mmc_cu_host.cu:2: **  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_cu_host.cu:8: *href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_cu_host.cu:9: **          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_cu_host.cu:10: **          in Pluker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175
mmc_cu_host.cu:14: *href="http://www.opticsinfobase.org/abstract.cfm?uri=oe-17-22-20178">
mmc_cu_host.cu:18: *20178-20190 (2009).
mmc_cu_host.cu:74:    uint meshlen = ((cfg->method == rtBLBadouelGrid) ? cfg->crop0.z : mesh->ne)
mmc_cu_host.cu:75:                   << cfg->nbuffer; // use 4 copies to reduce racing
mmc_cu_host.cu:76:    cfg->crop0.w = meshlen * cfg->maxgate; // offset for the second buffer
mmc_cu_host.cu:84:    uint detreclen = (2 + ((cfg->ismomentum) > 0)) * mesh->prop +
mmc_cu_host.cu:85:                     (cfg->issaveexit > 0) * 6 + 1;
mmc_cu_host.cu:88:    MCXParam param = {make_float3(cfg->srcpos.x, cfg->srcpos.y, cfg->srcpos.z),
mmc_cu_host.cu:89:                      make_float3(cfg->srcdir.x, cfg->srcdir.y, cfg->srcdir.z),
mmc_cu_host.cu:90:                      cfg->tstart,
mmc_cu_host.cu:91:                      cfg->tend,
mmc_cu_host.cu:92:                      (uint)cfg->isreflect,
mmc_cu_host.cu:93:                      (uint)cfg->issavedet,
mmc_cu_host.cu:94:                      (uint)cfg->issaveexit,
mmc_cu_host.cu:95:                      (uint)cfg->ismomentum,
mmc_cu_host.cu:96:                      (uint)cfg->isatomic,
mmc_cu_host.cu:97:                      (uint)cfg->isspecular,
mmc_cu_host.cu:98:                      1.f / cfg->tstep,
mmc_cu_host.cu:99:                      cfg->minenergy,
mmc_cu_host.cu:100:                      cfg->maxdetphoton,
mmc_cu_host.cu:101:                      (uint)mesh->prop,
mmc_cu_host.cu:102:                      (uint)cfg->detnum,
mmc_cu_host.cu:103:                      (int)cfg->voidtime,
mmc_cu_host.cu:104:                      (int)cfg->srctype,
mmc_cu_host.cu:105:                      cfg->srcparam1,
mmc_cu_host.cu:106:                      cfg->srcparam2,
mmc_cu_host.cu:107:                      (uint)cfg->issaveref,
mmc_cu_host.cu:108:                      (uint)cfg->maxgate,
mmc_cu_host.cu:109:                      (uint)cfg->debuglevel,
mmc_cu_host.cu:111:                      cfg->outputtype,
mmc_cu_host.cu:112:                      mesh->elemlen,
mmc_cu_host.cu:113:                      cfg->mcmethod,
mmc_cu_host.cu:114:                      cfg->method,
mmc_cu_host.cu:115:                      1.f / cfg->unitinmm,
mmc_cu_host.cu:116:                      cfg->srcdir.w,
mmc_cu_host.cu:117:                      mesh->nn,
mmc_cu_host.cu:118:                      mesh->ne,
mmc_cu_host.cu:119:                      mesh->nf,
mmc_cu_host.cu:120:                      make_float3(mesh->nmin.x, mesh->nmin.y, mesh->nmin.z),
mmc_cu_host.cu:121:                      cfg->nout,
mmc_cu_host.cu:122:                      cfg->roulettesize,
mmc_cu_host.cu:123:                      cfg->srcnum,
mmc_cu_host.cu:124:                      cfg->crop0,
mmc_cu_host.cu:125:                      mesh->srcelemlen,
mmc_cu_host.cu:126:                      cfg->bary0,
mmc_cu_host.cu:127:                      cfg->e0,
mmc_cu_host.cu:128:                      cfg->isextdet,
mmc_cu_host.cu:130:                      cfg->nbuffer,
mmc_cu_host.cu:131:                      (uint)(mesh->prop + 1 + cfg->isextdet) + cfg->detnum,
mmc_cu_host.cu:132:                      (uint)(MIN((MAX_PROP - (mesh->prop + 1 + cfg->isextdet) - cfg->detnum), ((mesh->ne) << 2)) >> 2), /*max count of elem normal data in const mem*/
mmc_cu_host.cu:133:                      cfg->issaveseed,
mmc_cu_host.cu:134:                      cfg->seed
mmc_cu_host.cu:140:        cfg->debuglevel = cfg->debuglevel & (~MCX_DEBUG_PROGRESS);
mmc_cu_host.cu:147:    if (threadid < MAX_DEVICE && cfg->deviceid[threadid] == '\0') {
mmc_cu_host.cu:151:    gpuid = cfg->deviceid[threadid] - 1;
mmc_cu_host.cu:154:        mcx_error(-1, "GPU ID must be non-zero", __FILE__, __LINE__);
mmc_cu_host.cu:161:        if (cfg->exportfield == NULL) {
mmc_cu_host.cu:162:            cfg->exportfield = mesh->weight;
mmc_cu_host.cu:165:        if (cfg->exportdetected == NULL) {
mmc_cu_host.cu:166:            cfg->exportdetected = (float*)malloc(hostdetreclen * cfg->maxdetphoton * sizeof(float));
mmc_cu_host.cu:169:        if (cfg->issaveseed && cfg->exportseed == NULL) {
mmc_cu_host.cu:170:            cfg->exportseed = (unsigned char*)malloc(cfg->maxdetphoton * (sizeof(RandType) * RAND_BUF_LEN));
mmc_cu_host.cu:173:        cfg->energytot = 0.f;
mmc_cu_host.cu:174:        cfg->energyesc = 0.f;
mmc_cu_host.cu:175:        cfg->runtime = 0;
mmc_cu_host.cu:181:                      sizeof(float) * cfg->maxdetphoton * hostdetreclen +
mmc_cu_host.cu:183:        gpu[gpuid].maxgate = (gpu[gpuid].globalmem - needmem) / meshlen;
mmc_cu_host.cu:185:            MIN(((cfg->tend - cfg->tstart) / cfg->tstep + 0.5), gpu[gpuid].maxgate);
mmc_cu_host.cu:188:    if (!cfg->autopilot) {
mmc_cu_host.cu:189:        uint gates = (uint)((cfg->tend - cfg->tstart) / cfg->tstep + 0.5);
mmc_cu_host.cu:190:        gpu[gpuid].autothread = cfg->nthread;
mmc_cu_host.cu:191:        gpu[gpuid].autoblock = cfg->nblocksize;
mmc_cu_host.cu:193:        if (cfg->maxgate == 0) {
mmc_cu_host.cu:194:            cfg->maxgate = gates;
mmc_cu_host.cu:195:        } else if ((uint)cfg->maxgate > gates) {
mmc_cu_host.cu:196:            cfg->maxgate = gates;
mmc_cu_host.cu:199:        gpu[gpuid].maxgate = cfg->maxgate;
mmc_cu_host.cu:208:    uint nflen = mesh->nf * cfg->maxgate;
mmc_cu_host.cu:212:    for (i = 0; cfg->deviceid[i]; i++) {
mmc_cu_host.cu:213:        fullload += cfg->workload[i];
mmc_cu_host.cu:217:        for (i = 0; cfg->deviceid[i]; i++) {
mmc_cu_host.cu:218:            cfg->workload[i] = gpu[cfg->deviceid[i] - 1].core;
mmc_cu_host.cu:226:    for (i = 0; cfg->deviceid[i]; i++)
mmc_cu_host.cu:227:        if (cfg->workload[i] > 0.f) {
mmc_cu_host.cu:228:            fullload += cfg->workload[i];
mmc_cu_host.cu:230:            mcx_error(-1, "workload was unspecified for an active device", __FILE__, __LINE__);
mmc_cu_host.cu:234:    threadphoton = (int)(cfg->nphoton * cfg->workload[gpuid] /
mmc_cu_host.cu:235:                         (fullload * gpu[gpuid].autothread * cfg->respin));
mmc_cu_host.cu:237:        (int)(cfg->nphoton * cfg->workload[gpuid] / (fullload * cfg->respin) -
mmc_cu_host.cu:239:    field = (float*)calloc(sizeof(float) * meshlen * 2, cfg->maxgate);
mmc_cu_host.cu:240:    dref = (float*)calloc(sizeof(float) * mesh->nf, cfg->maxgate);
mmc_cu_host.cu:241:    Pdet = (float*)calloc(cfg->maxdetphoton * sizeof(float), hostdetreclen);
mmc_cu_host.cu:245:    fieldlen = meshlen * cfg->maxgate;
mmc_cu_host.cu:247:    if (cfg->seed > 0) {
mmc_cu_host.cu:248:        srand(cfg->seed);
mmc_cu_host.cu:256:    CUDA_ASSERT(cudaMalloc((void**)&gnode, sizeof(float3) * (mesh->nn)));
mmc_cu_host.cu:257:    CUDA_ASSERT(cudaMemcpy(gnode, mesh->node, sizeof(float3) * (mesh->nn),
mmc_cu_host.cu:260:    CUDA_ASSERT(cudaMalloc((void**)&gelem, sizeof(int4) * (mesh->ne)));
mmc_cu_host.cu:261:    CUDA_ASSERT(cudaMemcpy(gelem, mesh->elem, sizeof(int4) * (mesh->ne),
mmc_cu_host.cu:264:    CUDA_ASSERT(cudaMalloc((void**)&gtype, sizeof(int) * (mesh->ne)));
mmc_cu_host.cu:265:    CUDA_ASSERT(cudaMemcpy(gtype, mesh->type, sizeof(int) * (mesh->ne),
mmc_cu_host.cu:268:    CUDA_ASSERT(cudaMalloc((void**)&gfacenb, sizeof(int4) * (mesh->ne)));
mmc_cu_host.cu:269:    CUDA_ASSERT(cudaMemcpy(gfacenb, mesh->facenb, sizeof(int4) * (mesh->ne),
mmc_cu_host.cu:272:    if (mesh->srcelemlen > 0) {
mmc_cu_host.cu:273:        CUDA_ASSERT(cudaMalloc((void**)&gsrcelem, sizeof(int) * (mesh->srcelemlen)));
mmc_cu_host.cu:274:        CUDA_ASSERT(cudaMemcpy(gsrcelem, mesh->srcelem,
mmc_cu_host.cu:275:                               sizeof(int) * (mesh->srcelemlen),
mmc_cu_host.cu:281:    CUDA_ASSERT(cudaMalloc((void**)&gnormal, sizeof(float4) * (mesh->ne) * 4));
mmc_cu_host.cu:282:    CUDA_ASSERT(cudaMemcpy(gnormal, tracer->n, sizeof(float4) * (mesh->ne) * 4,
mmc_cu_host.cu:287:    CUDA_ASSERT(cudaMemcpyToSymbol(gmed, mesh->med,
mmc_cu_host.cu:288:                                   (mesh->prop + 1 + cfg->isextdet) * sizeof(Medium), 0,
mmc_cu_host.cu:291:    if (cfg->detpos && cfg->detnum) {
mmc_cu_host.cu:292:        if ((mesh->prop + 1 + cfg->isextdet) + cfg->detnum >= MAX_PROP) {
mmc_cu_host.cu:293:            mcx_error(-5, "Total tissue type and detector count must be less than 2000", __FILE__, __LINE__);
mmc_cu_host.cu:296:        CUDA_ASSERT(cudaMemcpyToSymbol(gmed, cfg->detpos,
mmc_cu_host.cu:297:                                       sizeof(float4)*cfg->detnum, (mesh->prop + 1 + cfg->isextdet) * sizeof(Medium),
mmc_cu_host.cu:301:    CUDA_ASSERT(cudaMemcpyToSymbol(gmed, tracer->n,
mmc_cu_host.cu:333:                           sizeof(float) * cfg->maxdetphoton * hostdetreclen));
mmc_cu_host.cu:335:                           sizeof(float) * cfg->maxdetphoton * hostdetreclen,
mmc_cu_host.cu:351:    if (cfg->srctype == MCX_SRC_PATTERN) {
mmc_cu_host.cu:353:                               sizeof(float) * (int)(cfg->srcparam1.w * cfg->srcparam2.w)));
mmc_cu_host.cu:354:        CUDA_ASSERT(cudaMemcpy(gsrcpattern, cfg->srcpattern,
mmc_cu_host.cu:355:                               sizeof(float) * (int)(cfg->srcparam1.w * cfg->srcparam2.w),
mmc_cu_host.cu:357:    } else if (cfg->srctype == MCX_SRC_PATTERN3D) {
mmc_cu_host.cu:359:                               sizeof(float) * (int)(cfg->srcparam1.x * cfg->srcparam1.y*
mmc_cu_host.cu:360:                                       cfg->srcparam1.z)));
mmc_cu_host.cu:361:        CUDA_ASSERT(cudaMemcpy(gsrcpattern, cfg->srcpattern,
mmc_cu_host.cu:362:                               sizeof(float) * (int)(cfg->srcparam1.x * cfg->srcparam1.y*
mmc_cu_host.cu:363:                                       cfg->srcparam1.z),
mmc_cu_host.cu:369:    if (cfg->issaveseed) {
mmc_cu_host.cu:370:        Pphotonseed = (RandType*)calloc(cfg->maxdetphoton, (sizeof(RandType) * RAND_BUF_LEN));
mmc_cu_host.cu:371:        CUDA_ASSERT(cudaMalloc((void**)&gphotonseed, cfg->maxdetphoton * (sizeof(RandType)*RAND_BUF_LEN)));
mmc_cu_host.cu:374:    if (cfg->seed == SEED_FROM_FILE) {
mmc_cu_host.cu:375:        CUDA_ASSERT(cudaMalloc((void**)&greplayweight, sizeof(float)*cfg->nphoton));
mmc_cu_host.cu:376:        CUDA_ASSERT(cudaMemcpy(greplayweight, cfg->replayweight, sizeof(float)*cfg->nphoton, cudaMemcpyHostToDevice));
mmc_cu_host.cu:378:        CUDA_ASSERT(cudaMalloc((void**)&greplaytime, sizeof(float)*cfg->nphoton));
mmc_cu_host.cu:379:        CUDA_ASSERT(cudaMemcpy(greplaytime, cfg->replaytime, sizeof(float)*cfg->nphoton, cudaMemcpyHostToDevice));
mmc_cu_host.cu:381:        CUDA_ASSERT(cudaMalloc((void**)&greplayseed, (sizeof(RandType)*RAND_BUF_LEN)*cfg->nphoton));
mmc_cu_host.cu:382:        CUDA_ASSERT(cudaMemcpy(greplayseed, cfg->photonseed, (sizeof(RandType)*RAND_BUF_LEN)*cfg->nphoton, cudaMemcpyHostToDevice));
mmc_cu_host.cu:395:            cfg->flog, "- variant name: [%s] compiled by nvcc [%d.%d] with CUDA [%d]\n",
mmc_cu_host.cu:399:            cfg->flog, "- code name: [Vanilla MCX] compiled by nvcc [%d.%d] with CUDA [%d]\n",
mmc_cu_host.cu:402:        MMC_FPRINTF(cfg->flog, "- compiled with: [RNG] %s [Seed Length] %d\n",
mmc_cu_host.cu:404:        fflush(cfg->flog);
mmc_cu_host.cu:408:    MMC_FPRINTF(cfg->flog,
mmc_cu_host.cu:409:                "- [device %d(%d): %s] threadph=%d oddphotons=%d np=%.1f "
mmc_cu_host.cu:412:                oddphotons, cfg->nphoton * cfg->workload[gpuid] / fullload,
mmc_cu_host.cu:414:                cfg->respin);
mmc_cu_host.cu:416:    // simulate for all time-gates in maxgate groups per run
mmc_cu_host.cu:420:    for (t = cfg->tstart; t < cfg->tend; t += cfg->tstep * cfg->maxgate) {
mmc_cu_host.cu:422:        twindow1 = t + cfg->tstep * cfg->maxgate;
mmc_cu_host.cu:424:        MMC_FPRINTF(cfg->flog,
mmc_cu_host.cu:427:        fflush(cfg->flog);
mmc_cu_host.cu:431:        for (int iter = 0; iter < cfg->respin; iter++) {
mmc_cu_host.cu:432:            MMC_FPRINTF(cfg->flog, "simulation run#%2d ... \n", iter + 1);
mmc_cu_host.cu:433:            fflush(cfg->flog);
mmc_cu_host.cu:434:            fflush(cfg->flog);
mmc_cu_host.cu:441:            if (cfg->issavedet) {
mmc_cu_host.cu:453:                if ((cfg->debuglevel & MCX_DEBUG_PROGRESS)) {
mmc_cu_host.cu:454:                    int p0 = 0, ndone = -1;
mmc_cu_host.cu:456:                    progressfun(-0.f, handle);
mmc_cu_host.cu:471:                    MMC_FPRINTF(cfg->flog, "\n");
mmc_cu_host.cu:476:            toc += tic1 - tic0;
mmc_cu_host.cu:477:            MMC_FPRINTF(cfg->flog,
mmc_cu_host.cu:479:                        tic1 - tic);
mmc_cu_host.cu:480:            fflush(cfg->flog);
mmc_cu_host.cu:483:            if (cfg->runtime < tic1 - tic) {
mmc_cu_host.cu:484:                cfg->runtime = tic1 - tic;
mmc_cu_host.cu:492:            if (cfg->issavedet) {
mmc_cu_host.cu:495:                CUDA_ASSERT(cudaMemcpy(Pdet, gdetphoton, sizeof(float) * cfg->maxdetphoton * hostdetreclen,
mmc_cu_host.cu:498:                if (cfg->issaveseed) {
mmc_cu_host.cu:499:                    CUDA_ASSERT(cudaMemcpy(Pphotonseed, gphotonseed, cfg->maxdetphoton * (sizeof(RandType)*RAND_BUF_LEN),
mmc_cu_host.cu:503:                if (detected > cfg->maxdetphoton) {
mmc_cu_host.cu:504:                    MMC_FPRINTF(cfg->flog, "WARNING: the detected photon (%d) \
mmc_cu_host.cu:505:              is more than what your have specified (%d), please use the -H option to specify a greater number\t",
mmc_cu_host.cu:506:                                detected, cfg->maxdetphoton);
mmc_cu_host.cu:508:                    MMC_FPRINTF(cfg->flog, "detected %d photons, total: %d\t", detected,
mmc_cu_host.cu:509:                                cfg->detectedcount + detected);
mmc_cu_host.cu:513:                cfg->his.detected += detected;
mmc_cu_host.cu:514:                detected = MIN(detected, cfg->maxdetphoton);
mmc_cu_host.cu:516:                if (cfg->exportdetected) {
mmc_cu_host.cu:519:                        cfg->exportdetected = (float*)realloc(
mmc_cu_host.cu:520:                            cfg->exportdetected, (cfg->detectedcount + detected) *
mmc_cu_host.cu:522:                        memcpy(cfg->exportdetected + cfg->detectedcount * (hostdetreclen),
mmc_cu_host.cu:525:                        if (cfg->issaveseed) {
mmc_cu_host.cu:526:                            cfg->exportseed = (unsigned char*)realloc(cfg->exportseed, (cfg->detectedcount + detected) * (sizeof(RandType) * RAND_BUF_LEN));
mmc_cu_host.cu:527:                            memcpy(cfg->exportseed + cfg->detectedcount * sizeof(RandType)*RAND_BUF_LEN, Pphotonseed, detected * (sizeof(RandType)*RAND_BUF_LEN));
mmc_cu_host.cu:530:                        cfg->detectedcount += detected;
mmc_cu_host.cu:535:            if (cfg->issaveref) {
mmc_cu_host.cu:549:            if (cfg->issave2pt) {
mmc_cu_host.cu:554:                MMC_FPRINTF(cfg->flog, "transfer complete:        %d ms\n",
mmc_cu_host.cu:555:                            GetTimeMillis() - tic);
mmc_cu_host.cu:556:                fflush(cfg->flog);
mmc_cu_host.cu:559:                    field[(i >> cfg->nbuffer)] += rawfield[i] + rawfield[i + fieldlen];    //+rawfield[i+fieldlen];
mmc_cu_host.cu:572:                        cfg->energyesc += energy[(i << 1)];
mmc_cu_host.cu:573:                        cfg->energytot += energy[(i << 1) + 1];
mmc_cu_host.cu:581:            if (cfg->respin > 1 && RAND_SEED_WORD_LEN > 1) {
mmc_cu_host.cu:603:        fieldlen = (fieldlen >> cfg->nbuffer);
mmc_cu_host.cu:606:        if (cfg->exportfield) {
mmc_cu_host.cu:607:            if (cfg->basisorder == 0 || cfg->method == rtBLBadouelGrid) {
mmc_cu_host.cu:610:                    cfg->exportfield[i] += field[i];
mmc_cu_host.cu:612:                for (i = 0; i < cfg->maxgate; i++)
mmc_cu_host.cu:613:                    for (j = 0; j < mesh->ne; j++) {
mmc_cu_host.cu:614:                        float ww = field[i * mesh->ne + j] * 0.25f;
mmc_cu_host.cu:616:                        for (int k = 0; k < mesh->elemlen; k++)
mmc_cu_host.cu:617:                            cfg->exportfield[i * mesh->nn +
mmc_cu_host.cu:618:                                               mesh->elem[j * mesh->elemlen + k] - 1] += ww;
mmc_cu_host.cu:623:        if (cfg->issaveref && mesh->dref) {
mmc_cu_host.cu:625:                mesh->dref[i] += dref[i];
mmc_cu_host.cu:629:        if (cfg->isnormalized) {
mmc_cu_host.cu:630:            MMC_FPRINTF(cfg->flog, "normalizing raw data ...\t");
mmc_cu_host.cu:631:            fflush(cfg->flog);
mmc_cu_host.cu:633:            cfg->energyabs = cfg->energytot - cfg->energyesc;
mmc_cu_host.cu:634:            mesh_normalize(mesh, cfg, cfg->energyabs, cfg->energytot, 0);
mmc_cu_host.cu:637:        if (cfg->issave2pt && cfg->parentid == mpStandalone) {
mmc_cu_host.cu:638:            MMC_FPRINTF(cfg->flog, "saving data to file ...\t");
mmc_cu_host.cu:640:            MMC_FPRINTF(cfg->flog, "saving data complete : %d ms\n\n",
mmc_cu_host.cu:641:                        GetTimeMillis() - tic);
mmc_cu_host.cu:642:            fflush(cfg->flog);
mmc_cu_host.cu:645:        if (cfg->issavedet && cfg->parentid == mpStandalone &&
mmc_cu_host.cu:646:                cfg->exportdetected) {
mmc_cu_host.cu:647:            cfg->his.unitinmm = cfg->unitinmm;
mmc_cu_host.cu:648:            cfg->his.savedphoton = cfg->detectedcount;
mmc_cu_host.cu:649:            cfg->his.detected = cfg->detectedcount;
mmc_cu_host.cu:650:            mesh_savedetphoton(cfg->exportdetected, (void*)(cfg->exportseed), cfg->detectedcount,
mmc_cu_host.cu:654:        if (cfg->issaveref) {
mmc_cu_host.cu:655:            MMC_FPRINTF(cfg->flog, "saving surface diffuse reflectance ...");
mmc_cu_host.cu:661:        MMC_FPRINTF(cfg->flog,
mmc_cu_host.cu:662:                    "simulated %ld photons (%ld) with devices (ray-tet "
mmc_cu_host.cu:664:                    cfg->nphoton, cfg->nphoton, reporter.raytet,
mmc_cu_host.cu:665:                    (double)cfg->nphoton / toc);
mmc_cu_host.cu:666:        MMC_FPRINTF(cfg->flog,
mmc_cu_host.cu:669:                    cfg->energytot,
mmc_cu_host.cu:670:                    (cfg->energytot - cfg->energyesc) / cfg->energytot * 100.f);
mmc_cu_host.cu:671:        fflush(cfg->flog);
mmc_cu_host.cu:733:        mcx_error(-1, "No GPU device found\n", __FILE__, __LINE__);
mmc_rand_sfmt.h:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_rand_sfmt.h:5:**  \copyright Qianqian Fang, 2010-2021
mmc_rand_sfmt.h:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_rand_sfmt.h:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_rand_sfmt.h:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_rand_sfmt.h:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_rand_sfmt.h:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_rand_sfmt.h:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_rand_sfmt.h:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_rand_sfmt.h:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_rand_sfmt.h:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_rand_sfmt.h:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_rand_sfmt.h:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_rand_sfmt.h:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_rand_sfmt.h:35:\brief   An interface to use the SFMT-19937 random number generator
Makefile:11:  EXTRALIB:=-static-libgcc -lgcc_eh
Makefile:17:USERCCFLAGS=-DUSE_OS_TIMER -DUSE_OPENCL -DMMC_XORSHIFT -DUSE_OPTIX 
Makefile:19:DUMMY:=$(shell mkdir -p built/cjson)
Makefile:23:    USERCCFLAGS+=-DUSE_CUDA
Makefile:24:    CUCCOPT= -DUSE_ATOMIC -DMCX_SAVE_DETECTORS -DMCX_DO_REFLECTION -DUSE_DMMC -DUSE_BLBADOUEL -DUSE_CUDA
Makefile:25:    EXTRALIB+=-lcudart
mmc_cl_host.h:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_cl_host.h:5:**  \copyright Qianqian Fang, 2010-2021
mmc_cl_host.h:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_cl_host.h:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_cl_host.h:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_cl_host.h:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_cl_host.h:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_cl_host.h:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_cl_host.h:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_cl_host.h:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_cl_host.h:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_cl_host.h:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_cl_host.h:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_cl_host.h:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_cl_host.h:35:\brief   Definitions of mmc high-level driver functions for OpenCL backend
mmc_cl_host.h:89:    cl_int    reclen;                 /**< record (4-byte per record) number per detected photon */
mmc_core.cl:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_core.cl:5:**  \copyright Qianqian Fang, 2010-2021
mmc_core.cl:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_core.cl:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_core.cl:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_core.cl:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_core.cl:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_core.cl:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_core.cl:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_core.cl:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_core.cl:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_core.cl:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_core.cl:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_core.cl:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_core.cl:40:    return make_float3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
mmc_core.cl:72:inline __device__ __host__ float3 operator -(float3 a, float3 b) {
mmc_core.cl:73:    return make_float3(a.x - b.x, a.y - b.y, a.z - b.z);
mmc_core.cl:75:inline __device__ __host__ void operator -=(float3& b, float3 a) {
mmc_core.cl:76:    b.x -= a.x;
mmc_core.cl:77:    b.y -= a.y;
mmc_core.cl:78:    b.z -= a.z;
mmc_core.cl:95:inline __device__ __host__ float4 operator -(float4 a) {
mmc_core.cl:96:    return make_float4(-a.x, -a.y, -a.z, -a.w);
mmc_core.cl:122:inline __device__ __host__ float4 operator -(float4 a, float4 b) {
mmc_core.cl:123:    return make_float4(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
mmc_core.cl:125:inline __device__ __host__ void operator -=(float4& b, float4 a) {
mmc_core.cl:126:    b.x -= a.x;
mmc_core.cl:127:    b.y -= a.y;
mmc_core.cl:128:    b.z -= a.z;
mmc_core.cl:129:    b.w -= a.w;
mmc_core.cl:182:#define FLT_EPSILON   1.19209290E-07F
mmc_core.cl:240:#define R_C0               3.335640951981520e-12f  //1/C0 in s/mm
mmc_core.cl:243:#define SAME_VOXEL         -9999.f                 //scatter within a voxel
mmc_core.cl:249:    #define EPS                FLT_EPSILON             //round-off limit
mmc_core.cl:258:#define FIX_PHOTON         1e-3f      /**< offset to the ray to avoid edge/vertex */
mmc_core.cl:265:#define SEED_FROM_FILE      -999                         /**< special flag indicating to load seeds from history file */
mmc_core.cl:279:    float photontimer;            /**< the total time-of-fly of the photon */
mmc_core.cl:309:    int    reclen;                 /**< record (4-byte per record) number per detected photon */
mmc_core.cl:348:#define GPU_PARAM(a,b) (a->b)
mmc_core.cl:355:    #define GPU_PARAM(a,b) (a->b)
mmc_core.cl:362:__constant__ int faceorder[] = {1, 3, 2, 0, -1};
mmc_core.cl:412:    return s1.f[0] - 1.0f;
mmc_core.cl:436:    return -MCX_MATHFUN(log)(rand_uniform01(t) + EPS);
mmc_core.cl:464:// http://suhorukov.blogspot.co.uk/2011/12/opencl-11-atomic-operations-on-floating.html
mmc_core.cl:465:// https://devtalk.nvidia.com/default/topic/458062/atomicadd-float-float-atomicmul-float-float-/
mmc_core.cl:511:        if ((gmed[i].x - p0[0].x) * (gmed[i].x - p0[0].x) +
mmc_core.cl:512:                (gmed[i].y - p0[0].y) * (gmed[i].y - p0[0].y) +
mmc_core.cl:513:                (gmed[i].z - p0[0].z) * (gmed[i].z - p0[0].z) < gmed[i].w * gmed[i].w) {
mmc_core.cl:514:            return i - GPU_PARAM(gcfg, maxmedia) - GPU_PARAM(gcfg, isextdet);
mmc_core.cl:550:                n_det[baseaddr++] = p0->x;
mmc_core.cl:551:                n_det[baseaddr++] = p0->y;
mmc_core.cl:552:                n_det[baseaddr++] = p0->z;
mmc_core.cl:553:                n_det[baseaddr++] = v->x;
mmc_core.cl:554:                n_det[baseaddr++] = v->y;
mmc_core.cl:555:                n_det[baseaddr++] = v->z;
mmc_core.cl:558:            n_det[baseaddr++] = ppath[GPU_PARAM(gcfg, reclen) - 1]; // save partial pathlength to the memory
mmc_core.cl:565: * \brief Branch-less Badouel-based SSE4 ray-tracer to advance photon by one step
mmc_core.cl:567: * this function uses Branch-less Badouel-based SSE4 ray-triangle intersection
mmc_core.cl:569: * Branch-less Badouel algorithms do not calculate the Barycentric coordinates
mmc_core.cl:570: * and can only store energy loss using 0-th order basis function. This function
mmc_core.cl:571: * is the fastest among the 4 ray-tracers.
mmc_core.cl:574: * \param[in] tracer: the ray-tracer aux data structure
mmc_core.cl:584:    int tshift, faceidx = -1, eid;
mmc_core.cl:592:    if (r->eid <= 0) {
mmc_core.cl:593:        return -1;
mmc_core.cl:596:    eid = (r->eid - 1) << 2;
mmc_core.cl:598:    r->pout.x = MMC_UNDEFINED;
mmc_core.cl:599:    r->faceid = -1;
mmc_core.cl:600:    r->isend = 0;
mmc_core.cl:602:    if (r->eid <= GPU_PARAM(gcfg, normbuf)) {
mmc_core.cl:604:        S = ((r->vec.x) * ((__constant float4*)gmed)[eid]) + ((r->vec.y) * ((__constant float4*)gmed)[eid + 1]) + ((r->vec.z) * ((__constant float4*)gmed)[eid + 2]);
mmc_core.cl:605:        T = ((__constant float4*)gmed)[eid + 3] - (((r->p0.x) * ((__constant float4*)gmed)[eid]) + ((r->p0.y) * ((__constant float4*)gmed)[eid + 1]) + ((r->p0.z) * ((__constant float4*)gmed)[eid + 2]));
mmc_core.cl:607:        S = ((r->vec.x) * normal[eid]) + ((r->vec.y) * normal[eid + 1]) + ((r->vec.z) * normal[eid + 2]);
mmc_core.cl:608:        T = normal[eid + 3] - (((r->p0.x) * normal[eid]) + ((r->p0.y) * normal[eid + 1]) + ((r->p0.z) * normal[eid + 2]));
mmc_core.cl:612:    T = -convert_float4_rte(isgreater(T, FL4(0.f)) * 2) * FL4(0.5f) * T;
mmc_core.cl:617:    S = -convert_float4_rte(isgreater(S, FL4(0.f)) * 2) * FL4(0.5f);
mmc_core.cl:618:    T =  (S * T) + ((FL4(1.f) - S) * FL4(1e10f));
mmc_core.cl:622:    eid = r->eid - 1;
mmc_core.cl:626:    r->faceid = faceorder[faceidx];
mmc_core.cl:628:    if (r->faceid >= 0 && Lmin >= 0.f) {
mmc_core.cl:632:        currweight.f = r->weight;
mmc_core.cl:634:        r->Lmove = (prop.mus <= EPS) ? R_MIN_MUS : r->slen / prop.mus;
mmc_core.cl:635:        r->isend = (Lmin > r->Lmove);
mmc_core.cl:636:        r->Lmove = ((r->isend) ? r->Lmove : Lmin);
mmc_core.cl:637:        r->pout = r->p0 + FL3(Lmin) * r->vec;
mmc_core.cl:639:        if ((int)((r->photontimer + r->Lmove * (prop.n * R_C0) - gcfg->tstart)*GPU_PARAM(gcfg, Rtstep)) > GPU_PARAM(gcfg, maxgate) - 1) { /*exit time window*/
mmc_core.cl:640:            r->faceid = -2;
mmc_core.cl:641:            r->pout.x = MMC_UNDEFINED;
mmc_core.cl:642:            r->Lmove = (gcfg->tend - r->photontimer) / (prop.n * R_C0) - 1e-4f;
mmc_core.cl:645:        totalloss = MCX_MATHFUN(exp)(-prop.mua * r->Lmove);
mmc_core.cl:646:        r->weight *= totalloss;
mmc_core.cl:648:        totalloss = 1.f - totalloss; /*remaining fraction*/
mmc_core.cl:652:                currweight.f = r->Lmove;
mmc_core.cl:653:                currweight.f *= replayweight[r->photonid];
mmc_core.cl:654:                currweight.f += r->weight;
mmc_core.cl:656:                if (r->slen0 < EPS) {
mmc_core.cl:659:                    currweight.f = r->Lmove * prop.mus / r->slen0;
mmc_core.cl:662:                currweight.f *= replayweight[r->photonid];
mmc_core.cl:663:                currweight.f += r->weight;
mmc_core.cl:667:        r->slen -= r->Lmove * prop.mus;
mmc_core.cl:668:        ww = currweight.f - r->weight;
mmc_core.cl:669:        r->photontimer += r->Lmove * (prop.n * R_C0);
mmc_core.cl:672:            tshift = MIN( ((int)(replaytime[r->photonid] * GPU_PARAM(gcfg, Rtstep))), GPU_PARAM(gcfg, maxgate) - 1 ) * GPU_PARAM(gcfg, framelen);
mmc_core.cl:674:            tshift = MIN( ((int)((r->photontimer - gcfg->tstart) * GPU_PARAM(gcfg, Rtstep))), GPU_PARAM(gcfg, maxgate) - 1 ) * GPU_PARAM(gcfg, framelen);
mmc_core.cl:692:                r->oldidx = (r->oldidx == ID_UNDEFINED) ? newidx : r->oldidx;
mmc_core.cl:694:                if (newidx != r->oldidx) {
mmc_core.cl:697:                    if (r->oldweight > 0.f) {
mmc_core.cl:699:                        float oldval = atomicadd(weight + r->oldidx, r->oldweight);
mmc_core.cl:702:                            if (atomicadd(weight + r->oldidx, -oldval) < 0.0f) {
mmc_core.cl:703:                                atomicadd(weight + r->oldidx, oldval);
mmc_core.cl:705:                                atomicadd(weight + r->oldidx + gcfg->crop0.w, oldval);
mmc_core.cl:710:                        weight[r->oldidx] += r->oldweight;
mmc_core.cl:715:                    r->oldidx = newidx;
mmc_core.cl:716:                    r->oldweight = ww;
mmc_core.cl:718:                    r->oldweight += ww;
mmc_core.cl:723:                if (r->faceid == -2 || !r->isend) {
mmc_core.cl:725:                    float oldval = atomicadd(weight + newidx, r->oldweight);
mmc_core.cl:728:                        if (atomicadd(weight + r->oldidx, -oldval) < 0.0f) {
mmc_core.cl:729:                            atomicadd(weight + r->oldidx, oldval);
mmc_core.cl:731:                            atomicadd(weight + r->oldidx + gcfg->crop0.w, oldval);
mmc_core.cl:736:                    weight[newidx] += r->oldweight;
mmc_core.cl:738:                    r->oldweight = 0.f;
mmc_core.cl:752:                eid = (int)(r->Lmove * GPU_PARAM(gcfg, dstep)) + 1; // number of segments
mmc_core.cl:754:                S.w = r->Lmove / eid;                 // segment length
mmc_core.cl:755:                T.w = MCX_MATHFUN(exp)(-prop.mua * S.w); // segment loss
mmc_core.cl:757:                T.xyz =  r->vec * FL3(S.w);      // delta vector
mmc_core.cl:758:                S.xyz =  (r->p0 - gcfg->nmin) + (T.xyz * FL3(0.5f)); /*starting point*/
mmc_core.cl:760:                T =  make_float4(r->vec.x * S.w, r->vec.y * S.w, r->vec.z * S.w, T.w); // delta vector
mmc_core.cl:761:                S =  make_float4((r->p0.x - gcfg->nmin.x) + T.x * 0.5f, (r->p0.y - gcfg->nmin.y) + T.y * 0.5f, (r->p0.z - gcfg->nmin.z) + T.z * 0.5f, S.w); /*starting point*/
mmc_core.cl:763:                totalloss = (totalloss == 0.f) ? 0.f : (1.f - T.w) / totalloss; // fraction of total loss per segment
mmc_core.cl:775:                    uint newidx = (idx.z * gcfg->crop0.y + idx.y * gcfg->crop0.x + idx.x) + tshift;
mmc_core.cl:776:                    r->oldidx = (r->oldidx == ID_UNDEFINED) ? newidx : r->oldidx;
mmc_core.cl:778:                    if (newidx != r->oldidx) {
mmc_core.cl:781:                        float oldval = atomicadd(weight + r->oldidx, r->oldweight);
mmc_core.cl:784:                            if (atomicadd(weight + r->oldidx, -oldval) < 0.0f) {
mmc_core.cl:785:                                atomicadd(weight + r->oldidx, oldval);
mmc_core.cl:787:                                atomicadd(weight + r->oldidx + gcfg->crop0.w, oldval);
mmc_core.cl:792:                        weight[r->oldidx] += r->oldweight;
mmc_core.cl:795:                        r->oldidx = newidx;
mmc_core.cl:796:                        r->oldweight = S.w * totalloss;
mmc_core.cl:798:                        r->oldweight += S.w * totalloss;
mmc_core.cl:803:                    if (r->faceid == -2 || !r->isend) {
mmc_core.cl:805:                        float oldval = atomicadd(weight + r->oldidx, r->oldweight);
mmc_core.cl:808:                            if (atomicadd(weight + r->oldidx, -oldval) < 0.0f) {
mmc_core.cl:809:                                atomicadd(weight + r->oldidx, oldval);
mmc_core.cl:811:                                atomicadd(weight + r->oldidx + gcfg->crop0.w, oldval);
mmc_core.cl:816:                        weight[newidx] += r->oldweight;
mmc_core.cl:818:                        r->oldweight = 0.f;
mmc_core.cl:838:        r->p0 = r->p0 + FL3(r->Lmove) * r->vec;
mmc_core.cl:841:    return ((r->faceid == -2) ? 0.f : r->slen);
mmc_core.cl:854: * \param[in] tracer: the ray-tracer aux data structure
mmc_core.cl:867:    int offs = (*oldeid - 1) << 2;
mmc_core.cl:880:    n1 = ((*oldeid != *eid) ? gmed[type[*oldeid - 1]].n : GPU_PARAM(gcfg, nout));
mmc_core.cl:881:    n2 = ((*eid > 0) ? gmed[type[*eid - 1]].n : GPU_PARAM(gcfg, nout));
mmc_core.cl:885:    tmp2 = 1.f - tmp0 / tmp1 * (1.f - Icos * Icos); /*1-[n1/n2*sin(si)]^2 = cos(ti)^2*/
mmc_core.cl:891:        Rtotal = (Re - Im) / (Re + Im); /*Rp*/
mmc_core.cl:893:        Rtotal = (Rtotal + (Re - Im) / (Re + Im)) * 0.5f; /*(Rp+Rs)/2*/
mmc_core.cl:900:            *c0 += (FL3(-2.f * Icos)) * pnorm;
mmc_core.cl:901:            //if(GPU_PARAM(gcfg,debuglevel)&dlReflect) GPUDEBUG(("R %f %f %f %d %d %f\n",c0->x,c0->y,c0->z,*eid,*oldeid,Rtotal));
mmc_core.cl:906:            *c0 += (FL3(-Icos)) * pnorm;
mmc_core.cl:908:            //if(GPU_PARAM(gcfg,debuglevel)&dlReflect) GPUDEBUG(("Z %f %f %f %d %d %f\n",c0->x,c0->y,c0->z,*eid,*oldeid,1.f-Rtotal));
mmc_core.cl:911:        *c0 += (FL3(-2.f * Icos)) * pnorm;
mmc_core.cl:913:        //if(GPU_PARAM(gcfg,debuglevel)&dlReflect) GPUDEBUG(("V %f %f %f %d %d %f\n",c0->x,c0->y,c0->z,*eid,*oldeid,1.f));
mmc_core.cl:948:        tmp0 = (1.f - g * g) / (1.f - g + 2.f * g * rand_next_zangle(ran));
mmc_core.cl:950:        tmp0 = (1.f + g * g - tmp0) / (2.f * g);
mmc_core.cl:951:        tmp0 = clamp(tmp0, -1.f, 1.f);
mmc_core.cl:954:        stheta = MCX_MATHFUN(sqrt)(1.f - tmp0 * tmp0);
mmc_core.cl:958:        theta = acos(2.f * rand_next_zangle(ran) - 1.f);
mmc_core.cl:962:    if ( dir->z > -1.f + EPS && dir->z < 1.f - EPS ) {
mmc_core.cl:963:        tmp0 = 1.f - dir->z * dir->z; //reuse tmp to minimize registers
mmc_core.cl:967:        p.x = tmp1 * (dir->x * dir->z * cphi - dir->y * sphi) + dir->x * ctheta;
mmc_core.cl:968:        p.y = tmp1 * (dir->y * dir->z * cphi + dir->x * sphi) + dir->y * ctheta;
mmc_core.cl:969:        p.z = -tmp1 * tmp0 * cphi             + dir->z * ctheta;
mmc_core.cl:973:        p.z = (dir->z > 0.f) ? ctheta : -ctheta;
mmc_core.cl:977:        pmom[0] += (1.f - ctheta);
mmc_core.cl:980:    dir->x = p.x;
mmc_core.cl:981:    dir->y = p.y;
mmc_core.cl:982:    dir->z = p.z;
mmc_core.cl:987: * \brief Function to deal with ray-edge/ray-vertex intersections
mmc_core.cl:1003:        c0 += nodes[ee[i] - 1];
mmc_core.cl:1006:    *p += (c0 * FL3(0.25f) - *p) * (FL3(FIX_PHOTON));
mmc_core.cl:1024:    float3 origin = r->p0;
mmc_core.cl:1026:    r->slen = rand_next_scatlen(ran);
mmc_core.cl:1033:        if (r->eid > 0) {
mmc_core.cl:1044:        r->p0.x = gcfg->srcpos.x + rx * gcfg->srcparam1.x + ry * gcfg->srcparam2.x;
mmc_core.cl:1045:        r->p0.y = gcfg->srcpos.y + rx * gcfg->srcparam1.y + ry * gcfg->srcparam2.y;
mmc_core.cl:1046:        r->p0.z = gcfg->srcpos.z + rx * gcfg->srcparam1.z + ry * gcfg->srcparam2.z;
mmc_core.cl:1047:        r->weight = 1.f;
mmc_core.cl:1053:            int xsize = (int)gcfg->srcparam1.w;
mmc_core.cl:1054:            int ysize = (int)gcfg->srcparam2.w;
mmc_core.cl:1055:            r->posidx = MIN((int)(ry * ysize), ysize - 1) * xsize + MIN((int)(rx * xsize), xsize - 1);
mmc_core.cl:1056:            r->weight = srcpattern[MIN( (int)(ry * gcfg->srcparam2.w), (int)gcfg->srcparam2.w - 1 ) * (int)(gcfg->srcparam1.w) + MIN( (int)(rx * gcfg->srcparam1.w), (int)gcfg->srcparam1.w - 1 )];
mmc_core.cl:1062:            r->weight = (MCX_MATHFUN(cos)((floor(gcfg->srcparam1.w) * rx + floor(gcfg->srcparam2.w) * ry + gcfg->srcparam1.w - floor(gcfg->srcparam1.w)) * TWO_PI) * (1.f - gcfg->srcparam2.w + floor(gcfg->srcparam2.w)) + 1.f) * 0.5f;
mmc_core.cl:1065:        origin.x += (gcfg->srcparam1.x + gcfg->srcparam2.x) * 0.5f;
mmc_core.cl:1066:        origin.y += (gcfg->srcparam1.y + gcfg->srcparam2.y) * 0.5f;
mmc_core.cl:1067:        origin.z += (gcfg->srcparam1.z + gcfg->srcparam2.z) * 0.5f;
mmc_core.cl:1075:        float4 v2 = gcfg->srcparam1;
mmc_core.cl:1076:        v2.w *= MCX_MATHFUN(rsqrt)(gcfg->srcparam1.x * gcfg->srcparam1.x + gcfg->srcparam1.y * gcfg->srcparam1.y + gcfg->srcparam1.z * gcfg->srcparam1.z);
mmc_core.cl:1077:        v2.x = v2.w * (gcfg->srcdir.y * gcfg->srcparam1.z - gcfg->srcdir.z * gcfg->srcparam1.y);
mmc_core.cl:1078:        v2.y = v2.w * (gcfg->srcdir.z * gcfg->srcparam1.x - gcfg->srcdir.x * gcfg->srcparam1.z);
mmc_core.cl:1079:        v2.z = v2.w * (gcfg->srcdir.x * gcfg->srcparam1.y - gcfg->srcdir.y * gcfg->srcparam1.x);
mmc_core.cl:1080:        r->p0.x = gcfg->srcpos.x + rx * gcfg->srcparam1.x + ry * v2.x;
mmc_core.cl:1081:        r->p0.y = gcfg->srcpos.y + rx * gcfg->srcparam1.y + ry * v2.y;
mmc_core.cl:1082:        r->p0.z = gcfg->srcpos.z + rx * gcfg->srcparam1.z + ry * v2.z;
mmc_core.cl:1088:            r->weight = (MCX_MATHFUN(sin)((gcfg->srcparam2.x * rx + gcfg->srcparam2.z) * TWO_PI) * MCX_MATHFUN(sin)((gcfg->srcparam2.y * ry + gcfg->srcparam2.w) * TWO_PI) + 1.f) * 0.5f; //between 0 and 1
mmc_core.cl:1095:            r->weight = (MCX_MATHFUN(cos)((gcfg->srcparam2.x * rx + gcfg->srcparam2.y * ry + gcfg->srcparam2.z) * TWO_PI) * (1.f - gcfg->srcparam2.w) + 1.f) * 0.5f; //between 0 and 1
mmc_core.cl:1098:        origin.x += (gcfg->srcparam1.x + v2.x) * 0.5f;
mmc_core.cl:1099:        origin.y += (gcfg->srcparam1.y + v2.y) * 0.5f;
mmc_core.cl:1100:        origin.z += (gcfg->srcparam1.z + v2.z) * 0.5f;
mmc_core.cl:1102:#if defined(__NVCC__) || defined(MCX_SRC_DISK) || defined(MCX_SRC_GAUSSIAN) // uniform disk distribution or Gaussian-beam
mmc_core.cl:1116:            r0 = MCX_MATHFUN(sqrt)(rand_uniform01(ran)) * gcfg->srcparam1.x;
mmc_core.cl:1123:            if (fabs(GPU_PARAM(gcfg, focus)) < 1e-5f || fabs(gcfg->srcparam1.y) < 1e-5f) {
mmc_core.cl:1124:                r0 = MCX_MATHFUN(sqrt)(-MCX_MATHFUN(log)((rand_uniform01(ran)))) * gcfg->srcparam1.x;
mmc_core.cl:1126:                float z0 = gcfg->srcparam1.x * gcfg->srcparam1.x * M_PI / gcfg->srcparam1.y; //Rayleigh range
mmc_core.cl:1127:                r0 = MCX_MATHFUN(sqrt)(-MCX_MATHFUN(log)((rand_uniform01(ran)) * (1.f + (GPU_PARAM(gcfg, focus) * GPU_PARAM(gcfg, focus) / (z0 * z0))))) * gcfg->srcparam1.x;
mmc_core.cl:1136:        if (gcfg->srcdir.z > -1.f + EPS && gcfg->srcdir.z < 1.f - EPS) {
mmc_core.cl:1137:            float tmp0 = 1.f - gcfg->srcdir.z * gcfg->srcdir.z;
mmc_core.cl:1139:            r->p0.x = gcfg->srcpos.x + tmp1 * (gcfg->srcdir.x * gcfg->srcdir.z * cphi - gcfg->srcdir.y * sphi);
mmc_core.cl:1140:            r->p0.y = gcfg->srcpos.y + tmp1 * (gcfg->srcdir.y * gcfg->srcdir.z * cphi + gcfg->srcdir.x * sphi);
mmc_core.cl:1141:            r->p0.z = gcfg->srcpos.z - tmp1 * tmp0 * cphi;
mmc_core.cl:1143:            r->p0.x += r0 * cphi;
mmc_core.cl:1144:            r->p0.y += r0 * sphi;
mmc_core.cl:1156:#if defined(__NVCC__) || defined(MCX_SRC_CONE) // a solid-angle section of a uniform sphere
mmc_core.cl:1163:                ang = (gcfg->srcparam1.y > 0) ? TWO_PI * rand_uniform01(ran) : acos(2.f * rand_uniform01(ran) - 1.f); //sine distribution
mmc_core.cl:1164:            } while (ang > gcfg->srcparam1.x);
mmc_core.cl:1173:                ang = acos(2.f * rand_uniform01(ran) - 1.f);    //sine distribution
mmc_core.cl:1185:        r->vec.x = stheta * cphi;
mmc_core.cl:1186:        r->vec.y = stheta * sphi;
mmc_core.cl:1187:        r->vec.z = ctheta;
mmc_core.cl:1191:            if (r->eid > 0) {
mmc_core.cl:1204:        ang = MCX_MATHFUN(sqrt)(-2.f * MCX_MATHFUN(log)((rand_uniform01(ran)))) * (1.f - 2.f * rand_uniform01(ran)) * gcfg->srcparam1.x;
mmc_core.cl:1207:        r->vec.x = stheta * cphi;
mmc_core.cl:1208:        r->vec.y = stheta * sphi;
mmc_core.cl:1209:        r->vec.z = ctheta;
mmc_core.cl:1217:        r->p0.x += t * gcfg->srcparam1.x;
mmc_core.cl:1218:        r->p0.y += t * gcfg->srcparam1.y;
mmc_core.cl:1219:        r->p0.z += t * gcfg->srcparam1.z;
mmc_core.cl:1227:            t = 1.f - 2.f * rand_uniform01(ran);
mmc_core.cl:1228:            s = 1.f - 2.f * rand_uniform01(ran);
mmc_core.cl:1229:            p = MCX_MATHFUN(sqrt)(1.f - r->vec.x * r->vec.x - r->vec.y * r->vec.y) * (rand_uniform01(ran) > 0.5f ? 1.f : -1.f);
mmc_core.cl:1231:            vv.x = r->vec.y * p - r->vec.z * s;
mmc_core.cl:1232:            vv.y = r->vec.z * t - r->vec.x * p;
mmc_core.cl:1233:            vv.z = r->vec.x * s - r->vec.y * t;
mmc_core.cl:1234:            r->vec = vv;
mmc_core.cl:1235:            //*((float3*)&(r->vec))=(float3)(r->vec.y*p-r->vec.z*s,r->vec.z*t-r->vec.x*p,r->vec.x*s-r->vec.y*t);
mmc_core.cl:1241:        origin.x += (gcfg->srcparam1.x) * 0.5f;
mmc_core.cl:1242:        origin.y += (gcfg->srcparam1.y) * 0.5f;
mmc_core.cl:1243:        origin.z += (gcfg->srcparam1.z) * 0.5f;
mmc_core.cl:1253:        origin.x += GPU_PARAM(gcfg, focus) * r->vec.x;
mmc_core.cl:1254:        origin.y += GPU_PARAM(gcfg, focus) * r->vec.y;
mmc_core.cl:1255:        origin.z += GPU_PARAM(gcfg, focus) * r->vec.z;
mmc_core.cl:1258:            r->vec.x = r->p0.x - origin.x;
mmc_core.cl:1259:            r->vec.y = r->p0.y - origin.y;
mmc_core.cl:1260:            r->vec.z = r->p0.z - origin.z;
mmc_core.cl:1262:            r->vec.x = origin.x - r->p0.x;
mmc_core.cl:1263:            r->vec.y = origin.y - r->p0.y;
mmc_core.cl:1264:            r->vec.z = origin.z - r->p0.z;
mmc_core.cl:1267:        Rn2 = MCX_MATHFUN(rsqrt)(dot(r->vec, r->vec)); // normalize
mmc_core.cl:1268:        r->vec = r->vec * Rn2;
mmc_core.cl:1271:    r->p0 += r->vec * EPS;
mmc_core.cl:1278:        /*Caluclate intial element id and bary-centric coordinates for area sources - position changes everytime*/
mmc_core.cl:1285:            __global int* elems = elem + (srcelem[is] - 1) * GPU_PARAM(gcfg, elemlen);
mmc_core.cl:1288:                ea = elems[out[i][0]] - 1;
mmc_core.cl:1289:                eb = elems[out[i][1]] - 1;
mmc_core.cl:1290:                ec = elems[out[i][2]] - 1;
mmc_core.cl:1291:                vecAB = node[eb] - node[ea];
mmc_core.cl:1292:                vecAC = node[ec] - node[ea];
mmc_core.cl:1293:                vecS = r->p0 - node[ea];
mmc_core.cl:1295:                bary[facemap[i]] = -dot(vecS, vecN);
mmc_core.cl:1299:                if (bary[i] < -1e-4f) {
mmc_core.cl:1305:                r->eid = srcelem[is];
mmc_core.cl:1313:                    if ((bary[i] / s) < 1e-4f) {
mmc_core.cl:1314:                        r->faceid = ifacemap[i] + 1;
mmc_core.cl:1333: * This is the core Monte Carlo simulation function. It simulates the life-time
mmc_core.cl:1337: * \param[in] tracer: the ray-tracer aux data structure
mmc_core.cl:1350:    ray r = {gcfg->srcpos, gcfg->srcdir, {MMC_UNDEFINED, 0.f, 0.f}, GPU_PARAM(gcfg, e0), 0, 0, 1.f, 0.f, 0.f, 0.f, ID_UNDEFINED, 0.f};
mmc_core.cl:1372:        ppath[GPU_PARAM(gcfg, reclen) - 1] = r.weight; /*last record in partialpath is the initial photon weight*/
mmc_core.cl:1377:    /*http://stackoverflow.com/questions/2148149/how-to-sum-a-large-number-of-float-number*/
mmc_core.cl:1380:        r.slen = branchless_badouel_raytet(&r, gcfg, elem, weight, type[r.eid - 1], facenb, normal, gmed, replayweight, replaytime);
mmc_core.cl:1384:            if (r.faceid == -2) {
mmc_core.cl:1389:                fixphoton(&r.p0, node, (__global int*)(elem + (r.eid - 1)*GPU_PARAM(gcfg, elemlen)));
mmc_core.cl:1394:            r.faceid = -1;
mmc_core.cl:1399:        if (GPU_PARAM(gcfg, issavedet) && r.Lmove > 0.f && type[r.eid - 1] > 0) {
mmc_core.cl:1400:            ppath[GPU_PARAM(gcfg, maxmedia) + type[r.eid - 1] - 1] += r.Lmove;    /*second medianum block is the partial path*/
mmc_core.cl:1410:            r.eid = ((__global int*)(facenb + (r.eid - 1) * GPU_PARAM(gcfg, elemlen)))[r.faceid];
mmc_core.cl:1413:            if (GPU_PARAM(gcfg, isreflect) && (r.eid <= 0 || (r.eid > 0 && gmed[type[r.eid - 1]].n != gmed[type[oldeid - 1]].n ))) {
mmc_core.cl:1414:                if (! (r.eid <= 0 && ((gmed[type[oldeid - 1]].n == GPU_PARAM(gcfg, nout) && GPU_PARAM(gcfg, isreflect) != (int)bcMirror) || GPU_PARAM(gcfg, isreflect) == (int)bcAbsorbExterior) )) {
mmc_core.cl:1426:            if (type[oldeid - 1] == 0 && type[r.eid - 1]) {
mmc_core.cl:1437:            if (type[oldeid - 1] && type[r.eid - 1] == 0) {
mmc_core.cl:1448:            //          if(r.eid==0 && gmed[type[oldeid-1]].n == GPU_PARAM(gcfg,nout) ) break;
mmc_core.cl:1453:            r.slen = branchless_badouel_raytet(&r, gcfg, elem, weight, type[r.eid - 1], facenb, normal, gmed, replayweight, replaytime);
mmc_core.cl:1457:            if (GPU_PARAM(gcfg, issavedet) && r.Lmove > 0.f && type[r.eid - 1] > 0) {
mmc_core.cl:1458:                ppath[GPU_PARAM(gcfg, maxmedia) + type[r.eid - 1] - 1] += r.Lmove;
mmc_core.cl:1463:            if (r.faceid == -2) {
mmc_core.cl:1470:                fixphoton(&r.p0, node, (__global int*)(elem + (r.eid - 1)*GPU_PARAM(gcfg, elemlen)));
mmc_core.cl:1471:                r.slen = branchless_badouel_raytet(&r, gcfg, elem, weight, type[r.eid - 1], facenb, normal, gmed, replayweight, replaytime);
mmc_core.cl:1475:                if (GPU_PARAM(gcfg, issavedet) && r.Lmove > 0.f && type[r.eid - 1] > 0) {
mmc_core.cl:1476:                    ppath[GPU_PARAM(gcfg, maxmedia) + type[r.eid - 1] - 1] += r.Lmove;
mmc_core.cl:1500:                    copystate(ppath + (GPU_PARAM(gcfg, reclen) - 7), (__private float*) & (r.p0), 3); /*columns 7-5 from the right store the exit positions*/
mmc_core.cl:1501:                    copystate(ppath + (GPU_PARAM(gcfg, reclen) - 4), (__private float*) & (r.vec), 3); /*columns 4-2 from the right store the exit dirs*/
mmc_core.cl:1508:                    int tshift = MIN( ((int)((r.photontimer - gcfg->tstart) * GPU_PARAM(gcfg, Rtstep))), GPU_PARAM(gcfg, maxgate) - 1 ) * GPU_PARAM(gcfg, nf);
mmc_core.cl:1509:                    dref[((-r.eid) - 1) + tshift] += r.weight;
mmc_core.cl:1513:            } else if (r.faceid == -2 && (GPU_PARAM(gcfg, debuglevel)&dlMove)) {
mmc_core.cl:1515:            } else if (r.eid && r.faceid != -2  && GPU_PARAM(gcfg, debuglevel)&dlEdge) {
mmc_core.cl:1525:                    if (GPU_PARAM(gcfg, isextdet) && type[oldeid - 1] == GPU_PARAM(gcfg, maxmedia) + 1) {
mmc_core.cl:1528:                        savedetphoton(n_det, detectedphoton, ppath, &(r.p0), &(r.vec), gmed, -1, gcfg, photonseed, initseed);
mmc_core.cl:1533:                    if (GPU_PARAM(gcfg, isextdet) && type[oldeid - 1] == GPU_PARAM(gcfg, maxmedia) + 1) {
mmc_core.cl:1536:                        savedetphoton(n_det, detectedphoton, ppath, &(r.p0), &(r.vec), gmed, -1, gcfg, photonseed, NULL);
mmc_core.cl:1550:        if (GPU_PARAM(gcfg, minenergy) > 0.f && r.weight < GPU_PARAM(gcfg, minenergy) && (gcfg->tend - gcfg->tstart)*GPU_PARAM(gcfg, Rtstep) <= 1.f) { /*Russian Roulette*/
mmc_core.cl:1561:        r.slen0 = mc_next_scatter(gmed[type[r.eid - 1]].g, &r.vec, ran, gcfg, &mom);
mmc_core.cl:1566:            if (GPU_PARAM(gcfg, ismomentum) && type[r.eid - 1] > 0) {             /*when ismomentum is set to 1*/
mmc_core.cl:1567:                ppath[(GPU_PARAM(gcfg, maxmedia) << 1) + type[r.eid - 1] - 1] += mom;    /*the third medianum block stores the momentum transfer*/
mmc_core.cl:1571:                ppath[type[r.eid - 1] - 1] += 1.f;    /*the first medianum block stores the scattering event counts*/
mmc_core.cl:1622:    atomicadd(&(reporter->raytet), raytet);
mmc_rand_logistic.c:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_rand_logistic.c:5:**  \copyright Qianqian Fang, 2010-2021
mmc_rand_logistic.c:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_rand_logistic.c:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_rand_logistic.c:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_rand_logistic.c:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_rand_logistic.c:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_rand_logistic.c:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_rand_logistic.c:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_rand_logistic.c:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_rand_logistic.c:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_rand_logistic.c:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_rand_logistic.c:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_rand_logistic.c:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_rand_logistic.c:46:    #define FUN(x)               (4.f*(x)*(1.f-(x)))
mmc_rand_logistic.c:47:    #define NU 1e-8f
mmc_rand_logistic.c:48:    #define NU2 (1.f-2.f*NU)
mmc_rand_logistic.c:49:    #define MIN_INVERSE_LIMIT 1e-7f
mmc_rand_logistic.c:50:    #define logistic_uniform(v)  (acosf(1.f-2.f*(v))*R_PI)
mmc_rand_logistic.c:54:    #define FUN(x)               (4.0*(x)*(1.0-(x)))
mmc_rand_logistic.c:55:    #define NU 1e-14
mmc_rand_logistic.c:56:    #define NU2 (1.0-2.0*NU)
mmc_rand_logistic.c:57:    #define MIN_INVERSE_LIMIT 1e-12
mmc_rand_logistic.c:58:    #define logistic_uniform(v)  (acos(1.0-2.0*(v))*R_PI)
mmc_rand_logistic.c:73:           tnew[i]=RING_FUN(t[i],t[i-1],t[i+1]);
mmc_rand_logistic.c:74:        tnew[len_1]=RING_FUN(t[len_1],t[0],t[len_1-1]);
mmc_rand_logistic.c:96:    logistic_step(t, tbuf, RAND_BUF_LEN - 1);
mmc_rand_logistic.c:97:    logistic_step(tbuf, t, RAND_BUF_LEN - 1);
mmc_rand_logistic.c:126:    return ((ran == 0.f) ? LOG_MT_MAX : (-logf(ran)));
mmc_cuda_query_gpu.cu:37:        mcx_error(-(int)cuerr, (char*)cudaGetErrorString(cuerr), file, linenum);
mmc_cuda_query_gpu.cu:55:                    S_RED "ERROR: No CUDA-capable GPU device found\n" S_RESET);
mmc_cuda_query_gpu.cu:61:    if (cfg->gpuid && cfg->gpuid > (uint)deviceCount) {
mmc_cuda_query_gpu.cu:72:        if (cfg->isgpuinfo == 3) {
mmc_cuda_query_gpu.cu:74:        } else if (cfg->deviceid[dev] == '1') {
mmc_cuda_query_gpu.cu:75:            cfg->deviceid[dev] = '\0';
mmc_cuda_query_gpu.cu:76:            cfg->deviceid[activedev] = dev + 1;
mmc_cuda_query_gpu.cu:94:        (*info)[dev].maxgate = cfg->maxgate;
mmc_cuda_query_gpu.cu:102:            if (cfg->isgpuinfo) {
mmc_cuda_query_gpu.cu:117:                            (*info)[dev].clock * 1e-6f);
mmc_cuda_query_gpu.cu:127:    if (cfg->isgpuinfo == 2 &&
mmc_cuda_query_gpu.cu:128:            cfg->parentid == mpStandalone) { // list GPU info only
mmc_cuda_query_gpu.cu:133:        cfg->deviceid[activedev] = '\0';
nifti1.h:7:           - added DT_RGBA32 and NIFTI_TYPE_RGBA32
nifti1.h:8:           - added NIFTI_INTENT codes:
nifti1.h:16:      ** This file defines the "NIFTI-1" header format.               **
nifti1.h:21:      **--------------------------------------------------------------**
nifti1.h:28:      **--------------------------------------------------------------**
nifti1.h:35:/*---------------------------------------------------------------------------*/
nifti1.h:37:         (c) Copyright 1986-1995
nifti1.h:45:-----------------------------------------------------------------------------*/
nifti1.h:47:/*---------------------------------------------------------------------------*/
nifti1.h:48:/*! INTRODUCTION TO NIFTI-1:
nifti1.h:49:   ------------------------
nifti1.h:54:        - More basic data types.
nifti1.h:55:        - Two affine transformations to specify voxel coordinates.
nifti1.h:56:        - "Intent" codes and parameters to describe the meaning of the data.
nifti1.h:57:        - Affine scaling of the stored data values to their "true" values.
nifti1.h:58:        - Optional storage of the header and image data in one file (.nii).
nifti1.h:59:    (b) To maintain compatibility with non-NIFTI-aware ANALYZE 7.5 compatible
nifti1.h:61:        with a NIFTI-1 dataset -- at least, with one stored in a traditional
nifti1.h:65:   and some of the lesser-used fields have been co-opted for other purposes.
nifti1.h:66:   Notably, most of the data_history substructure has been co-opted for
nifti1.h:70:   NIFTI-1 FLAG (MAGIC STRINGS):
nifti1.h:71:   ----------------------------
nifti1.h:72:   To flag such a struct as being conformant to the NIFTI-1 spec, the last 4
nifti1.h:78:   file, but trying to avoid clobbering widely-used ANALYZE 7.5 fields led to
nifti1.h:82:   If a NIFTI-aware program reads a header file that is NOT marked with a
nifti1.h:86:   NIFTI-1 FILE STORAGE:
nifti1.h:87:   --------------------
nifti1.h:99:   ----------------
nifti1.h:100:   Most NIFTI-aware programs will only be able to handle a subset of the full
nifti1.h:101:   range of datasets possible with this format.  All NIFTI-aware programs
nifti1.h:108:   ------------
nifti1.h:111:   NIFTI-1 files.  The file nifti1_test.c is a sample program that uses
nifti1.h:113:-----------------------------------------------------------------------------*/
nifti1.h:115:/*---------------------------------------------------------------------------*/
nifti1.h:117:   -------------------------
nifti1.h:118:   In the comments below for each field, only NIFTI-1 specific requirements
nifti1.h:130:-----------------------------------------------------------------------------*/
nifti1.h:141:           NIFTI-1 header file.
nifti1.h:145:    /* NIFTI-1 usage         */  /* ANALYZE 7.5 field(s) */
nifti1.h:148:    /*--- was header_key substruct ---*/
nifti1.h:157:    /*--- was image_dimension substruct ---*/
nifti1.h:183:    /*--- was data_history substruct ---*/
nifti1.h:187:    short qform_code ;   /*!< NIFTI_XFORM_* code.   */  /*-- all ANALYZE 7.5 ---*/
nifti1.h:209:/*---------------------------------------------------------------------------*/
nifti1.h:211:   -----------------
nifti1.h:218:   file is 348 bytes), then a NIfTI-1 compliant program should use the
nifti1.h:233:   These values may need to be byte-swapped, as indicated by dim[0] for
nifti1.h:238:     * ecode is a non-negative integer that indicates the format of the
nifti1.h:244:         = 4 = AFNI group (i.e., ASCII XML-ish elements)
nifti1.h:256:   totally unspecified by the NIfTI-1 standard. In particular, if binary
nifti1.h:264:   is at bytes #352-355 in the .hdr or .nii file (files start at byte #0).
nifti1.h:271:   if an extended header data section would run past the end-of-file,
nifti1.h:279:-----------------------------------------------------------------------------*/
nifti1.h:282:    @brief This structure represents a 4-byte string that should follow the
nifti1.h:283:           binary nifti_1_header data in a NIFTI-1 header file.  If the char
nifti1.h:299:    char* edata ;  /*!< raw data, with no byte swapping (length is esize-8)  */
nifti1.h:303:/*---------------------------------------------------------------------------*/
nifti1.h:305:   ---------------------------------------
nifti1.h:307:              - if dim[0] is outside range 1..7, then the header information
nifti1.h:309:              - ANALYZE supports dim[0] up to 7, but NIFTI-1 reserves
nifti1.h:314:              - also see the discussion of intent_code, far below
nifti1.h:317:                 - cf. ORIENTATION section below for use of pixdim[0]
nifti1.h:318:                 - the units of pixdim can be specified with the xyzt_units
nifti1.h:325:   In NIFTI-1 files, dimensions 1,2,3 are for space, dimension 4 is for time,
nifti1.h:328:     - A typical whole-brain FMRI experiment's time series:
nifti1.h:329:        - dim[0] = 4
nifti1.h:330:        - dim[1] = 64   pixdim[1] = 3.75 xyzt_units =  NIFTI_UNITS_MM
nifti1.h:331:        - dim[2] = 64   pixdim[2] = 3.75             | NIFTI_UNITS_SEC
nifti1.h:332:        - dim[3] = 20   pixdim[3] = 5.0
nifti1.h:333:        - dim[4] = 120  pixdim[4] = 2.0
nifti1.h:334:     - A typical T1-weighted anatomical volume:
nifti1.h:335:        - dim[0] = 3
nifti1.h:336:        - dim[1] = 256  pixdim[1] = 1.0  xyzt_units = NIFTI_UNITS_MM
nifti1.h:337:        - dim[2] = 256  pixdim[2] = 1.0
nifti1.h:338:        - dim[3] = 128  pixdim[3] = 1.1
nifti1.h:339:     - A single slice EPI time series:
nifti1.h:340:        - dim[0] = 4
nifti1.h:341:        - dim[1] = 64   pixdim[1] = 3.75 xyzt_units =  NIFTI_UNITS_MM
nifti1.h:342:        - dim[2] = 64   pixdim[2] = 3.75             | NIFTI_UNITS_SEC
nifti1.h:343:        - dim[3] = 1    pixdim[3] = 5.0
nifti1.h:344:        - dim[4] = 1200 pixdim[4] = 0.2
nifti1.h:345:     - A 3-vector stored at each point in a 3D volume:
nifti1.h:346:        - dim[0] = 5
nifti1.h:347:        - dim[1] = 256  pixdim[1] = 1.0  xyzt_units = NIFTI_UNITS_MM
nifti1.h:348:        - dim[2] = 256  pixdim[2] = 1.0
nifti1.h:349:        - dim[3] = 128  pixdim[3] = 1.1
nifti1.h:350:        - dim[4] = 1    pixdim[4] = 0.0
nifti1.h:351:        - dim[5] = 3                     intent_code = NIFTI_INTENT_VECTOR
nifti1.h:352:     - A single time series with a 3x3 matrix at each point:
nifti1.h:353:        - dim[0] = 5
nifti1.h:354:        - dim[1] = 1                     xyzt_units = NIFTI_UNITS_SEC
nifti1.h:355:        - dim[2] = 1
nifti1.h:356:        - dim[3] = 1
nifti1.h:357:        - dim[4] = 1200 pixdim[4] = 0.2
nifti1.h:358:        - dim[5] = 9                     intent_code = NIFTI_INTENT_GENMATRIX
nifti1.h:359:        - intent_p1 = intent_p2 = 3.0    (indicates matrix dimensions)
nifti1.h:360:-----------------------------------------------------------------------------*/
nifti1.h:362:/*---------------------------------------------------------------------------*/
nifti1.h:364:   ------------
nifti1.h:368:   the data starts immediately after the NIFTI-1 header.  If vox_offset is
nifti1.h:369:   greater than 352, the NIFTI-1 format does not say much about the
nifti1.h:374:   -----
nifti1.h:379:   When storing NIFTI-1 datasets in pairs of files, it is customary to name
nifti1.h:386:   -------------
nifti1.h:390:   Floating point types are presumed to be stored in IEEE-754 format.
nifti1.h:391:-----------------------------------------------------------------------------*/
nifti1.h:393:/*---------------------------------------------------------------------------*/
nifti1.h:395:   ------------------------
nifti1.h:406:      memory-mapped input to be properly byte-aligned.
nifti1.h:407:   Note that since vox_offset is an IEEE-754 32 bit float (for compatibility
nifti1.h:408:   with the ANALYZE-7.5 format), it effectively has a 24 bit mantissa. All
nifti1.h:410:   all larger integers are exactly storable as IEEE-754 32 bit floats. However,
nifti1.h:417:   In a .img file (i.e., image data stored separately from the NIfTI-1
nifti1.h:418:   header), data bytes between #0 and #vox_offset-1 (inclusive) are completely
nifti1.h:419:   undefined and unregulated by the NIfTI-1 standard. One potential use of
nifti1.h:421:   the .img file be a copy of (or link to) a pre-existing image file in some
nifti1.h:424:   "multiple-of-16 rule" with an arbitrary external file; using the NIfTI-1
nifti1.h:428:   In a .nii file, data bytes between #348 and #vox_offset-1 (inclusive) may
nifti1.h:429:   be used to store user-defined extra information; similarly, in a .hdr file,
nifti1.h:430:   any data bytes after byte #347 are available for user-defined extra
nifti1.h:433:-----------------------------------------------------------------------------*/
nifti1.h:435:/*---------------------------------------------------------------------------*/
nifti1.h:437:   ------------
nifti1.h:447:    - However, the scaling is to be ignored if datatype is DT_RGB24.
nifti1.h:448:    - If datatype is a complex type, then the scaling is to be
nifti1.h:453:    - Minimum display intensity (black) corresponds to dataset value cal_min.
nifti1.h:454:    - Maximum display intensity (white) corresponds to dataset value cal_max.
nifti1.h:455:    - Dataset values below cal_min should display as black also, and values
nifti1.h:457:    - Colors "black" and "white", of course, may refer to any scalar display
nifti1.h:459:    - cal_min and cal_max only make sense when applied to scalar-valued
nifti1.h:461:-----------------------------------------------------------------------------*/
nifti1.h:463:/*---------------------------------------------------------------------------*/
nifti1.h:465:   ---------------------------------------------------
nifti1.h:467:   Larger values are NIFTI-1 additions.  These are all multiples of 256, so
nifti1.h:469:   to use only powers-of-2, as the original ANALYZE 7.5 datatype codes do.
nifti1.h:476:   A NIFTI-1 program should fail gracefully (e.g., print a warning message)
nifti1.h:478:-----------------------------------------------------------------------------*/
nifti1.h:486:/*--- the original ANALYZE 7.5 type codes ---*/
nifti1.h:499:/*----- another set of names for the same ---*/
nifti1.h:508:/*------------------- new codes for NIFTI ---*/
nifti1.h:521:/*------- aliases for all the above codes ---*/
nifti1.h:561:/*-------- sample typedefs for complicated types ---*/
nifti1.h:577:/*---------------------------------------------------------------------------*/
nifti1.h:579:   ----------------------------
nifti1.h:585:   VECTOR-VALUED DATASETS:
nifti1.h:586:   ----------------------
nifti1.h:590:    - dim[0] = 5
nifti1.h:591:    - dim[1] = 64
nifti1.h:592:    - dim[2] = 64
nifti1.h:593:    - dim[3] = 20
nifti1.h:594:    - dim[4] = 1     (indicates no time axis)
nifti1.h:595:    - dim[5] = 3
nifti1.h:596:    - datatype = DT_FLOAT
nifti1.h:597:    - intent_code = NIFTI_INTENT_VECTOR
nifti1.h:599:   with a 3-vector of floats defined at each point in the 3D grid.
nifti1.h:604:   NIFTI-1 file specification!  Uses of dimensions 6 and 7 are also not
nifti1.h:608:   --------------------------------------------
nifti1.h:620:    - dim[0] = 5
nifti1.h:621:    - dim[1] = 128
nifti1.h:622:    - dim[2] = 128
nifti1.h:623:    - dim[3] = 1      (indicates a single slice)
nifti1.h:624:    - dim[4] = 1      (indicates no time axis)
nifti1.h:625:    - dim[5] = 2
nifti1.h:626:    - datatype = DT_FLOAT
nifti1.h:627:    - intent_code = NIFTI_INTENT_TTEST
nifti1.h:628:   mean that this is a 2D dataset (128x128) of t-statistics, with the
nifti1.h:629:   t-statistic being in the first "plane" of data and the degrees-of-freedom
nifti1.h:632:   If the dataset 5th dimension is used to store the voxel-wise statistical
nifti1.h:641:   ----------------
nifti1.h:643:   stored in the dataset.  Some non-statistical values for intent_code
nifti1.h:648:    - intent_code = NIFTI_INTENT_ESTIMATE; intent_name = "T1";
nifti1.h:651:    - intent_code = NIFTI_INTENT_TTEST; intent_name = "House";
nifti1.h:652:       could be used to signify that the voxel values are t-statistics
nifti1.h:654:    - intent_code = NIFTI_INTENT_DISPVECT; intent_name = "ToMNI152";
nifti1.h:658:    - intent_code = NIFTI_INTENT_SYMMATRIX; intent_name = "DTI";
nifti1.h:663:-----------------------------------------------------------------------------*/
nifti1.h:669:/*-------- These codes are for probability distributions ---------------*/
nifti1.h:672:    - intent_p1, intent_p2, intent_p3 if dataset doesn't have 5th dimension
nifti1.h:673:    - image data array                if dataset does have 5th dimension
nifti1.h:689:/*----------------------------------------------------------------------*/
nifti1.h:693:     R/sqrt(1-R*R) is t-distributed with p1 DOF. */
nifti1.h:714:/*! [C1, chap 18] Chi-squared (1 param): p1 = DOF.
nifti1.h:715:    Density(x) proportional to exp(-x/2) * x^(p1/2-1). */
nifti1.h:720:    Density(x) proportional to x^(a-1) * (1-x)^(b-1). */
nifti1.h:726:    Prob(x) = (p1 choose x) * p2^x * (1-p2)^(p1-x), for x=0,1,...,p1. */
nifti1.h:732:    Density(x) proportional to x^(p1-1) * exp(-p2*x). */
nifti1.h:737:    Prob(x) = exp(-p1) * p1^x / x! , for x=0,1,2,.... */
nifti1.h:752:/*! [C2, chap 29] Noncentral chi-squared statistic (2 params):
nifti1.h:759:    Density(x) proportional to sech^2((x-p1)/(2*p2)). */
nifti1.h:765:    Density(x) proportional to exp(-abs(x-p1)/p2). */
nifti1.h:781:     ((x-p1)/p2)^(p3-1) * exp(-((x-p1)/p2)^p3) for x > p1. */
nifti1.h:786:    Density(x) proportional to x^(p1-1) * exp(-x^2/2) for x > 0.
nifti1.h:789:     p1 = 3 = Maxwell-Boltzmann distribution.                  */
nifti1.h:796:     exp(-p2*(x-p1)^2/(2*p1^2*x)) / x^3  for x > 0. */
nifti1.h:802:    cdf(x) = exp(-exp(-(x-p1)/p2)). */
nifti1.h:806:/*! Data is a 'p-value' (no params). */
nifti1.h:810:/*! Data is ln(p-value) (no params).
nifti1.h:811:    To be safe, a program should compute p = exp(-abs(this_value)).
nifti1.h:813:    as positive, so that this_value = -log(p). */
nifti1.h:818:/*! Data is log10(p-value) (no params).
nifti1.h:819:    To be safe, a program should compute p = pow(10.,-abs(this_value)).
nifti1.h:821:    as positive, so that this_value = -log10(p). */
nifti1.h:833:/*---------- these values for intent_code aren't for statistics ----------*/
nifti1.h:853:      - dataset must have a 5th dimension (dim[0]=5 and dim[5]>1)
nifti1.h:854:      - intent_code must be NIFTI_INTENT_GENMATRIX
nifti1.h:855:      - dim[5] must be M*N
nifti1.h:856:      - intent_p1 must be M (in float format)
nifti1.h:857:      - intent_p2 must be N (ditto)
nifti1.h:858:      - the matrix values A[i][[j] are stored in row-order:
nifti1.h:859:        - A[0][0] A[0][1] ... A[0][N-1]
nifti1.h:860:        - A[1][0] A[1][1] ... A[1][N-1]
nifti1.h:861:        - etc., until
nifti1.h:862:        - A[M-1][0] A[M-1][1] ... A[M-1][N-1]        */
nifti1.h:867:      - dataset must have a 5th dimension
nifti1.h:868:      - intent_code must be NIFTI_INTENT_SYMMATRIX
nifti1.h:869:      - dim[5] must be N*(N+1)/2
nifti1.h:870:      - intent_p1 must be N (in float format)
nifti1.h:871:      - the matrix values A[i][[j] are stored in row-order:
nifti1.h:872:        - A[0][0]
nifti1.h:873:        - A[1][0] A[1][1]
nifti1.h:874:        - A[2][0] A[2][1] A[2][2]
nifti1.h:875:        - etc.: row-by-row                           */
nifti1.h:881:      - dataset must have a 5th dimension
nifti1.h:882:      - intent_code must be NIFTI_INTENT_DISPVECT
nifti1.h:883:      - dim[5] must be the dimensionality of the displacment
nifti1.h:884:        vector (e.g., 3 for spatial displacement, 2 for in-plane) */
nifti1.h:891:      - dataset must have a 5th dimension
nifti1.h:892:      - intent_code must be NIFTI_INTENT_POINTSET
nifti1.h:893:      - dim[0] = 5
nifti1.h:894:      - dim[1] = number of points
nifti1.h:895:      - dim[2] = dim[3] = dim[4] = 1
nifti1.h:896:      - dim[5] must be the dimensionality of space (e.g., 3 => 3D space).
nifti1.h:897:      - intent_name may describe the object these points come from
nifti1.h:904:      - dataset must have a 5th dimension
nifti1.h:905:      - intent_code must be NIFTI_INTENT_TRIANGLE
nifti1.h:906:      - dim[0] = 5
nifti1.h:907:      - dim[1] = number of triangles
nifti1.h:908:      - dim[2] = dim[3] = dim[4] = 1
nifti1.h:909:      - dim[5] = 3
nifti1.h:910:      - datatype should be an integer type (preferably DT_INT32)
nifti1.h:911:      - the data values are indexes (0,1,...) into a pointset dataset. */
nifti1.h:916:      - dataset must have a 5th dimension
nifti1.h:917:      - intent_code must be NIFTI_INTENT_QUATERNION
nifti1.h:918:      - dim[0] = 5
nifti1.h:919:      - dim[5] = 4
nifti1.h:920:      - datatype should be a floating point type     */
nifti1.h:924:/*! Dimensionless value - no params - although, as in _ESTIMATE
nifti1.h:929:/*---------- these values apply to GIFTI datasets ----------*/
nifti1.h:942:      - dataset must have a 5th dimension
nifti1.h:943:      - dim[0] = 5
nifti1.h:944:      - dim[1] = number of nodes
nifti1.h:945:      - dim[2] = dim[3] = dim[4] = 1
nifti1.h:946:      - dim[5] = 3
nifti1.h:953:      - dataset must have a 5th dimension
nifti1.h:954:      - dim[0] = 5
nifti1.h:955:      - dim[1] = number of nodes
nifti1.h:956:      - dim[2] = dim[3] = dim[4] = 1
nifti1.h:957:      - dim[5] = 4
nifti1.h:969:/*---------------------------------------------------------------------------*/
nifti1.h:971:   ---------------------------------------------------
nifti1.h:977:     i = 0 .. dim[1]-1
nifti1.h:978:     j = 0 .. dim[2]-1  (if dim[0] >= 2)
nifti1.h:979:     k = 0 .. dim[3]-1  (if dim[0] >= 3)
nifti1.h:981:   2 and 3, the (x,y,z) axes refer to a subject-based coordinate system,
nifti1.h:984:   This is a right-handed coordinate system.  However, the exact direction
nifti1.h:995:    which is a left-handed coordinate system.  This backwardness is
nifti1.h:996:    too difficult to tolerate, so this NIFTI-1 standard specifies the
nifti1.h:1006:   N.B.: Method 2 uses a factor 'qfac' which is either -1 or 1; qfac is
nifti1.h:1009:    when reading a NIFTI-1 header, not when reading an ANALYZE 7.5 header.
nifti1.h:1014:   -------------------------------------------------------
nifti1.h:1023:   coordinates.  (NIFTI-1 does not have the ANALYZE 7.5 orient field,
nifti1.h:1029:   ---------------------------------------------------------------------
nifti1.h:1032:   "scanner-anatomical" coordinates, which are often embedded in the
nifti1.h:1036:   coordinates, which would typically result from some post-acquisition
nifti1.h:1046:   The qoffset_* shifts are in the NIFTI-1 header.  Note that the center
nifti1.h:1053:   The scaling factor qfac is either 1 or -1.  The rotation matrix R
nifti1.h:1057:     i increases from Left-to-Right
nifti1.h:1058:     j increases from Anterior-to-Posterior
nifti1.h:1059:     k increases from Inferior-to-Superior
nifti1.h:1060:   Then (i,j,k) is a left-handed triple.  In this example, if qfac=1,
nifti1.h:1064:     [  0  -1   0 ]  which is "improper" (determinant = -1).
nifti1.h:1067:   If we set qfac=-1, then the R matrix would be
nifti1.h:1070:     [  0  -1   0 ]  which is proper.
nifti1.h:1071:     [  0   0  -1 ]
nifti1.h:1074:   (which encodes a 180 degree rotation about the x-axis).
nifti1.h:1077:   -----------------------------------
nifti1.h:1089:   --------------
nifti1.h:1114:   -------------------------------------------------------
nifti1.h:1118:   we require that a = sqrt(1.0-(b*b+c*c+d*d)) be nonnegative.  The (b,c,d)
nifti1.h:1125:         [ a*a+b*b-c*c-d*d   2*b*c-2*a*d       2*b*d+2*a*c     ]
nifti1.h:1126:     R = [ 2*b*c+2*a*d       a*a+c*c-b*b-d*d   2*c*d-2*a*b     ]
nifti1.h:1127:         [ 2*b*d-2*a*c       2*c*d+2*a*b       a*a+d*d-c*c-b*b ]
nifti1.h:1133:   If (p,q,r) is a unit 3-vector, then rotation of angle h about that
nifti1.h:1138:   Requiring a >= 0 is equivalent to requiring -Pi <= h <= Pi.  (Note that
nifti1.h:1139:   [-a,-b,-c,-d] represents the same rotation as [a,b,c,d]; there are 2
nifti1.h:1141:   To rotate a 3-vector (x,y,z) using quaternions, we compute the
nifti1.h:1144:     [0,x',y',z'] = [a,b,c,d] * [0,x,y,z] * [a,-b,-c,-d]
nifti1.h:1146:   which is equivalent to the matrix-vector multiply
nifti1.h:1156:       I*I = J*J = K*K = -1 (I,J,K are square roots of -1)
nifti1.h:1158:       J*I = -K    K*J = -I    I*K = -J  (not commutative!)
nifti1.h:1160:       [a,b,0,0] * [0,0,0,1] = [0,0,-b,a]
nifti1.h:1162:       (a+b*I)*(K) = (a*K+b*I*K) = (a*K-b*J).
nifti1.h:1166:   we can compute the fields for the NIFTI-1 header by
nifti1.h:1169:     b = 0.25 * (R32-R23) / a       => quatern_b
nifti1.h:1170:     c = 0.25 * (R13-R31) / a       => quatern_c
nifti1.h:1171:     d = 0.25 * (R21-R12) / a       => quatern_d
nifti1.h:1177:   Note that R-transpose (= R-inverse) would lead to the quaternion
nifti1.h:1178:   [a,-b,-c,-d].
nifti1.h:1184:   Here, (Xd,Yd,Zd) refer to DICOM coordinates, and Xd=-x, Yd=-y, Zd=z,
nifti1.h:1189:     qoffset_x = -px   qoffset_y = -py   qoffset_z = pz
nifti1.h:1192:   That is, DICOM's coordinate system is 180 degrees rotated about the z-axis
nifti1.h:1194:   and NIFTI, you just have to negate the x- and y-coordinates.
nifti1.h:1197:   orientation of the x- and y-axes of the image data in terms of 2 3-vectors.
nifti1.h:1198:   The first vector is a unit vector along the x-axis, and the second is
nifti1.h:1199:   along the y-axis.  If the (0020,0037) attribute is extracted into the
nifti1.h:1202:              [ -xa  -ya ]
nifti1.h:1203:              [ -xb  -yb ]
nifti1.h:1205:   The negations are because DICOM's x- and y-axes are reversed relative
nifti1.h:1207:   displacement (relative to the subject) along the slice-wise direction.
nifti1.h:1210:   either the cross-product of the first 2 columns or its negative.  It is
nifti1.h:1215:-----------------------------------------------------------------------------*/
nifti1.h:1218:/*-----------------------*/      /*---------------------------------------*/
nifti1.h:1228:/*! Scanner-based anatomical coordinates */
nifti1.h:1237:/*! Coordinates aligned to Talairach-
nifti1.h:1247:/*---------------------------------------------------------------------------*/
nifti1.h:1249:   ----------------------------------------
nifti1.h:1253:    - If dim[4]=1 or dim[0] < 4, there is no time axis.
nifti1.h:1254:    - A single time series (no space) would be specified with
nifti1.h:1255:      - dim[0] = 4 (for scalar data) or dim[0] = 5 (for vector data)
nifti1.h:1256:      - dim[1] = dim[2] = dim[3] = 1
nifti1.h:1257:      - dim[4] = number of time points
nifti1.h:1258:      - pixdim[4] = time step
nifti1.h:1259:      - xyzt_units indicates units of pixdim[4]
nifti1.h:1260:      - dim[5] = number of values stored at each time point
nifti1.h:1276:   actually frequency in Hertz (_HZ), in part-per-million (_PPM)
nifti1.h:1277:   or in radians-per-second (_RADS).
nifti1.h:1281:   for m=0..dim[4]-1.
nifti1.h:1282:-----------------------------------------------------------------------------*/
nifti1.h:1326:/*---------------------------------------------------------------------------*/
nifti1.h:1327:/* MRI-SPECIFIC SPATIAL AND TEMPORAL INFORMATION:
nifti1.h:1328:   ---------------------------------------------
nifti1.h:1339:      Rectangular scan multi-slice EPI:
nifti1.h:1341:      Spiral scan multi-slice EPI:
nifti1.h:1343:        since the concepts of frequency- and phase-encoding directions
nifti1.h:1367:                    slice_end=dim[slice_dim]-1 are the correct values.
nifti1.h:1369:                    be non-negative and slice_end must be greater than
nifti1.h:1396:  slice_start+1 for INC2 and at slice_end-1 for DEC2).  This latter
nifti1.h:1410:-----------------------------------------------------------------------------*/
nifti1.h:1439:/*---------------------------------------------------------------------------*/
nifti1.h:1441:   -------------
nifti1.h:1444:   of interoperability of ANALYZE 7.5 files is a murky one -- not all
nifti1.h:1446:   murkiness is a principal motivation behind NIFTI-1.)
nifti1.h:1448:   Some of the fields that may need to be set for other (non-NIFTI aware)
nifti1.h:1456:   It is best to initialize ALL fields in the NIFTI-1 header to 0
nifti1.h:1458:-----------------------------------------------------------------------------*/
nifti1.h:1460:/*---------------------------------------------------------------------------*/
nifti1.h:1462:-----------------------------------------------------------------------------*/
nifti1.h:1472:      ? (h).magic[2]-'0' : 0 )
mmc_fastmath.h:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_fastmath.h:5:**  \copyright Qianqian Fang, 2010-2021
mmc_fastmath.h:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_fastmath.h:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_fastmath.h:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_fastmath.h:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_fastmath.h:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_fastmath.h:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_fastmath.h:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_fastmath.h:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_fastmath.h:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_fastmath.h:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_fastmath.h:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_fastmath.h:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_fastmath.h:42: * @brief An approximated floating-point exponential function using 9th order Taylor's expansion
mmc_fastmath.h:51:    return (362880.f + x * (362880.f + x * (181440.f + x * (60480.f + x * (15120.f + x * (3024.f + x * (504.f + x * (72.f + x * (9.f + x))))))))) * 2.75573192e-6f;
mmc_fastmath.h:57:        return (((i&0x7f800000)>>23)-0x7f)+(i&0x007fffff)/(float)0x800000;
mmc_optix_core.cu:21:constexpr float R_C0 = 3.335640951981520e-12f; // 1/C0 in s/mm
mmc_optix_core.cu:71:    if (vec.z > -1.0f + std::numeric_limits<float>::epsilon() &&
mmc_optix_core.cu:72:            vec.z < 1.0f - std::numeric_limits<float>::epsilon()) {
mmc_optix_core.cu:73:        float tmp0 = 1.0f - vec.z * vec.z;
mmc_optix_core.cu:75:        return tmp1 * (azi.y * make_float3(vec.x, vec.y, -tmp0) *
mmc_optix_core.cu:76:                       make_float3(vec.z, vec.z, 1.f) + azi.x * make_float3(-vec.y, vec.x, 0.0f))
mmc_optix_core.cu:79:        return make_float3(zen.x * azi.y, zen.x * azi.x, (vec.z > 0.0f) ? zen.y : -zen.y);
mmc_optix_core.cu:84: * @brief Returns the sine and cosine from the Henyey-Greenstein distribution
mmc_optix_core.cu:90:        ctheta = (1.0f - g * g) / (1.0f - g + 2.0f * g * rand.uniform(0.0f, 1.0f));
mmc_optix_core.cu:92:        ctheta = (1.0f + g * g - ctheta) / (2.0f * g);
mmc_optix_core.cu:93:        ctheta = fmax(-1.0f, fmin(1.0f, ctheta));
mmc_optix_core.cu:95:        ctheta = 2.0f * rand.uniform(0.0f, 1.0f) - 1.0f;
mmc_optix_core.cu:134:    return min(((int)((tof - gcfg.tstart) * gcfg.Rtstep)),
mmc_optix_core.cu:135:               gcfg.maxgate - 1) * gcfg.crop0.z;
mmc_optix_core.cu:154:// geometric solution taken from: scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-trac    er-rendering-simple-shapes/ray-sphere-intersection.html
mmc_optix_core.cu:158:    float3 L = center - ray_origin;
mmc_optix_core.cu:161:    float d2 = dot(L, L) - tca * tca;
mmc_optix_core.cu:165:        float2 hitTs = make_float2(-1, -1);
mmc_optix_core.cu:170:    float thc = sqrt(width * width - d2);
mmc_optix_core.cu:172:    hitTs.x = tca - thc;
mmc_optix_core.cu:178:// from davidjcobb.github.io/articles/ray-cylinder-intersection
mmc_optix_core.cu:181:    float3 R1 = ray_origin - vertex2;
mmc_optix_core.cu:182:    float3 Cs = vertex1 - vertex2;
mmc_optix_core.cu:190:    float a = 1 - (Ca_dot_Rd * Ca_dot_Rd);
mmc_optix_core.cu:191:    float b = 2 * (dot(ray_dir, R1) - Ca_dot_Rd * Ca_dot_R1);
mmc_optix_core.cu:192:    float c = R1_dot_R1 - Ca_dot_R1 * Ca_dot_R1 - (width * width);
mmc_optix_core.cu:195:    float discriminant = b * b - 4.0f * a * c;
mmc_optix_core.cu:198:        cyl_hits.x = -1;
mmc_optix_core.cu:199:        cyl_hits.y = -1;
mmc_optix_core.cu:203:    cyl_hits.x = (-b - sqrt(discriminant)) / (2 * a);
mmc_optix_core.cu:204:    cyl_hits.y = (-b + sqrt(discriminant)) / (2 * a);
mmc_optix_core.cu:217:        if (atomicAdd(&((float*)gcfg.outputbuffer)[eid], -accum) < 0.0f) {
mmc_optix_core.cu:233:    float segdecay = expf(-prop.mua * seglen);
mmc_optix_core.cu:234:    float segloss = (gcfg.outputtype == otEnergy) ? r.weight * (1.0f - segdecay) :
mmc_optix_core.cu:235:                    (prop.mua ? r.weight * (1.0f - segdecay) / prop.mua : 0.0f);
mmc_optix_core.cu:239:    float3 segmid = r.p0 - gcfg.nmin + 0.5f * step; // segment midpoint
mmc_optix_core.cu:279:    tmp2 = 1.f - tmp0 / tmp1 * (1.f - Icos * Icos);
mmc_optix_core.cu:286:        Rtotal = (Re - Im) / (Re + Im); /*Rp*/
mmc_optix_core.cu:288:        Rtotal = (Rtotal + (Re - Im) / (Re + Im)) * 0.5f; /*(Rp+Rs)/2*/
mmc_optix_core.cu:292:            r.p0 -= r.dir * DOUBLE_SAFETY_DISTANCE;
mmc_optix_core.cu:293:            r.dir += -2.0f * Icos * norm;
mmc_optix_core.cu:296:            r.dir += -Icos * norm;
mmc_optix_core.cu:302:        r.p0 -= r.dir * DOUBLE_SAFETY_DISTANCE;
mmc_optix_core.cu:303:        r.dir += -2.0f * Icos * norm;
mmc_optix_core.cu:362:    r.weight *= expf(-currprop.mua * lmove);
mmc_optix_core.cu:368:    r.slen -= lmove * currprop.mus;
mmc_optix_core.cu:451:    r.weight *= expf(-currprop.mua * lmove);
mmc_optix_core.cu:478:        capsuleIdx = primIdx - gcfg.num_inside_prims;
mmc_optix_core.cu:487:    float3 lineseg_AB = capsule.vertex1 - capsule.vertex2;
mmc_optix_core.cu:505:    if (dot(sphere_one_hit_one - capsule.vertex1, lineseg_AB) < 0) {
mmc_optix_core.cu:506:        sphere_one_hits.x = -1;
mmc_optix_core.cu:509:    if (dot(sphere_one_hit_two - capsule.vertex1, lineseg_AB) < 0) {
mmc_optix_core.cu:510:        sphere_one_hits.y = -1;
mmc_optix_core.cu:524:    if (dot(capsule.vertex2 - sphere_two_hit_one, lineseg_AB) < 0) {
mmc_optix_core.cu:525:        sphere_two_hits.x = -1;
mmc_optix_core.cu:528:    if (dot(capsule.vertex2 - sphere_two_hit_two, lineseg_AB) < 0) {
mmc_optix_core.cu:529:        sphere_two_hits.y = -1;
mmc_optix_core.cu:543:    if (dot(cyl_hit_one - capsule.vertex1, lineseg_AB) > 0 ||
mmc_optix_core.cu:544:            dot(cyl_hit_one - capsule.vertex2, lineseg_AB) < 0) {
mmc_optix_core.cu:545:        cyl_hits.x = -1;
mmc_optix_core.cu:548:    if (dot(cyl_hit_two - capsule.vertex1, lineseg_AB) > 0 ||
mmc_optix_core.cu:549:            dot(cyl_hit_two - capsule.vertex2, lineseg_AB) < 0) {
mmc_optix_core.cu:550:        cyl_hits.y = -1;
mmc_rand_drand48.c:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_rand_drand48.c:5:**  \copyright Qianqian Fang, 2010-2021
mmc_rand_drand48.c:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_rand_drand48.c:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_rand_drand48.c:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_rand_drand48.c:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_rand_drand48.c:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_rand_drand48.c:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_rand_drand48.c:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_rand_drand48.c:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_rand_drand48.c:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_rand_drand48.c:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_rand_drand48.c:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_rand_drand48.c:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_rand_drand48.c:50:   02111-1307 USA.
mmc_rand_drand48.c:56:\brief   POSIX 48bit multi-threaded RNG for win32 port via LibGW32C
mmc_rand_drand48.c:70:    // if (__builtin_expect (!buffer->__init, 0))
mmc_rand_drand48.c:71:    if (buffer->__init == 0) {
mmc_rand_drand48.c:72:        buffer->__a = 0x5deece66dull;
mmc_rand_drand48.c:73:        buffer->__c = 0xb;
mmc_rand_drand48.c:74:        buffer->__init = 1;
mmc_rand_drand48.c:83:    result = X * buffer->__a + buffer->__c;
mmc_rand_drand48.c:97:        return -1;
mmc_rand_drand48.c:109:    *result = temp.d - 1.0;
mmc_rand_drand48.c:116:    return __erand48_r (buffer->__x, buffer, result);
mmc_rand_drand48.c:121:    memcpy (buffer->__old_x, buffer->__x, sizeof (buffer->__x));
mmc_rand_drand48.c:124:    buffer->__x[2] = seed16v[2];
mmc_rand_drand48.c:125:    buffer->__x[1] = seed16v[1];
mmc_rand_drand48.c:126:    buffer->__x[0] = seed16v[0];
mmc_rand_drand48.c:127:    buffer->__a = 0x5deece66dull;
mmc_rand_drand48.c:128:    buffer->__c = 0xb;
mmc_rand_drand48.c:129:    buffer->__init = 1;
nthread:1:mmc_cu_host.cu:    uint meshlen = ((cfg->method == rtBLBadouelGrid) ? cfg->crop0.z : mesh->ne)
nthread:2:mmc_cu_host.cu:                   << cfg->nbuffer; // use 4 copies to reduce racing
nthread:3:mmc_cu_host.cu:    cfg->crop0.w = meshlen * cfg->maxgate; // offset for the second buffer
nthread:4:mmc_cu_host.cu:    uint detreclen = (2 + ((cfg->ismomentum) > 0)) * mesh->prop +
nthread:5:mmc_cu_host.cu:                     (cfg->issaveexit > 0) * 6 + 1;
nthread:6:mmc_cu_host.cu:    MCXParam param = {make_float3(cfg->srcpos.x, cfg->srcpos.y, cfg->srcpos.z),
nthread:7:mmc_cu_host.cu:                      make_float3(cfg->srcdir.x, cfg->srcdir.y, cfg->srcdir.z),
nthread:8:mmc_cu_host.cu:                      cfg->tstart,
nthread:9:mmc_cu_host.cu:                      cfg->tend,
nthread:10:mmc_cu_host.cu:                      (uint)cfg->isreflect,
nthread:11:mmc_cu_host.cu:                      (uint)cfg->issavedet,
nthread:12:mmc_cu_host.cu:                      (uint)cfg->issaveexit,
nthread:13:mmc_cu_host.cu:                      (uint)cfg->ismomentum,
nthread:14:mmc_cu_host.cu:                      (uint)cfg->isatomic,
nthread:15:mmc_cu_host.cu:                      (uint)cfg->isspecular,
nthread:16:mmc_cu_host.cu:                      1.f / cfg->tstep,
nthread:17:mmc_cu_host.cu:                      cfg->minenergy,
nthread:18:mmc_cu_host.cu:                      cfg->maxdetphoton,
nthread:19:mmc_cu_host.cu:                      (uint)cfg->detnum,
nthread:20:mmc_cu_host.cu:                      (int)cfg->voidtime,
nthread:21:mmc_cu_host.cu:                      (int)cfg->srctype,
nthread:22:mmc_cu_host.cu:                      cfg->srcparam1,
nthread:23:mmc_cu_host.cu:                      cfg->srcparam2,
nthread:24:mmc_cu_host.cu:                      (uint)cfg->issaveref,
nthread:25:mmc_cu_host.cu:                      (uint)cfg->maxgate,
nthread:26:mmc_cu_host.cu:                      (uint)cfg->debuglevel,
nthread:27:mmc_cu_host.cu:                      cfg->outputtype,
nthread:28:mmc_cu_host.cu:                      cfg->mcmethod,
nthread:29:mmc_cu_host.cu:                      cfg->method,
nthread:30:mmc_cu_host.cu:                      1.f / cfg->unitinmm,
nthread:31:mmc_cu_host.cu:                      cfg->srcdir.w,
nthread:32:mmc_cu_host.cu:                      cfg->nout,
nthread:33:mmc_cu_host.cu:                      cfg->roulettesize,
nthread:34:mmc_cu_host.cu:                      cfg->srcnum,
nthread:35:mmc_cu_host.cu:                      cfg->crop0,
nthread:36:mmc_cu_host.cu:                      cfg->bary0,
nthread:37:mmc_cu_host.cu:                      cfg->e0,
nthread:38:mmc_cu_host.cu:                      cfg->isextdet,
nthread:39:mmc_cu_host.cu:                      cfg->nbuffer,
nthread:40:mmc_cu_host.cu:                      (uint)(mesh->prop + 1 + cfg->isextdet) + cfg->detnum,
nthread:41:mmc_cu_host.cu:                      (uint)(MIN((MAX_PROP - (mesh->prop + 1 + cfg->isextdet) - cfg->detnum), ((mesh->ne) << 2)) >> 2), /*max count of elem normal data in const mem*/
nthread:42:mmc_cu_host.cu:                      cfg->issaveseed,
nthread:43:mmc_cu_host.cu:                      cfg->seed
nthread:44:mmc_cu_host.cu:        cfg->debuglevel = cfg->debuglevel & (~MCX_DEBUG_PROGRESS);
nthread:45:mmc_cu_host.cu:    if (threadid < MAX_DEVICE && cfg->deviceid[threadid] == '\0') {
nthread:46:mmc_cu_host.cu:    gpuid = cfg->deviceid[threadid] - 1;
nthread:47:mmc_cu_host.cu:        if (cfg->exportfield == NULL) {
nthread:48:mmc_cu_host.cu:            cfg->exportfield = mesh->weight;
nthread:49:mmc_cu_host.cu:        if (cfg->exportdetected == NULL) {
nthread:50:mmc_cu_host.cu:            cfg->exportdetected = (float*)malloc(hostdetreclen * cfg->maxdetphoton * sizeof(float));
nthread:51:mmc_cu_host.cu:        if (cfg->issaveseed && cfg->exportseed == NULL) {
nthread:52:mmc_cu_host.cu:            cfg->exportseed = (unsigned char*)malloc(cfg->maxdetphoton * (sizeof(RandType) * RAND_BUF_LEN));
nthread:53:mmc_cu_host.cu:        cfg->energytot = 0.f;
nthread:54:mmc_cu_host.cu:        cfg->energyesc = 0.f;
nthread:55:mmc_cu_host.cu:        cfg->runtime = 0;
nthread:56:mmc_cu_host.cu:                      sizeof(float) * cfg->maxdetphoton * hostdetreclen +
nthread:57:mmc_cu_host.cu:            MIN(((cfg->tend - cfg->tstart) / cfg->tstep + 0.5), gpu[gpuid].maxgate);
nthread:58:mmc_cu_host.cu:    if (!cfg->autopilot) {
nthread:59:mmc_cu_host.cu:        uint gates = (uint)((cfg->tend - cfg->tstart) / cfg->tstep + 0.5);
nthread:60:mmc_cu_host.cu:        gpu[gpuid].autothread = cfg->nthread;
nthread:61:mmc_cu_host.cu:        gpu[gpuid].autoblock = cfg->nblocksize;
nthread:62:mmc_cu_host.cu:        if (cfg->maxgate == 0) {
nthread:63:mmc_cu_host.cu:            cfg->maxgate = gates;
nthread:64:mmc_cu_host.cu:        } else if ((uint)cfg->maxgate > gates) {
nthread:65:mmc_cu_host.cu:            cfg->maxgate = gates;
nthread:66:mmc_cu_host.cu:        gpu[gpuid].maxgate = cfg->maxgate;
nthread:67:mmc_cu_host.cu:    uint nflen = mesh->nf * cfg->maxgate;
nthread:68:mmc_cu_host.cu:    for (i = 0; cfg->deviceid[i]; i++) {
nthread:69:mmc_cu_host.cu:        fullload += cfg->workload[i];
nthread:70:mmc_cu_host.cu:        for (i = 0; cfg->deviceid[i]; i++) {
nthread:71:mmc_cu_host.cu:            cfg->workload[i] = gpu[cfg->deviceid[i] - 1].core;
nthread:72:mmc_cu_host.cu:    for (i = 0; cfg->deviceid[i]; i++)
nthread:73:mmc_cu_host.cu:        if (cfg->workload[i] > 0.f) {
nthread:74:mmc_cu_host.cu:            fullload += cfg->workload[i];
nthread:75:mmc_cu_host.cu:    threadphoton = (int)(cfg->nphoton * cfg->workload[gpuid] /
nthread:76:mmc_cu_host.cu:                         (fullload * gpu[gpuid].autothread * cfg->respin));
nthread:77:mmc_cu_host.cu:        (int)(cfg->nphoton * cfg->workload[gpuid] / (fullload * cfg->respin) -
nthread:78:mmc_cu_host.cu:    field = (float*)calloc(sizeof(float) * meshlen * 2, cfg->maxgate);
nthread:79:mmc_cu_host.cu:    dref = (float*)calloc(sizeof(float) * mesh->nf, cfg->maxgate);
nthread:80:mmc_cu_host.cu:    Pdet = (float*)calloc(cfg->maxdetphoton * sizeof(float), hostdetreclen);
nthread:81:mmc_cu_host.cu:    fieldlen = meshlen * cfg->maxgate;
nthread:82:mmc_cu_host.cu:    if (cfg->seed > 0) {
nthread:83:mmc_cu_host.cu:        srand(cfg->seed);
nthread:84:mmc_cu_host.cu:                                   (mesh->prop + 1 + cfg->isextdet) * sizeof(Medium), 0,
nthread:85:mmc_cu_host.cu:    if (cfg->detpos && cfg->detnum) {
nthread:86:mmc_cu_host.cu:        if ((mesh->prop + 1 + cfg->isextdet) + cfg->detnum >= MAX_PROP) {
nthread:87:mmc_cu_host.cu:        CUDA_ASSERT(cudaMemcpyToSymbol(gmed, cfg->detpos,
nthread:88:mmc_cu_host.cu:                                       sizeof(float4)*cfg->detnum, (mesh->prop + 1 + cfg->isextdet) * sizeof(Medium),
nthread:89:mmc_cu_host.cu:                           sizeof(float) * cfg->maxdetphoton * hostdetreclen));
nthread:90:mmc_cu_host.cu:                           sizeof(float) * cfg->maxdetphoton * hostdetreclen,
nthread:91:mmc_cu_host.cu:    if (cfg->srctype == MCX_SRC_PATTERN) {
nthread:92:mmc_cu_host.cu:                               sizeof(float) * (int)(cfg->srcparam1.w * cfg->srcparam2.w)));
nthread:93:mmc_cu_host.cu:        CUDA_ASSERT(cudaMemcpy(gsrcpattern, cfg->srcpattern,
nthread:94:mmc_cu_host.cu:                               sizeof(float) * (int)(cfg->srcparam1.w * cfg->srcparam2.w),
nthread:95:mmc_cu_host.cu:    } else if (cfg->srctype == MCX_SRC_PATTERN3D) {
nthread:96:mmc_cu_host.cu:                               sizeof(float) * (int)(cfg->srcparam1.x * cfg->srcparam1.y*
nthread:97:mmc_cu_host.cu:                                       cfg->srcparam1.z)));
nthread:98:mmc_cu_host.cu:        CUDA_ASSERT(cudaMemcpy(gsrcpattern, cfg->srcpattern,
nthread:99:mmc_cu_host.cu:                               sizeof(float) * (int)(cfg->srcparam1.x * cfg->srcparam1.y*
nthread:100:mmc_cu_host.cu:                                       cfg->srcparam1.z),
nthread:101:mmc_cu_host.cu:    if (cfg->issaveseed) {
nthread:102:mmc_cu_host.cu:        Pphotonseed = (RandType*)calloc(cfg->maxdetphoton, (sizeof(RandType) * RAND_BUF_LEN));
nthread:103:mmc_cu_host.cu:        CUDA_ASSERT(cudaMalloc((void**)&gphotonseed, cfg->maxdetphoton * (sizeof(RandType)*RAND_BUF_LEN)));
nthread:104:mmc_cu_host.cu:    if (cfg->seed == SEED_FROM_FILE) {
nthread:105:mmc_cu_host.cu:        CUDA_ASSERT(cudaMalloc((void**)&greplayweight, sizeof(float)*cfg->nphoton));
nthread:106:mmc_cu_host.cu:        CUDA_ASSERT(cudaMemcpy(greplayweight, cfg->replayweight, sizeof(float)*cfg->nphoton, cudaMemcpyHostToDevice));
nthread:107:mmc_cu_host.cu:        CUDA_ASSERT(cudaMalloc((void**)&greplaytime, sizeof(float)*cfg->nphoton));
nthread:108:mmc_cu_host.cu:        CUDA_ASSERT(cudaMemcpy(greplaytime, cfg->replaytime, sizeof(float)*cfg->nphoton, cudaMemcpyHostToDevice));
nthread:109:mmc_cu_host.cu:        CUDA_ASSERT(cudaMalloc((void**)&greplayseed, (sizeof(RandType)*RAND_BUF_LEN)*cfg->nphoton));
nthread:110:mmc_cu_host.cu:        CUDA_ASSERT(cudaMemcpy(greplayseed, cfg->photonseed, (sizeof(RandType)*RAND_BUF_LEN)*cfg->nphoton, cudaMemcpyHostToDevice));
nthread:111:mmc_cu_host.cu:            cfg->flog, "- variant name: [%s] compiled by nvcc [%d.%d] with CUDA [%d]\n",
nthread:112:mmc_cu_host.cu:            cfg->flog, "- code name: [Vanilla MCX] compiled by nvcc [%d.%d] with CUDA [%d]\n",
nthread:113:mmc_cu_host.cu:        MMC_FPRINTF(cfg->flog, "- compiled with: [RNG] %s [Seed Length] %d\n",
nthread:114:mmc_cu_host.cu:        fflush(cfg->flog);
nthread:115:mmc_cu_host.cu:    MMC_FPRINTF(cfg->flog,
nthread:116:mmc_cu_host.cu:                oddphotons, cfg->nphoton * cfg->workload[gpuid] / fullload,
nthread:117:mmc_cu_host.cu:                cfg->respin);
nthread:118:mmc_cu_host.cu:    for (t = cfg->tstart; t < cfg->tend; t += cfg->tstep * cfg->maxgate) {
nthread:119:mmc_cu_host.cu:        twindow1 = t + cfg->tstep * cfg->maxgate;
nthread:120:mmc_cu_host.cu:        MMC_FPRINTF(cfg->flog,
nthread:121:mmc_cu_host.cu:        fflush(cfg->flog);
nthread:122:mmc_cu_host.cu:        for (int iter = 0; iter < cfg->respin; iter++) {
nthread:123:mmc_cu_host.cu:            MMC_FPRINTF(cfg->flog, "simulation run#%2d ... \n", iter + 1);
nthread:124:mmc_cu_host.cu:            fflush(cfg->flog);
nthread:125:mmc_cu_host.cu:            fflush(cfg->flog);
nthread:126:mmc_cu_host.cu:            if (cfg->issavedet) {
nthread:127:mmc_cu_host.cu:                if ((cfg->debuglevel & MCX_DEBUG_PROGRESS)) {
nthread:128:mmc_cu_host.cu:                    MMC_FPRINTF(cfg->flog, "\n");
nthread:129:mmc_cu_host.cu:            MMC_FPRINTF(cfg->flog,
nthread:130:mmc_cu_host.cu:            fflush(cfg->flog);
nthread:131:mmc_cu_host.cu:            if (cfg->runtime < tic1 - tic) {
nthread:132:mmc_cu_host.cu:                cfg->runtime = tic1 - tic;
nthread:133:mmc_cu_host.cu:            if (cfg->issavedet) {
nthread:134:mmc_cu_host.cu:                CUDA_ASSERT(cudaMemcpy(Pdet, gdetphoton, sizeof(float) * cfg->maxdetphoton * hostdetreclen,
nthread:135:mmc_cu_host.cu:                if (cfg->issaveseed) {
nthread:136:mmc_cu_host.cu:                    CUDA_ASSERT(cudaMemcpy(Pphotonseed, gphotonseed, cfg->maxdetphoton * (sizeof(RandType)*RAND_BUF_LEN),
nthread:137:mmc_cu_host.cu:                if (detected > cfg->maxdetphoton) {
nthread:138:mmc_cu_host.cu:                    MMC_FPRINTF(cfg->flog, "WARNING: the detected photon (%d) \
nthread:139:mmc_cu_host.cu:                                detected, cfg->maxdetphoton);
nthread:140:mmc_cu_host.cu:                    MMC_FPRINTF(cfg->flog, "detected %d photons, total: %d\t", detected,
nthread:141:mmc_cu_host.cu:                                cfg->detectedcount + detected);
nthread:142:mmc_cu_host.cu:                cfg->his.detected += detected;
nthread:143:mmc_cu_host.cu:                detected = MIN(detected, cfg->maxdetphoton);
nthread:144:mmc_cu_host.cu:                if (cfg->exportdetected) {
nthread:145:mmc_cu_host.cu:                        cfg->exportdetected = (float*)realloc(
nthread:146:mmc_cu_host.cu:                            cfg->exportdetected, (cfg->detectedcount + detected) *
nthread:147:mmc_cu_host.cu:                        memcpy(cfg->exportdetected + cfg->detectedcount * (hostdetreclen),
nthread:148:mmc_cu_host.cu:                        if (cfg->issaveseed) {
nthread:149:mmc_cu_host.cu:                            cfg->exportseed = (unsigned char*)realloc(cfg->exportseed, (cfg->detectedcount + detected) * (sizeof(RandType) * RAND_BUF_LEN));
nthread:150:mmc_cu_host.cu:                            memcpy(cfg->exportseed + cfg->detectedcount * sizeof(RandType)*RAND_BUF_LEN, Pphotonseed, detected * (sizeof(RandType)*RAND_BUF_LEN));
nthread:151:mmc_cu_host.cu:                        cfg->detectedcount += detected;
nthread:152:mmc_cu_host.cu:            if (cfg->issaveref) {
nthread:153:mmc_cu_host.cu:            if (cfg->issave2pt) {
nthread:154:mmc_cu_host.cu:                MMC_FPRINTF(cfg->flog, "transfer complete:        %d ms\n",
nthread:155:mmc_cu_host.cu:                fflush(cfg->flog);
nthread:156:mmc_cu_host.cu:                    field[(i >> cfg->nbuffer)] += rawfield[i] + rawfield[i + fieldlen];    //+rawfield[i+fieldlen];
nthread:157:mmc_cu_host.cu:                        cfg->energyesc += energy[(i << 1)];
nthread:158:mmc_cu_host.cu:                        cfg->energytot += energy[(i << 1) + 1];
nthread:159:mmc_cu_host.cu:            if (cfg->respin > 1 && RAND_SEED_WORD_LEN > 1) {
nthread:160:mmc_cu_host.cu:        fieldlen = (fieldlen >> cfg->nbuffer);
nthread:161:mmc_cu_host.cu:        if (cfg->exportfield) {
nthread:162:mmc_cu_host.cu:            if (cfg->basisorder == 0 || cfg->method == rtBLBadouelGrid) {
nthread:163:mmc_cu_host.cu:                    cfg->exportfield[i] += field[i];
nthread:164:mmc_cu_host.cu:                for (i = 0; i < cfg->maxgate; i++)
nthread:165:mmc_cu_host.cu:                            cfg->exportfield[i * mesh->nn +
nthread:166:mmc_cu_host.cu:        if (cfg->issaveref && mesh->dref) {
nthread:167:mmc_cu_host.cu:        if (cfg->isnormalized) {
nthread:168:mmc_cu_host.cu:            MMC_FPRINTF(cfg->flog, "normalizing raw data ...\t");
nthread:169:mmc_cu_host.cu:            fflush(cfg->flog);
nthread:170:mmc_cu_host.cu:            cfg->energyabs = cfg->energytot - cfg->energyesc;
nthread:171:mmc_cu_host.cu:            mesh_normalize(mesh, cfg, cfg->energyabs, cfg->energytot, 0);
nthread:172:mmc_cu_host.cu:        if (cfg->issave2pt && cfg->parentid == mpStandalone) {
nthread:173:mmc_cu_host.cu:            MMC_FPRINTF(cfg->flog, "saving data to file ...\t");
nthread:174:mmc_cu_host.cu:            MMC_FPRINTF(cfg->flog, "saving data complete : %d ms\n\n",
nthread:175:mmc_cu_host.cu:            fflush(cfg->flog);
nthread:176:mmc_cu_host.cu:        if (cfg->issavedet && cfg->parentid == mpStandalone &&
nthread:177:mmc_cu_host.cu:                cfg->exportdetected) {
nthread:178:mmc_cu_host.cu:            cfg->his.unitinmm = cfg->unitinmm;
nthread:179:mmc_cu_host.cu:            cfg->his.savedphoton = cfg->detectedcount;
nthread:180:mmc_cu_host.cu:            cfg->his.detected = cfg->detectedcount;
nthread:181:mmc_cu_host.cu:            mesh_savedetphoton(cfg->exportdetected, (void*)(cfg->exportseed), cfg->detectedcount,
nthread:182:mmc_cu_host.cu:        if (cfg->issaveref) {
nthread:183:mmc_cu_host.cu:            MMC_FPRINTF(cfg->flog, "saving surface diffuse reflectance ...");
nthread:184:mmc_cu_host.cu:        MMC_FPRINTF(cfg->flog,
nthread:185:mmc_cu_host.cu:                    cfg->nphoton, cfg->nphoton, reporter.raytet,
nthread:186:mmc_cu_host.cu:                    (double)cfg->nphoton / toc);
nthread:187:mmc_cu_host.cu:        MMC_FPRINTF(cfg->flog,
nthread:188:mmc_cu_host.cu:                    cfg->energytot,
nthread:189:mmc_cu_host.cu:                    (cfg->energytot - cfg->energyesc) / cfg->energytot * 100.f);
nthread:190:mmc_cu_host.cu:        fflush(cfg->flog);
nthread:191:mmc_core.cl:        if ((int)((r->photontimer + r->Lmove * (prop.n * R_C0) - gcfg->tstart)*GPU_PARAM(gcfg, Rtstep)) > GPU_PARAM(gcfg, maxgate) - 1) { /*exit time window*/
nthread:192:mmc_core.cl:            r->Lmove = (gcfg->tend - r->photontimer) / (prop.n * R_C0) - 1e-4f;
nthread:193:mmc_core.cl:            tshift = MIN( ((int)((r->photontimer - gcfg->tstart) * GPU_PARAM(gcfg, Rtstep))), GPU_PARAM(gcfg, maxgate) - 1 ) * GPU_PARAM(gcfg, framelen);
nthread:194:mmc_core.cl:                                atomicadd(weight + r->oldidx + gcfg->crop0.w, oldval);
nthread:195:mmc_core.cl:                            atomicadd(weight + r->oldidx + gcfg->crop0.w, oldval);
nthread:196:mmc_core.cl:                S.xyz =  (r->p0 - gcfg->nmin) + (T.xyz * FL3(0.5f)); /*starting point*/
nthread:197:mmc_core.cl:                S =  make_float4((r->p0.x - gcfg->nmin.x) + T.x * 0.5f, (r->p0.y - gcfg->nmin.y) + T.y * 0.5f, (r->p0.z - gcfg->nmin.z) + T.z * 0.5f, S.w); /*starting point*/
nthread:198:mmc_core.cl:                    uint newidx = (idx.z * gcfg->crop0.y + idx.y * gcfg->crop0.x + idx.x) + tshift;
nthread:199:mmc_core.cl:                                atomicadd(weight + r->oldidx + gcfg->crop0.w, oldval);
nthread:200:mmc_core.cl:                                atomicadd(weight + r->oldidx + gcfg->crop0.w, oldval);
nthread:201:mmc_core.cl:        r->p0.x = gcfg->srcpos.x + rx * gcfg->srcparam1.x + ry * gcfg->srcparam2.x;
nthread:202:mmc_core.cl:        r->p0.y = gcfg->srcpos.y + rx * gcfg->srcparam1.y + ry * gcfg->srcparam2.y;
nthread:203:mmc_core.cl:        r->p0.z = gcfg->srcpos.z + rx * gcfg->srcparam1.z + ry * gcfg->srcparam2.z;
nthread:204:mmc_core.cl:            int xsize = (int)gcfg->srcparam1.w;
nthread:205:mmc_core.cl:            int ysize = (int)gcfg->srcparam2.w;
nthread:206:mmc_core.cl:            r->weight = srcpattern[MIN( (int)(ry * gcfg->srcparam2.w), (int)gcfg->srcparam2.w - 1 ) * (int)(gcfg->srcparam1.w) + MIN( (int)(rx * gcfg->srcparam1.w), (int)gcfg->srcparam1.w - 1 )];
nthread:207:mmc_core.cl:            r->weight = (MCX_MATHFUN(cos)((floor(gcfg->srcparam1.w) * rx + floor(gcfg->srcparam2.w) * ry + gcfg->srcparam1.w - floor(gcfg->srcparam1.w)) * TWO_PI) * (1.f - gcfg->srcparam2.w + floor(gcfg->srcparam2.w)) + 1.f) * 0.5f;
nthread:208:mmc_core.cl:        origin.x += (gcfg->srcparam1.x + gcfg->srcparam2.x) * 0.5f;
nthread:209:mmc_core.cl:        origin.y += (gcfg->srcparam1.y + gcfg->srcparam2.y) * 0.5f;
nthread:210:mmc_core.cl:        origin.z += (gcfg->srcparam1.z + gcfg->srcparam2.z) * 0.5f;
nthread:211:mmc_core.cl:        float4 v2 = gcfg->srcparam1;
nthread:212:mmc_core.cl:        v2.w *= MCX_MATHFUN(rsqrt)(gcfg->srcparam1.x * gcfg->srcparam1.x + gcfg->srcparam1.y * gcfg->srcparam1.y + gcfg->srcparam1.z * gcfg->srcparam1.z);
nthread:213:mmc_core.cl:        v2.x = v2.w * (gcfg->srcdir.y * gcfg->srcparam1.z - gcfg->srcdir.z * gcfg->srcparam1.y);
nthread:214:mmc_core.cl:        v2.y = v2.w * (gcfg->srcdir.z * gcfg->srcparam1.x - gcfg->srcdir.x * gcfg->srcparam1.z);
nthread:215:mmc_core.cl:        v2.z = v2.w * (gcfg->srcdir.x * gcfg->srcparam1.y - gcfg->srcdir.y * gcfg->srcparam1.x);
nthread:216:mmc_core.cl:        r->p0.x = gcfg->srcpos.x + rx * gcfg->srcparam1.x + ry * v2.x;
nthread:217:mmc_core.cl:        r->p0.y = gcfg->srcpos.y + rx * gcfg->srcparam1.y + ry * v2.y;
nthread:218:mmc_core.cl:        r->p0.z = gcfg->srcpos.z + rx * gcfg->srcparam1.z + ry * v2.z;
nthread:219:mmc_core.cl:            r->weight = (MCX_MATHFUN(sin)((gcfg->srcparam2.x * rx + gcfg->srcparam2.z) * TWO_PI) * MCX_MATHFUN(sin)((gcfg->srcparam2.y * ry + gcfg->srcparam2.w) * TWO_PI) + 1.f) * 0.5f; //between 0 and 1
nthread:220:mmc_core.cl:            r->weight = (MCX_MATHFUN(cos)((gcfg->srcparam2.x * rx + gcfg->srcparam2.y * ry + gcfg->srcparam2.z) * TWO_PI) * (1.f - gcfg->srcparam2.w) + 1.f) * 0.5f; //between 0 and 1
nthread:221:mmc_core.cl:        origin.x += (gcfg->srcparam1.x + v2.x) * 0.5f;
nthread:222:mmc_core.cl:        origin.y += (gcfg->srcparam1.y + v2.y) * 0.5f;
nthread:223:mmc_core.cl:        origin.z += (gcfg->srcparam1.z + v2.z) * 0.5f;
nthread:224:mmc_core.cl:            r0 = MCX_MATHFUN(sqrt)(rand_uniform01(ran)) * gcfg->srcparam1.x;
nthread:225:mmc_core.cl:            if (fabs(GPU_PARAM(gcfg, focus)) < 1e-5f || fabs(gcfg->srcparam1.y) < 1e-5f) {
nthread:226:mmc_core.cl:                r0 = MCX_MATHFUN(sqrt)(-MCX_MATHFUN(log)((rand_uniform01(ran)))) * gcfg->srcparam1.x;
nthread:227:mmc_core.cl:                float z0 = gcfg->srcparam1.x * gcfg->srcparam1.x * M_PI / gcfg->srcparam1.y; //Rayleigh range
nthread:228:mmc_core.cl:                r0 = MCX_MATHFUN(sqrt)(-MCX_MATHFUN(log)((rand_uniform01(ran)) * (1.f + (GPU_PARAM(gcfg, focus) * GPU_PARAM(gcfg, focus) / (z0 * z0))))) * gcfg->srcparam1.x;
nthread:229:mmc_core.cl:        if (gcfg->srcdir.z > -1.f + EPS && gcfg->srcdir.z < 1.f - EPS) {
nthread:230:mmc_core.cl:            float tmp0 = 1.f - gcfg->srcdir.z * gcfg->srcdir.z;
nthread:231:mmc_core.cl:            r->p0.x = gcfg->srcpos.x + tmp1 * (gcfg->srcdir.x * gcfg->srcdir.z * cphi - gcfg->srcdir.y * sphi);
nthread:232:mmc_core.cl:            r->p0.y = gcfg->srcpos.y + tmp1 * (gcfg->srcdir.y * gcfg->srcdir.z * cphi + gcfg->srcdir.x * sphi);
nthread:233:mmc_core.cl:            r->p0.z = gcfg->srcpos.z - tmp1 * tmp0 * cphi;
nthread:234:mmc_core.cl:                ang = (gcfg->srcparam1.y > 0) ? TWO_PI * rand_uniform01(ran) : acos(2.f * rand_uniform01(ran) - 1.f); //sine distribution
nthread:235:mmc_core.cl:            } while (ang > gcfg->srcparam1.x);
nthread:236:mmc_core.cl:        ang = MCX_MATHFUN(sqrt)(-2.f * MCX_MATHFUN(log)((rand_uniform01(ran)))) * (1.f - 2.f * rand_uniform01(ran)) * gcfg->srcparam1.x;
nthread:237:mmc_core.cl:        r->p0.x += t * gcfg->srcparam1.x;
nthread:238:mmc_core.cl:        r->p0.y += t * gcfg->srcparam1.y;
nthread:239:mmc_core.cl:        r->p0.z += t * gcfg->srcparam1.z;
nthread:240:mmc_core.cl:        origin.x += (gcfg->srcparam1.x) * 0.5f;
nthread:241:mmc_core.cl:        origin.y += (gcfg->srcparam1.y) * 0.5f;
nthread:242:mmc_core.cl:        origin.z += (gcfg->srcparam1.z) * 0.5f;
nthread:243:mmc_core.cl:    ray r = {gcfg->srcpos, gcfg->srcdir, {MMC_UNDEFINED, 0.f, 0.f}, GPU_PARAM(gcfg, e0), 0, 0, 1.f, 0.f, 0.f, 0.f, ID_UNDEFINED, 0.f};
nthread:244:mmc_core.cl:                    int tshift = MIN( ((int)((r.photontimer - gcfg->tstart) * GPU_PARAM(gcfg, Rtstep))), GPU_PARAM(gcfg, maxgate) - 1 ) * GPU_PARAM(gcfg, nf);
nthread:245:mmc_core.cl:        if (GPU_PARAM(gcfg, minenergy) > 0.f && r.weight < GPU_PARAM(gcfg, minenergy) && (gcfg->tend - gcfg->tstart)*GPU_PARAM(gcfg, Rtstep) <= 1.f) { /*Russian Roulette*/
nthread:246:mmc_cuda_query_gpu.cu:    if (cfg->gpuid && cfg->gpuid > (uint)deviceCount) {
nthread:247:mmc_cuda_query_gpu.cu:        if (cfg->isgpuinfo == 3) {
nthread:248:mmc_cuda_query_gpu.cu:        } else if (cfg->deviceid[dev] == '1') {
nthread:249:mmc_cuda_query_gpu.cu:            cfg->deviceid[dev] = '\0';
nthread:250:mmc_cuda_query_gpu.cu:            cfg->deviceid[activedev] = dev + 1;
nthread:251:mmc_cuda_query_gpu.cu:        (*info)[dev].maxgate = cfg->maxgate;
nthread:252:mmc_cuda_query_gpu.cu:            if (cfg->isgpuinfo) {
nthread:253:mmc_cuda_query_gpu.cu:    if (cfg->isgpuinfo == 2 &&
nthread:254:mmc_cuda_query_gpu.cu:            cfg->parentid == mpStandalone) { // list GPU info only
nthread:255:mmc_cuda_query_gpu.cu:        cfg->deviceid[activedev] = '\0';
nthread:256:mmc_mesh.c:    if (cfg->basisorder == 2) {
nthread:257:mmc_mesh.c:    if (cfg->seed == SEED_FROM_FILE && cfg->seedfile[0]) {
nthread:258:mmc_mesh.c:    sprintf(filename, format, cfg->meshtag);
nthread:259:mmc_mesh.c:    if (cfg->rootpath[0]) {
nthread:260:mmc_mesh.c:        sprintf(foutput, "%s%c%s", cfg->rootpath, pathsep, filename);
nthread:261:mmc_mesh.c:    if (cfg->method == rtBLBadouelGrid) {
nthread:262:mmc_mesh.c:    cfg->dim.x = (int)((mesh->nmax.x - mesh->nmin.x) / cfg->steps.x) + 1;
nthread:263:mmc_mesh.c:    cfg->dim.y = (int)((mesh->nmax.y - mesh->nmin.y) / cfg->steps.y) + 1;
nthread:264:mmc_mesh.c:    cfg->dim.z = (int)((mesh->nmax.z - mesh->nmin.z) / cfg->steps.z) + 1;
nthread:265:mmc_mesh.c:    cfg->crop0.x = cfg->dim.x;
nthread:266:mmc_mesh.c:    cfg->crop0.y = cfg->dim.y * cfg->dim.x;
nthread:267:mmc_mesh.c:    cfg->crop0.z = cfg->dim.y * cfg->dim.x * cfg->dim.z;
nthread:268:mmc_mesh.c:    mesh->med = (medium*)calloc(sizeof(medium), mesh->prop + 1 + cfg->isextdet);
nthread:269:mmc_mesh.c:    mesh->atte = (float*)calloc(sizeof(float), mesh->prop + 1 + cfg->isextdet);
nthread:270:mmc_mesh.c:    mesh->med[0].n = cfg->nout;
nthread:271:mmc_mesh.c:    if (cfg->isextdet) {
nthread:272:mmc_mesh.c:        /*mesh->atte[i]=expf(-cfg->minstep*mesh->med[i].mua);*/
nthread:273:mmc_mesh.c:    if (cfg->method != rtBLBadouelGrid && cfg->unitinmm != 1.f) {
nthread:274:mmc_mesh.c:            mesh->med[i].mus *= cfg->unitinmm;
nthread:275:mmc_mesh.c:            mesh->med[i].mua *= cfg->unitinmm;
nthread:276:mmc_mesh.c:    cfg->his.maxmedia = mesh->prop; /*skip media 0*/
nthread:277:mmc_mesh.c:    datalen = (cfg->method == rtBLBadouelGrid) ? cfg->crop0.z : ( (cfg->basisorder) ? mesh->nn : mesh->ne);
nthread:278:mmc_mesh.c:    mesh->weight = (double*)calloc(sizeof(double) * datalen, cfg->maxgate * cfg->srcnum);
nthread:279:mmc_mesh.c:            cfg->e0 = (cfg->e0 == 0) ? i + 1 : cfg->e0;
nthread:280:mmc_mesh.c:            cfg->isextdet = 1;
nthread:281:mmc_mesh.c:            cfg->detnum = 0; // when detecting wide-field detectors, suppress point detectors
nthread:282:mmc_mesh.c:    FILE* fp = fopen(cfg->seedfile, "rb");
nthread:283:mmc_mesh.c:    cfg->photonseed = malloc(his.savedphoton * his.seedbyte);
nthread:284:mmc_mesh.c:    if (cfg->photonseed == NULL) {
nthread:285:mmc_mesh.c:    if (fread(cfg->photonseed, his.seedbyte, his.savedphoton, fp) != his.savedphoton) {
nthread:286:mmc_mesh.c:    cfg->seed = SEED_FROM_FILE;
nthread:287:mmc_mesh.c:    cfg->nphoton = his.savedphoton;
nthread:288:mmc_mesh.c:    if (cfg->outputtype == otJacobian || cfg->outputtype == otWL || cfg->outputtype == otWP || cfg->replaydet > 0) {
nthread:289:mmc_mesh.c:        cfg->replayweight = (float*)malloc(his.savedphoton * sizeof(float));
nthread:290:mmc_mesh.c:        cfg->replaytime = (float*)malloc(his.savedphoton * sizeof(float));
nthread:291:mmc_mesh.c:        cfg->nphoton = 0;
nthread:292:mmc_mesh.c:            if (cfg->replaydet == 0 || cfg->replaydet == (int)(ppath[i * his.colcount])) {
nthread:293:mmc_mesh.c:                memcpy((char*)(cfg->photonseed) + cfg->nphoton * his.seedbyte, (char*)(cfg->photonseed) + i * his.seedbyte, his.seedbyte);
nthread:294:mmc_mesh.c:                if ((cfg->detparam1.w * cfg->detparam2.w > 0) && (cfg->detpattern != NULL)) {
nthread:295:mmc_mesh.c:                    cfg->replayweight[cfg->nphoton] = mesh_getdetweight(i, his.colcount, ppath, cfg);
nthread:296:mmc_mesh.c:                    cfg->replayweight[cfg->nphoton] = ppath[(i + 1) * his.colcount - 1];
nthread:297:mmc_mesh.c:                    cfg->replayweight[cfg->nphoton] *= expf(-mesh->med[j - 1].mua * ppath[i * his.colcount + j] * his.unitinmm);
nthread:298:mmc_mesh.c:                cfg->replaytime[cfg->nphoton] = 0.f;
nthread:299:mmc_mesh.c:                    cfg->replaytime[cfg->nphoton] += mesh->med[j - 1].n * ppath[i * his.colcount + j] * R_C0;
nthread:300:mmc_mesh.c:                cfg->nphoton++;
nthread:301:mmc_mesh.c:        cfg->photonseed = realloc(cfg->photonseed, cfg->nphoton * his.seedbyte);
nthread:302:mmc_mesh.c:        cfg->replayweight = (float*)realloc(cfg->replayweight, cfg->nphoton * sizeof(float));
nthread:303:mmc_mesh.c:        cfg->replaytime = (float*)realloc(cfg->replaytime, cfg->nphoton * sizeof(float));
nthread:304:mmc_mesh.c:        cfg->minenergy = 0.f;
nthread:305:mmc_mesh.c:    if (cfg->compute == cbOptiX) {
nthread:306:mmc_mesh.c:    } else if ( (cfg->srctype == stPencil || cfg->srctype == stIsotropic || cfg->srctype == stCone || cfg->srctype == stArcSin)  && cfg->e0 > 0) {
nthread:307:mmc_mesh.c:        int eid = cfg->e0 - 1;
nthread:308:mmc_mesh.c:        float s = 0.f, *bary = &(cfg->bary0.x);
nthread:309:mmc_mesh.c:            vec_diff(&nodes[ea], &(cfg->srcpos), &vecS);
nthread:310:mmc_mesh.c:        if (cfg->debuglevel & dlWeight)
nthread:311:mmc_mesh.c:            fprintf(cfg->flog, "initial bary-centric volumes [%e %e %e %e]\n",
nthread:312:mmc_mesh.c:    if (cfg->issaveref) {
nthread:313:mmc_mesh.c:        tracer->mesh->dref = (double*)calloc(sizeof(double) * tracer->mesh->nf * cfg->srcnum, cfg->maxgate);
nthread:314:mmc_mesh.c:    if (cfg->ismomentum) {
nthread:315:mmc_mesh.c:    int i, j, datalen = (cfg->method == rtBLBadouelGrid) ? cfg->crop0.z : ( (cfg->basisorder) ? mesh->nn : mesh->ne);
nthread:316:mmc_mesh.c:    if (cfg->rootpath[0]) {
nthread:317:mmc_mesh.c:        sprintf(fweight, "%s%c%s%s.dat", cfg->rootpath, pathsep, cfg->session, (isref ? "_dref" : ""));
nthread:318:mmc_mesh.c:        sprintf(fweight, "%s%s.dat", cfg->session, (isref ? "_dref" : ""));
nthread:319:mmc_mesh.c:    if (cfg->outputformat >= ofBin && cfg->outputformat <= ofBJNifti) {
nthread:320:mmc_mesh.c:        uint3 dim0 = cfg->dim;
nthread:321:mmc_mesh.c:        if (cfg->method != rtBLBadouelGrid) {
nthread:322:mmc_mesh.c:            cfg->dim.x = cfg->srcnum;
nthread:323:mmc_mesh.c:            cfg->dim.y = cfg->maxgate;
nthread:324:mmc_mesh.c:            cfg->dim.z = datalen;
nthread:325:mmc_mesh.c:        mcx_savedata(mesh->weight, datalen * cfg->maxgate * cfg->srcnum, cfg, isref);
nthread:326:mmc_mesh.c:        cfg->dim = dim0;
nthread:327:mmc_mesh.c:    for (i = 0; i < cfg->maxgate; i++) {
nthread:328:mmc_mesh.c:            if (1 == cfg->srcnum) {
nthread:329:mmc_mesh.c:                for (k = 0; k < cfg->srcnum; k++) {
nthread:330:mmc_mesh.c:                    shift = (i * datalen + j) * cfg->srcnum + k;
nthread:331:mmc_mesh.c:    if (cfg->rootpath[0]) {
nthread:332:mmc_mesh.c:        sprintf(fhistory, "%s%c%s.mch", cfg->rootpath, pathsep, cfg->session);
nthread:333:mmc_mesh.c:        sprintf(fhistory, "%s.mch", cfg->session);
nthread:334:mmc_mesh.c:    cfg->his.totalphoton = cfg->nphoton;
nthread:335:mmc_mesh.c:    cfg->his.unitinmm = 1.f;
nthread:336:mmc_mesh.c:    if (cfg->method != rtBLBadouelGrid) {
nthread:337:mmc_mesh.c:        cfg->his.unitinmm = cfg->unitinmm;
nthread:338:mmc_mesh.c:    cfg->his.detected = count;
nthread:339:mmc_mesh.c:    cfg->his.savedphoton = count;
nthread:340:mmc_mesh.c:    cfg->his.srcnum = cfg->srcnum;
nthread:341:mmc_mesh.c:    cfg->his.detnum = cfg->detnum;
nthread:342:mmc_mesh.c:    if (cfg->issaveseed && seeds != NULL) {
nthread:343:mmc_mesh.c:        cfg->his.seedbyte = seedbyte;
nthread:344:mmc_mesh.c:    cfg->his.colcount = (2 + (cfg->ismomentum > 0)) * cfg->his.maxmedia + (cfg->issaveexit > 0) * 6 + 2; /*column count=maxmedia+3*/
nthread:345:mmc_mesh.c:    if (count > 0 && cfg->exportdetected == NULL) {
nthread:346:mmc_mesh.c:        cfg->detectedcount = count;
nthread:347:mmc_mesh.c:        cfg->exportdetected = (float*)malloc(cfg->his.colcount * cfg->detectedcount * sizeof(float));
nthread:348:mmc_mesh.c:    if (cfg->exportdetected != ppath) {
nthread:349:mmc_mesh.c:        memcpy(cfg->exportdetected, ppath, count * cfg->his.colcount * sizeof(float));
nthread:350:mmc_mesh.c:    fwrite(&(cfg->his), sizeof(history), 1, fp);
nthread:351:mmc_mesh.c:    fwrite(ppath, sizeof(float), count * cfg->his.colcount, fp);
nthread:352:mmc_mesh.c:    if (cfg->issaveseed && seeds != NULL) {
nthread:353:mmc_mesh.c:    // cfg->issaveexit is 2 for this mode
nthread:354:mmc_mesh.c:    int colcount = (2 + (cfg->ismomentum > 0)) * cfg->his.maxmedia + 6 + 2;
nthread:355:mmc_mesh.c:    float x0 = cfg->detpos[0].x;
nthread:356:mmc_mesh.c:    float y0 = cfg->detpos[0].y;
nthread:357:mmc_mesh.c:    float xrange = cfg->detparam1.x + cfg->detparam2.x;
nthread:358:mmc_mesh.c:    float yrange = cfg->detparam1.y + cfg->detparam2.y;
nthread:359:mmc_mesh.c:    int xsize = cfg->detparam1.w;
nthread:360:mmc_mesh.c:    int ysize = cfg->detparam2.w;
nthread:361:mmc_mesh.c:    float unitinmm = (cfg->method != rtBLBadouelGrid) ? cfg->his.unitinmm : 1.f;
nthread:362:mmc_mesh.c:        for (j = 1; j <= cfg->his.maxmedia; j++) {
nthread:363:mmc_mesh.c:            path += ppath[i * colcount + j + cfg->his.maxmedia] * mesh->med[j].n;
nthread:364:mmc_mesh.c:            weight *= expf(-ppath[i * colcount + j + cfg->his.maxmedia] * mesh->med[j].mua * unitinmm);
nthread:365:mmc_mesh.c:        ntg = (int) path * R_C0 / cfg->tstep;
nthread:366:mmc_mesh.c:        if (ntg > cfg->maxgate - 1) {
nthread:367:mmc_mesh.c:            ntg = cfg->maxgate - 1;
nthread:368:mmc_mesh.c:    if (cfg->rootpath[0]) {
nthread:369:mmc_mesh.c:        sprintf(fhistory, "%s%c%s.img", cfg->rootpath, pathsep, cfg->session);
nthread:370:mmc_mesh.c:        sprintf(fhistory, "%s.img", cfg->session);
nthread:371:mmc_mesh.c:    fwrite(detmap, sizeof(float), cfg->detparam1.w * cfg->detparam2.w * cfg->maxgate, fp);
nthread:372:mmc_mesh.c:    float x0 = cfg->detpos[0].x;
nthread:373:mmc_mesh.c:    float y0 = cfg->detpos[0].y;
nthread:374:mmc_mesh.c:    float xrange = cfg->detparam1.x + cfg->detparam2.x;
nthread:375:mmc_mesh.c:    float yrange = cfg->detparam1.y + cfg->detparam2.y;
nthread:376:mmc_mesh.c:    int xsize = cfg->detparam1.w;
nthread:377:mmc_mesh.c:    int ysize = cfg->detparam2.w;
nthread:378:mmc_mesh.c:    return cfg->detpattern[yindex * xsize + xindex];
nthread:379:mmc_mesh.c:    int datalen = (cfg->method == rtBLBadouelGrid) ? cfg->crop0.z : ( (cfg->basisorder) ? mesh->nn : mesh->ne);
nthread:380:mmc_mesh.c:    if (cfg->issaveref && mesh->dref) {
nthread:381:mmc_mesh.c:        for (i = 0; i < cfg->maxgate; i++)
nthread:382:mmc_mesh.c:    if (cfg->seed == SEED_FROM_FILE && (cfg->outputtype == otJacobian || cfg->outputtype == otWL || cfg->outputtype == otWP)) {
nthread:383:mmc_mesh.c:        float normalizor = 1.f / (DELTA_MUA * cfg->nphoton);
nthread:384:mmc_mesh.c:        if (cfg->outputtype == otWL || cfg->outputtype == otWP) {
nthread:385:mmc_mesh.c:        for (i = 0; i < cfg->maxgate; i++)
nthread:386:mmc_mesh.c:                mesh->weight[(i * datalen + j)*cfg->srcnum + pair] *= normalizor;
nthread:387:mmc_mesh.c:    if (cfg->outputtype == otEnergy) {
nthread:388:mmc_mesh.c:        for (i = 0; i < cfg->maxgate; i++)
nthread:389:mmc_mesh.c:                mesh->weight[(i * datalen + j)*cfg->srcnum + pair] *= normalizor;
nthread:390:mmc_mesh.c:    if (cfg->method == rtBLBadouelGrid) {
nthread:391:mmc_mesh.c:        normalizor = 1.0 / (Etotal * cfg->unitinmm * cfg->unitinmm * cfg->unitinmm); /*scaling factor*/
nthread:392:mmc_mesh.c:        if (cfg->basisorder) {
nthread:393:mmc_mesh.c:            for (i = 0; i < cfg->maxgate; i++)
nthread:394:mmc_mesh.c:                        mesh->weight[(i * datalen + j)*cfg->srcnum + pair] /= mesh->nvol[j];
nthread:395:mmc_mesh.c:                for (j = 0; j < cfg->maxgate; j++)
nthread:396:mmc_mesh.c:                        energyelem += mesh->weight[(j * mesh->nn + ee[k] - 1) * cfg->srcnum + pair];    /*1/4 factor is absorbed two lines below*/
nthread:397:mmc_mesh.c:                for (j = 0; j < cfg->maxgate; j++) {
nthread:398:mmc_mesh.c:                    energydeposit += mesh->weight[(j * datalen + i) * cfg->srcnum + pair];
nthread:399:mmc_mesh.c:                for (j = 0; j < cfg->maxgate; j++) {
nthread:400:mmc_mesh.c:                    mesh->weight[(j * datalen + i)*cfg->srcnum + pair] /= energyelem;
nthread:401:mmc_mesh.c:    if (cfg->outputtype == otFlux) {
nthread:402:mmc_mesh.c:        normalizor /= cfg->tstep;
nthread:403:mmc_mesh.c:    for (i = 0; i < cfg->maxgate; i++)
nthread:404:mmc_mesh.c:            mesh->weight[(i * datalen + j)*cfg->srcnum + pair] *= normalizor;
nthread:407:mmc_cl_utils.c:                if (cfg->isgpuinfo) {
nthread:408:mmc_cl_utils.c:                    MMC_FPRINTF(cfg->flog, "Platform [%d] Name %s\n", i, pbuf);
nthread:409:mmc_cl_utils.c:                        cuinfo.maxgate = cfg->maxgate;
nthread:410:mmc_cl_utils.c:                        if (cfg->isgpuinfo) {
nthread:411:mmc_cl_utils.c:                            MMC_FPRINTF(cfg->flog, "============ %s device ID %d [%d of %d]: %s  ============\n", devname[j], cuid, k + 1, devnum, cuinfo.name);
nthread:412:mmc_cl_utils.c:                            MMC_FPRINTF(cfg->flog, " Device %d of %d:\t\t%s\n", cuid + 1, devnum, cuinfo.name);
nthread:413:mmc_cl_utils.c:                            MMC_FPRINTF(cfg->flog, " Compute units   :\t%d core(s)\n", (uint)cuinfo.sm);
nthread:414:mmc_cl_utils.c:                            MMC_FPRINTF(cfg->flog, " Global memory   :\t%ld B\n", (unsigned long)cuinfo.globalmem);
nthread:415:mmc_cl_utils.c:                            MMC_FPRINTF(cfg->flog, " Local memory    :\t%ld B\n", (unsigned long)cuinfo.sharedmem);
nthread:416:mmc_cl_utils.c:                            MMC_FPRINTF(cfg->flog, " Constant memory :\t%ld B\n", (unsigned long)cuinfo.constmem);
nthread:417:mmc_cl_utils.c:                            MMC_FPRINTF(cfg->flog, " Clock speed     :\t%d MHz\n", cuinfo.clock);
nthread:418:mmc_cl_utils.c:                                MMC_FPRINTF(cfg->flog, " Compute Capacity:\t%d.%d\n", cuinfo.major, cuinfo.minor);
nthread:419:mmc_cl_utils.c:                                MMC_FPRINTF(cfg->flog, " Stream Processor:\t%d\n", cuinfo.core);
nthread:420:mmc_cl_utils.c:                                MMC_FPRINTF(cfg->flog, " GFXIP version:   \t%d.%d\n", cuinfo.major, cuinfo.minor);
nthread:421:mmc_cl_utils.c:                                MMC_FPRINTF(cfg->flog, " Stream Processor:\t%d\n", cuinfo.core);
nthread:422:mmc_cl_utils.c:                            MMC_FPRINTF(cfg->flog, " Vendor name    :\t%s\n", VendorList[cuinfo.vendor]);
nthread:423:mmc_cl_utils.c:                            MMC_FPRINTF(cfg->flog, " Auto-thread    :\t%d\n", (uint)cuinfo.autothread);
nthread:424:mmc_cl_utils.c:                            MMC_FPRINTF(cfg->flog, " Auto-block     :\t%d\n", (uint)cuinfo.autoblock);
nthread:425:mmc_cl_utils.c:                            if (cfg->deviceid[cuid++] == '1') {
nthread:426:mmc_cl_utils.c:                                    fflush(cfg->flog);
nthread:427:mmc_cl_utils.c:    if (cfg->isgpuinfo == 2 && cfg->parentid == mpStandalone) {
nthread:428:mmc_raytrace.c:    mus = (cfg->mcmethod == mmMCX) ? prop->mus : (prop->mua + prop->mus);
nthread:429:mmc_raytrace.c:    if (cfg->debuglevel & dlTracing) {
nthread:430:mmc_raytrace.c:        MMC_FPRINTF(cfg->flog, "%d \n", eid);
nthread:431:mmc_raytrace.c:        //if(cfg->debuglevel&dlTracing) MMC_FPRINTF(cfg->flog,"testing face [%d]\n",i);
nthread:432:mmc_raytrace.c:            //if(cfg->debuglevel&dlTracingExit) MMC_FPRINTF(cfg->flog,"ray exits face %d[%d] of %d\n",i,faceorder[i],eid);
nthread:433:mmc_raytrace.c:            //if(cfg->debuglevel&dlTracingExit) MMC_FPRINTF(cfg->flog,"exit point %f %f %f\n",r->pout.x,r->pout.y,r->pout.z);
nthread:434:mmc_raytrace.c:        if ((int)((r->photontimer + r->Lmove * rc - cfg->tstart)*visit->rtstep) >= (int)((cfg->tend - cfg->tstart)*visit->rtstep)) { /*exit time window*/
nthread:435:mmc_raytrace.c:            r->Lmove = (cfg->tend - r->photontimer) / (prop->n * R_C0) - 1e-4f;
nthread:436:mmc_raytrace.c:        if (cfg->mcmethod == mmMCX) {
nthread:437:mmc_raytrace.c:        if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otJacobian) {
nthread:438:mmc_raytrace.c:            currweight *= cfg->replayweight[r->photonid];
nthread:439:mmc_raytrace.c:        } else if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otWL) {
nthread:440:mmc_raytrace.c:            currweight *= cfg->replayweight[r->photonid];
nthread:441:mmc_raytrace.c:        if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otWP) {
nthread:442:mmc_raytrace.c:            currweight *= cfg->replayweight[r->photonid];
nthread:443:mmc_raytrace.c:        //if(cfg->debuglevel&dlWeight) MMC_FPRINTF(cfg->flog,"update weight to %f and path end %d \n",r->weight,r->isend);
nthread:444:mmc_raytrace.c:        if (!cfg->basisorder) {
nthread:445:mmc_raytrace.c:            if (cfg->outputtype == otWL || cfg->outputtype == otWP) {
nthread:446:mmc_raytrace.c:                tshift = MIN( ((int)(cfg->replaytime[r->photonid] * visit->rtstep)), cfg->maxgate - 1 ) * tracer->mesh->ne;
nthread:447:mmc_raytrace.c:                tshift = MIN( ((int)((r->photontimer - cfg->tstart) * visit->rtstep)), cfg->maxgate - 1 ) * tracer->mesh->ne;
nthread:448:mmc_raytrace.c:            if (cfg->mcmethod == mmMCX) {
nthread:449:mmc_raytrace.c:                if (cfg->srctype != stPattern) {
nthread:450:mmc_raytrace.c:                    if (cfg->isatomic)
nthread:451:mmc_raytrace.c:                    int psize = (int)cfg->srcparam1.w * (int)cfg->srcparam2.w; // total number of pixels in each pattern
nthread:452:mmc_raytrace.c:                    for (pidx = 0; pidx < cfg->srcnum; pidx++) {
nthread:453:mmc_raytrace.c:                        if (cfg->isatomic)
nthread:454:mmc_raytrace.c:                            tracer->mesh->weight[(eid + tshift)*cfg->srcnum + pidx] += ww * cfg->srcpattern[pidx * psize + r->posidx];
nthread:455:mmc_raytrace.c:                            tracer->mesh->weight[(eid + tshift)*cfg->srcnum + pidx] += ww * cfg->srcpattern[pidx * psize + r->posidx];
nthread:456:mmc_raytrace.c:            if (cfg->debuglevel & dlBary) MMC_FPRINTF(cfg->flog, "Y [%f %f %f %f]\n",
nthread:457:mmc_raytrace.c:                    if (cfg->outputtype != otEnergy && cfg->outputtype != otWP) {
nthread:458:mmc_raytrace.c:                    if (cfg->outputtype == otWL || cfg->outputtype == otWP) {
nthread:459:mmc_raytrace.c:                        tshift = MIN( ((int)(cfg->replaytime[r->photonid] * visit->rtstep)), cfg->maxgate - 1 ) * tracer->mesh->nn;
nthread:460:mmc_raytrace.c:                        tshift = MIN( ((int)((r->photontimer - cfg->tstart) * visit->rtstep)), cfg->maxgate - 1 ) * tracer->mesh->nn;
nthread:461:mmc_raytrace.c:                    if (cfg->debuglevel & dlAccum) MMC_FPRINTF(cfg->flog, "A %f %f %f %e %d %e\n",
nthread:462:mmc_raytrace.c:                    if (cfg->mcmethod == mmMCX) {
nthread:463:mmc_raytrace.c:                        if (cfg->srctype != stPattern) {
nthread:464:mmc_raytrace.c:                            if (cfg->isatomic)
nthread:465:mmc_raytrace.c:                            int psize = (int)cfg->srcparam1.w * (int)cfg->srcparam2.w; // total number of pixels in each pattern
nthread:466:mmc_raytrace.c:                            for (pidx = 0; pidx < cfg->srcnum; pidx++) {
nthread:467:mmc_raytrace.c:                                if (cfg->isatomic)
nthread:468:mmc_raytrace.c:                                        tracer->mesh->weight[(ee[i] - 1 + tshift)*cfg->srcnum + pidx] += ww * cfg->srcpattern[pidx * psize + r->posidx] * (baryp0[i] + baryout[i]);
nthread:469:mmc_raytrace.c:                                        tracer->mesh->weight[(ee[i] - 1 + tshift)*cfg->srcnum + pidx] += ww * cfg->srcpattern[pidx * psize + r->posidx] * (baryp0[i] + baryout[i]);
nthread:470:mmc_raytrace.c:    mus = (cfg->mcmethod == mmMCX) ? prop->mus : (prop->mua + prop->mus);
nthread:471:mmc_raytrace.c:            if ((int)((r->photontimer + r->Lmove * rc - cfg->tstart)*visit->rtstep) >= (int)((cfg->tend - cfg->tstart)*visit->rtstep)) { /*exit time window*/
nthread:472:mmc_raytrace.c:                r->Lmove = (cfg->tend - r->photontimer) / (prop->n * R_C0) - 1e-4f;
nthread:473:mmc_raytrace.c:            if (cfg->mcmethod == mmMCX) {
nthread:474:mmc_raytrace.c:            if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otJacobian) {
nthread:475:mmc_raytrace.c:                currweight *= cfg->replayweight[r->photonid];
nthread:476:mmc_raytrace.c:            } else if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otWL) {
nthread:477:mmc_raytrace.c:                currweight *= cfg->replayweight[r->photonid];
nthread:478:mmc_raytrace.c:            if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otWP) {
nthread:479:mmc_raytrace.c:                currweight *= cfg->replayweight[r->photonid];
nthread:480:mmc_raytrace.c:                if (cfg->outputtype != otEnergy && cfg->outputtype != otWP) {
nthread:481:mmc_raytrace.c:            if (cfg->outputtype == otWL || cfg->outputtype == otWP) {
nthread:482:mmc_raytrace.c:                tshift = MIN( ((int)(cfg->replaytime[r->photonid] * visit->rtstep)), cfg->maxgate - 1 ) * (cfg->basisorder ? tracer->mesh->nn : tracer->mesh->ne);
nthread:483:mmc_raytrace.c:                tshift = MIN( ((int)((r->photontimer - cfg->tstart) * visit->rtstep)), cfg->maxgate - 1 ) * (cfg->basisorder ? tracer->mesh->nn : tracer->mesh->ne);
nthread:484:mmc_raytrace.c:            if (cfg->debuglevel & dlAccum) MMC_FPRINTF(cfg->flog, "A %f %f %f %e %d %e\n",
nthread:485:mmc_raytrace.c:            if (cfg->debuglevel & dlBary) MMC_FPRINTF(cfg->flog, "Y [%f %f %f %f]\n",
nthread:486:mmc_raytrace.c:            if (cfg->debuglevel & dlAccum) MMC_FPRINTF(cfg->flog, "A %f %f %f %e %d %e\n",
nthread:487:mmc_raytrace.c:            //if(cfg->debuglevel&dlBary)
nthread:488:mmc_raytrace.c:            //    MMC_FPRINTF(cfg->flog,"old bary0=[%f %f %f %f]\n",r->bary0.x,r->bary0.y,r->bary0.z,r->bary0.w);
nthread:489:mmc_raytrace.c:                //if(cfg->debuglevel&dlBary) MMC_FPRINTF(cfg->flog,"[%d %d %d %d],[%d %d %d %d] - ",
nthread:490:mmc_raytrace.c:                //if(cfg->debuglevel&dlBary) MMC_FPRINTF(cfg->flog,"[%f %f %f %f],[%f %f %f %f]\n",barypout[0],barypout[1],barypout[2],barypout[3],
nthread:491:mmc_raytrace.c:            //if(cfg->debuglevel&dlBary)
nthread:492:mmc_raytrace.c:            //    MMC_FPRINTF(cfg->flog,"new bary0=[%f %f %f %f]\n",r->bary0.x,r->bary0.y,r->bary0.z,r->bary0.w);
nthread:493:mmc_raytrace.c:            if (cfg->mcmethod == mmMCX) {
nthread:494:mmc_raytrace.c:                if (!cfg->basisorder) {
nthread:495:mmc_raytrace.c:                    if (cfg->srctype != stPattern) {
nthread:496:mmc_raytrace.c:                        if (cfg->isatomic)
nthread:497:mmc_raytrace.c:                        int psize = (int)cfg->srcparam1.w * (int)cfg->srcparam2.w; // total number of pixels in each pattern
nthread:498:mmc_raytrace.c:                        for (pidx = 0; pidx < cfg->srcnum; pidx++) {
nthread:499:mmc_raytrace.c:                            if (cfg->isatomic)
nthread:500:mmc_raytrace.c:                                tracer->mesh->weight[(eid + tshift)*cfg->srcnum + pidx] += ww * cfg->srcpattern[pidx * psize + r->posidx];
nthread:501:mmc_raytrace.c:                                tracer->mesh->weight[(eid + tshift)*cfg->srcnum + pidx] += ww * cfg->srcpattern[pidx * psize + r->posidx];
nthread:502:mmc_raytrace.c:                    if (cfg->srctype != stPattern) {
nthread:503:mmc_raytrace.c:                        if (cfg->isatomic)
nthread:504:mmc_raytrace.c:                        int psize = (int)cfg->srcparam1.w * (int)cfg->srcparam2.w; // total number of pixels in each pattern
nthread:505:mmc_raytrace.c:                        for (pidx = 0; pidx < cfg->srcnum; pidx++) {
nthread:506:mmc_raytrace.c:                            if (cfg->isatomic)
nthread:507:mmc_raytrace.c:                                    tracer->mesh->weight[(ee[j] - 1 + tshift)*cfg->srcnum + pidx] += barypout[j] * cfg->srcpattern[pidx * psize + r->posidx];
nthread:508:mmc_raytrace.c:                                    tracer->mesh->weight[(ee[j] - 1 + tshift)*cfg->srcnum + pidx] += barypout[j] * cfg->srcpattern[pidx * psize + r->posidx];
nthread:509:mmc_raytrace.c:        mus = (cfg->mcmethod == mmMCX) ? prop->mus : (prop->mua + prop->mus);
nthread:510:mmc_raytrace.c:        if ((int)((r->photontimer + r->Lmove * rc - cfg->tstart)*visit->rtstep) >= (int)((cfg->tend - cfg->tstart)*visit->rtstep)) { /*exit time window*/
nthread:511:mmc_raytrace.c:            r->Lmove = (cfg->tend - r->photontimer) / (prop->n * R_C0) - 1e-4f;
nthread:512:mmc_raytrace.c:        if (cfg->mcmethod == mmMCX) {
nthread:513:mmc_raytrace.c:        if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otJacobian) {
nthread:514:mmc_raytrace.c:            currweight *= cfg->replayweight[r->photonid];
nthread:515:mmc_raytrace.c:        } else if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otWL) {
nthread:516:mmc_raytrace.c:            currweight *= cfg->replayweight[r->photonid];
nthread:517:mmc_raytrace.c:        if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otWP) {
nthread:518:mmc_raytrace.c:            currweight *= cfg->replayweight[r->photonid];
nthread:519:mmc_raytrace.c:            if (cfg->outputtype == otWL || cfg->outputtype == otWP) {
nthread:520:mmc_raytrace.c:                tshift = MIN( ((int)(cfg->replaytime[r->photonid] * visit->rtstep)), cfg->maxgate - 1 ) * (cfg->basisorder ? tracer->mesh->nn : tracer->mesh->ne);
nthread:521:mmc_raytrace.c:                tshift = MIN( ((int)((r->photontimer - cfg->tstart) * visit->rtstep)), cfg->maxgate - 1 ) * (cfg->basisorder ? tracer->mesh->nn : tracer->mesh->ne);
nthread:522:mmc_raytrace.c:            if (cfg->debuglevel & dlAccum) MMC_FPRINTF(cfg->flog, "A %f %f %f %e %d %e\n",
nthread:523:mmc_raytrace.c:            if (cfg->mcmethod == mmMCX) {
nthread:524:mmc_raytrace.c:                if (!cfg->basisorder) {
nthread:525:mmc_raytrace.c:                    if (cfg->isatomic)
nthread:526:mmc_raytrace.c:                    if (cfg->outputtype != otEnergy && cfg->outputtype != otWP) {
nthread:527:mmc_raytrace.c:                    if (cfg->isatomic)
nthread:528:mmc_raytrace.c:        if (cfg->implicit && r->inroi) {
nthread:529:mmc_raytrace.c:        mus = (cfg->mcmethod == mmMCX) ? prop->mus : (prop->mua + prop->mus);
nthread:530:mmc_raytrace.c:        if (cfg->implicit) {
nthread:531:mmc_raytrace.c:            traceroi(r, tracer, cfg->implicit, 0);
nthread:532:mmc_raytrace.c:        if ((int)((r->photontimer + r->Lmove * rc - cfg->tstart)*visit->rtstep) > cfg->maxgate - 1) { /*exit time window*/
nthread:533:mmc_raytrace.c:            r->Lmove = (cfg->tend - r->photontimer) / (prop->n * R_C0) - 1e-4f;
nthread:534:mmc_raytrace.c:        if (cfg->mcmethod == mmMCX) {
nthread:535:mmc_raytrace.c:        if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otJacobian) {
nthread:536:mmc_raytrace.c:            currweight *= cfg->replayweight[r->photonid];
nthread:537:mmc_raytrace.c:        } else if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otWL) {
nthread:538:mmc_raytrace.c:            currweight *= cfg->replayweight[r->photonid];
nthread:539:mmc_raytrace.c:        if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otWP) {
nthread:540:mmc_raytrace.c:            currweight *= cfg->replayweight[r->photonid];
nthread:541:mmc_raytrace.c:            int framelen = (cfg->basisorder ? tracer->mesh->nn : tracer->mesh->ne);
nthread:542:mmc_raytrace.c:            if (cfg->method == rtBLBadouelGrid) {
nthread:543:mmc_raytrace.c:                framelen = cfg->crop0.z;
nthread:544:mmc_raytrace.c:            if (cfg->outputtype == otWL || cfg->outputtype == otWP) {
nthread:545:mmc_raytrace.c:                tshift = MIN( ((int)(cfg->replaytime[r->photonid] * visit->rtstep)), cfg->maxgate - 1 ) * framelen;
nthread:546:mmc_raytrace.c:                tshift = MIN( ((int)((r->photontimer - cfg->tstart) * visit->rtstep)), cfg->maxgate - 1 ) * framelen;
nthread:547:mmc_raytrace.c:            if (cfg->debuglevel & dlAccum) MMC_FPRINTF(cfg->flog, "A %f %f %f %e %d %e\n",
nthread:548:mmc_raytrace.c:                if (cfg->outputtype != otEnergy && cfg->outputtype != otWP) {
nthread:549:mmc_raytrace.c:            if (cfg->mcmethod == mmMCX) {
nthread:550:mmc_raytrace.c:                if (!cfg->basisorder) {
nthread:551:mmc_raytrace.c:                    if (cfg->method == rtBLBadouel) {
nthread:552:mmc_raytrace.c:                            if (cfg->srctype != stPattern) {
nthread:553:mmc_raytrace.c:                                if (cfg->isatomic)
nthread:554:mmc_raytrace.c:                                int psize = (int)cfg->srcparam1.w * (int)cfg->srcparam2.w; // total number of pixels in each pattern
nthread:555:mmc_raytrace.c:                                for (pidx = 0; pidx < cfg->srcnum; pidx++) {
nthread:556:mmc_raytrace.c:                                    if (cfg->isatomic)
nthread:557:mmc_raytrace.c:                                        tracer->mesh->weight[r->oldidx * cfg->srcnum + pidx] += r->oldweight * cfg->srcpattern[pidx * psize + r->posidx];
nthread:558:mmc_raytrace.c:                                        tracer->mesh->weight[r->oldidx * cfg->srcnum + pidx] += r->oldweight * cfg->srcpattern[pidx * psize + r->posidx];
nthread:559:mmc_raytrace.c:                            if (cfg->srctype != stPattern) {
nthread:560:mmc_raytrace.c:                                if (cfg->isatomic)
nthread:561:mmc_raytrace.c:                                int psize = (int)cfg->srcparam1.w * (int)cfg->srcparam2.w; // total number of pixels in each pattern
nthread:562:mmc_raytrace.c:                                for (pidx = 0; pidx < cfg->srcnum; pidx++) {
nthread:563:mmc_raytrace.c:                                    if (cfg->isatomic)
nthread:564:mmc_raytrace.c:                                        tracer->mesh->weight[newidx * cfg->srcnum + pidx] += r->oldweight * cfg->srcpattern[pidx * psize + r->posidx];
nthread:565:mmc_raytrace.c:                                        tracer->mesh->weight[newidx * cfg->srcnum + pidx] += r->oldweight * cfg->srcpattern[pidx * psize + r->posidx];
nthread:566:mmc_raytrace.c:                        int i, seg = (int)(r->Lmove / cfg->steps.x) + 1;
nthread:567:mmc_raytrace.c:                        dstep = 1.f / cfg->steps.x;
nthread:568:mmc_raytrace.c:                            unsigned int newidx = idx.z * cfg->crop0.y + idx.y * cfg->crop0.x + idx.x + tshift;
nthread:569:mmc_raytrace.c:                                if (cfg->isatomic)
nthread:570:mmc_raytrace.c:                                if (cfg->isatomic)
nthread:571:mmc_raytrace.c:                    if (cfg->srctype != stPattern) {
nthread:572:mmc_raytrace.c:                        if (cfg->isatomic)
nthread:573:mmc_raytrace.c:                        int psize = (int)cfg->srcparam1.w * (int)cfg->srcparam2.w; // total number of pixels in each pattern
nthread:574:mmc_raytrace.c:                        for (pidx = 0; pidx < cfg->srcnum; pidx++) {
nthread:575:mmc_raytrace.c:                            if (cfg->isatomic)
nthread:576:mmc_raytrace.c:                                    tracer->mesh->weight[(ee[out[faceidx][i]] - 1 + tshift)*cfg->srcnum + pidx] += ww * cfg->srcpattern[pidx * psize + r->posidx];
nthread:577:mmc_raytrace.c:                                    tracer->mesh->weight[(ee[out[faceidx][i]] - 1 + tshift)*cfg->srcnum + pidx] += ww * cfg->srcpattern[pidx * psize + r->posidx];
nthread:578:mmc_raytrace.c:    ray r = {cfg->srcpos, {cfg->srcdir.x, cfg->srcdir.y, cfg->srcdir.z}, {MMC_UNDEFINED, 0.f, 0.f}, cfg->bary0, cfg->e0, cfg->dim.y - 1, 0, 0, 1.f, 0.f, 0.f, 0.f, 0.f, 0., 0, NULL, NULL, cfg->srcdir.w, 0, 0xFFFFFFFF, 0.0, NULL, 0, 0, 0, 0};
nthread:579:mmc_raytrace.c:    if (cfg->issavedet && cfg->issaveseed) {
nthread:580:mmc_raytrace.c:    if (cfg->method >= rtPlucker && cfg->method <= rtBLBadouelGrid) {
nthread:581:mmc_raytrace.c:        tracercore = engines[(int)(cfg->method)];
nthread:582:mmc_raytrace.c:    if (cfg->srctype != stPattern) {
nthread:583:mmc_raytrace.c:        if (cfg->seed == SEED_FROM_FILE && (cfg->outputtype == otWL || cfg->outputtype == otWP)) {
nthread:584:mmc_raytrace.c:            kahany = cfg->replayweight[r.photonid] - visit->kahanc0[0];    /* when replay mode, accumulate detected photon weight */
nthread:585:mmc_raytrace.c:        int psize = (int)cfg->srcparam1.w * (int)cfg->srcparam2.w;
nthread:586:mmc_raytrace.c:            for (pidx = 0; pidx < cfg->srcnum; pidx++) {
nthread:587:mmc_raytrace.c:                if (cfg->seed == SEED_FROM_FILE && (cfg->outputtype == otWL || cfg->outputtype == otWP)) {
nthread:588:mmc_raytrace.c:                    kahany = cfg->replayweight[r.photonid] - visit->kahanc0[pidx];    /* when replay mode, accumulate detected photon weight */
nthread:589:mmc_raytrace.c:                    kahany = r.weight * cfg->srcpattern[pidx * psize + r.posidx] - visit->kahanc0[pidx];
nthread:590:mmc_raytrace.c:    if (cfg->implicit) {
nthread:591:mmc_raytrace.c:        updateroi(cfg->implicit, &r, tracer->mesh);
nthread:592:mmc_raytrace.c:        traceroi(&r, tracer, cfg->implicit, 1);
nthread:593:mmc_raytrace.c:        if (cfg->implicit) {
nthread:594:mmc_raytrace.c:            updateroi(cfg->implicit, &r, tracer->mesh);
nthread:595:mmc_raytrace.c:        if (cfg->issavedet && r.Lmove > 0.f && mesh->type[r.eid - 1] > 0 && r.faceid >= 0) {
nthread:596:mmc_raytrace.c:        if (cfg->implicit && cfg->isreflect && r.roitype && r.roiidx >= 0 && (mesh->med[cfg->his.maxmedia].n != mesh->med[mesh->type[r.eid - 1]].n)) {
nthread:597:mmc_raytrace.c:        } else if (cfg->implicit && r.roitype) {
nthread:598:mmc_raytrace.c:            if (cfg->implicit) {
nthread:599:mmc_raytrace.c:                if (cfg->isreflect && (r.eid <= 0 || mesh->med[mesh->type[r.eid - 1]].n != mesh->med[mesh->type[oldeid - 1]].n )) {
nthread:600:mmc_raytrace.c:                    if (! (!r.inroi && r.eid <= 0 && ((mesh->med[mesh->type[oldeid - 1]].n == cfg->nout && cfg->isreflect != (int)bcMirror) || cfg->isreflect == (int)bcAbsorbExterior) ) ) {
nthread:601:mmc_raytrace.c:                if (cfg->isreflect && (r.eid <= 0 || mesh->med[mesh->type[r.eid - 1]].n != mesh->med[mesh->type[oldeid - 1]].n )) {
nthread:602:mmc_raytrace.c:                    if (! (r.eid <= 0 && ((mesh->med[mesh->type[oldeid - 1]].n == cfg->nout && cfg->isreflect != (int)bcMirror) || cfg->isreflect == (int)bcAbsorbExterior) ) ) {
nthread:603:mmc_raytrace.c:                if (cfg->debuglevel & dlExit)
nthread:604:mmc_raytrace.c:                    MMC_FPRINTF(cfg->flog, "e %f %f %f %f %f %f %f %d\n", r.p0.x, r.p0.y, r.p0.z,
nthread:605:mmc_raytrace.c:                if (!cfg->voidtime) {
nthread:606:mmc_raytrace.c:                if (cfg->debuglevel & dlExit)
nthread:607:mmc_raytrace.c:                    MMC_FPRINTF(cfg->flog, "x %f %f %f %f %f %f %f %d\n", r.p0.x, r.p0.y, r.p0.z,
nthread:608:mmc_raytrace.c:                if (!cfg->isextdet) {
nthread:609:mmc_raytrace.c:            //          if(r.eid!=ID_UNDEFINED && mesh->med[mesh->type[oldeid-1]].n == cfg->nout ) break;
nthread:610:mmc_raytrace.c:            if (r.pout.x != MMC_UNDEFINED && (cfg->debuglevel & dlMove)) {
nthread:611:mmc_raytrace.c:                MMC_FPRINTF(cfg->flog, "P %f %f %f %d %zu %e\n", r.pout.x, r.pout.y, r.pout.z, r.eid, id, r.slen);
nthread:612:mmc_raytrace.c:            if (cfg->implicit) {
nthread:613:mmc_raytrace.c:                updateroi(cfg->implicit, &r, tracer->mesh);
nthread:614:mmc_raytrace.c:            if (cfg->issavedet && r.Lmove > 0.f && mesh->type[r.eid - 1] > 0) {
nthread:615:mmc_raytrace.c:                if (cfg->issavedet && r.Lmove > 0.f && mesh->type[r.eid - 1] > 0) {
nthread:616:mmc_raytrace.c:            if (r.eid != ID_UNDEFINED && (cfg->debuglevel & dlMove)) {
nthread:617:mmc_raytrace.c:                MMC_FPRINTF(cfg->flog, "B %f %f %f %d %zu %e\n", r.p0.x, r.p0.y, r.p0.z, r.eid, id, r.slen);
nthread:618:mmc_raytrace.c:                if (cfg->debuglevel & dlExit)
nthread:619:mmc_raytrace.c:                    MMC_FPRINTF(cfg->flog, "E %f %f %f %f %f %f %f %d\n", r.p0.x, r.p0.y, r.p0.z,
nthread:620:mmc_raytrace.c:                if (cfg->issavedet && cfg->issaveexit) {                                   /*when issaveexit is set to 1*/
nthread:621:mmc_raytrace.c:                if (cfg->issaveref && r.eid < 0 && mesh->dref) {
nthread:622:mmc_raytrace.c:                    int tshift = MIN( ((int)((r.photontimer - cfg->tstart) * visit->rtstep)), cfg->maxgate - 1 ) * mesh->nf;
nthread:623:mmc_raytrace.c:            } else if (r.faceid == -2 && (cfg->debuglevel & dlMove)) {
nthread:624:mmc_raytrace.c:                MMC_FPRINTF(cfg->flog, "T %f %f %f %d %zu %e\n", r.p0.x, r.p0.y, r.p0.z, r.eid, id, r.slen);
nthread:625:mmc_raytrace.c:            } else if (r.eid && r.faceid != -2  && cfg->debuglevel & dlEdge) {
nthread:626:mmc_raytrace.c:                MMC_FPRINTF(cfg->flog, "X %f %f %f %d %zu %e\n", r.p0.x, r.p0.y, r.p0.z, r.eid, id, r.slen);
nthread:627:mmc_raytrace.c:            if (cfg->issavedet && r.eid <= 0) {
nthread:628:mmc_raytrace.c:                if (cfg->detnum == 0 && cfg->isextdet && mesh->type[oldeid - 1] == mesh->prop + 1) {
nthread:629:mmc_raytrace.c:                    for (i = 0; i < cfg->detnum; i++) {
nthread:630:mmc_raytrace.c:                        if ((cfg->detpos[i].x - r.p0.x) * (cfg->detpos[i].x - r.p0.x) +
nthread:631:mmc_raytrace.c:                                (cfg->detpos[i].y - r.p0.y) * (cfg->detpos[i].y - r.p0.y) +
nthread:632:mmc_raytrace.c:                                (cfg->detpos[i].z - r.p0.z) * (cfg->detpos[i].z - r.p0.z) < cfg->detpos[i].w * cfg->detpos[i].w) {
nthread:633:mmc_raytrace.c:        if (cfg->debuglevel & dlMove) {
nthread:634:mmc_raytrace.c:            MMC_FPRINTF(cfg->flog, "M %f %f %f %d %zu %e\n", r.p0.x, r.p0.y, r.p0.z, r.eid, id, r.slen);
nthread:635:mmc_raytrace.c:        if (cfg->minenergy > 0.f && r.weight < cfg->minenergy && (cfg->tend - cfg->tstart)*visit->rtstep <= 1.f) { /*Russian Roulette*/
nthread:636:mmc_raytrace.c:            if (rand_do_roulette(ran)*cfg->roulettesize <= 1.f) {
nthread:637:mmc_raytrace.c:                r.weight *= cfg->roulettesize;
nthread:638:mmc_raytrace.c:                if (cfg->debuglevel & dlWeight) {
nthread:639:mmc_raytrace.c:                    MMC_FPRINTF(cfg->flog, "Russian Roulette bumps r.weight to %f\n", r.weight);
nthread:640:mmc_raytrace.c:        if (cfg->implicit && cfg->isreflect && r.roitype && r.roiidx >= 0 && (mesh->med[cfg->his.maxmedia].n != mesh->med[mesh->type[r.eid - 1]].n)) {
nthread:641:mmc_raytrace.c:        } else if (cfg->implicit && r.roitype) {
nthread:642:mmc_raytrace.c:        if (cfg->mcmethod != mmMCX) {
nthread:643:mmc_raytrace.c:        if (cfg->ismomentum && mesh->type[r.eid - 1] > 0) {              /*when ismomentum is set to 1*/
nthread:644:mmc_raytrace.c:    if (cfg->issavedet && exitdet > 0) {
nthread:645:mmc_raytrace.c:            if (cfg->issaveseed) {
nthread:646:mmc_raytrace.c:        if (cfg->issaveseed) {
nthread:647:mmc_raytrace.c:    if (cfg->srctype != stPattern) {
nthread:648:mmc_raytrace.c:        int psize = (int)cfg->srcparam1.w * (int)cfg->srcparam2.w;
nthread:649:mmc_raytrace.c:            for (pidx = 0; pidx < cfg->srcnum; pidx++) {
nthread:650:mmc_raytrace.c:                kahany = r.Eabsorb * cfg->srcpattern[pidx * psize + r.posidx] - visit->kahanc1[pidx];
nthread:651:mmc_raytrace.c:        n2 = tracer->mesh->med[cfg->his.maxmedia].n;
nthread:652:mmc_raytrace.c:        n1 = tracer->mesh->med[cfg->his.maxmedia].n;
nthread:653:mmc_raytrace.c:            //if(cfg->debuglevel&dlReflect) MMC_FPRINTF(cfg->flog,"R %f %f %f %d %d %f\n",c0->x,c0->y,c0->z,*eid,*oldeid,Rtotal);
nthread:654:mmc_raytrace.c:        } else if (cfg->isspecular == 2 && *eid == 0) {
nthread:655:mmc_raytrace.c:    if (cfg->method == rtPlucker) { //Plucker ray-tracing
nthread:656:mmc_raytrace.c:    } else if (cfg->method < rtBLBadouel) {
nthread:657:mmc_raytrace.c:    } else if (cfg->method == rtBLBadouel || cfg->method == rtBLBadouelGrid) {
nthread:658:mmc_raytrace.c:    if (cfg->implicit && inroi != 0) {
nthread:659:mmc_raytrace.c:        n1 = tracer->mesh->med[cfg->his.maxmedia].n;
nthread:660:mmc_raytrace.c:        n1 = (*oldeid != *eid) ? tracer->mesh->med[tracer->mesh->type[*oldeid - 1]].n : cfg->nout;
nthread:661:mmc_raytrace.c:        n2 = (*eid > 0) ? tracer->mesh->med[tracer->mesh->type[*eid - 1]].n : cfg->nout;
nthread:662:mmc_raytrace.c:    if (tmp2 > 0.f && !(*eid <= 0 && cfg->isreflect == bcMirror)) { /*if no total internal reflection*/
nthread:663:mmc_raytrace.c:            //if(cfg->debuglevel&dlReflect) MMC_FPRINTF(cfg->flog,"R %f %f %f %d %d %f\n",c0->x,c0->y,c0->z,*eid,*oldeid,Rtotal);
nthread:664:mmc_raytrace.c:        } else if (cfg->isspecular == 2 && *eid == 0) {
nthread:665:mmc_raytrace.c:            //if(cfg->debuglevel&dlReflect) MMC_FPRINTF(cfg->flog,"Z %f %f %f %d %d %f\n",c0->x,c0->y,c0->z,*eid,*oldeid,1.f-Rtotal);
nthread:666:mmc_raytrace.c:        //if(cfg->debuglevel&dlReflect) MMC_FPRINTF(cfg->flog,"V %f %f %f %d %d %f\n",c0->x,c0->y,c0->z,*eid,*oldeid,1.f);
nthread:667:mmc_raytrace.c:    if (cfg->srctype == stPencil) { // pencil beam, use the old workflow, except when eid is not given
nthread:668:mmc_raytrace.c:    } else if (cfg->srctype == stPlanar || cfg->srctype == stPattern || cfg->srctype == stFourier) {
nthread:669:mmc_raytrace.c:        r->p0.x = cfg->srcpos.x + rx * cfg->srcparam1.x + ry * cfg->srcparam2.x;
nthread:670:mmc_raytrace.c:        r->p0.y = cfg->srcpos.y + rx * cfg->srcparam1.y + ry * cfg->srcparam2.y;
nthread:671:mmc_raytrace.c:        r->p0.z = cfg->srcpos.z + rx * cfg->srcparam1.z + ry * cfg->srcparam2.z;
nthread:672:mmc_raytrace.c:        if (cfg->srctype == stPattern) {
nthread:673:mmc_raytrace.c:            int xsize = (int)cfg->srcparam1.w;
nthread:674:mmc_raytrace.c:            int ysize = (int)cfg->srcparam2.w;
nthread:675:mmc_raytrace.c:            if (cfg->seed == SEED_FROM_FILE && (cfg->outputtype == otWL || cfg->outputtype == otWP)) { // replay mode currently doesn't support multiple source patterns
nthread:676:mmc_raytrace.c:                r->weight = cfg->srcpattern[MIN( (int)(ry * cfg->srcparam2.w), (int)cfg->srcparam2.w - 1 ) * (int)(cfg->srcparam1.w) + MIN( (int)(rx * cfg->srcparam1.w), (int)cfg->srcparam1.w - 1 )];
nthread:677:mmc_raytrace.c:                cfg->replayweight[r->photonid] *= r->weight;
nthread:678:mmc_raytrace.c:        } else if (cfg->srctype == stFourier) {
nthread:679:mmc_raytrace.c:            r->weight = (cosf((floorf(cfg->srcparam1.w) * rx + floorf(cfg->srcparam2.w) * ry + cfg->srcparam1.w - floorf(cfg->srcparam1.w)) * TWO_PI) * (1.f - cfg->srcparam2.w + floorf(cfg->srcparam2.w)) + 1.f) * 0.5f;
nthread:680:mmc_raytrace.c:        origin.x += (cfg->srcparam1.x + cfg->srcparam2.x) * 0.5f;
nthread:681:mmc_raytrace.c:        origin.y += (cfg->srcparam1.y + cfg->srcparam2.y) * 0.5f;
nthread:682:mmc_raytrace.c:        origin.z += (cfg->srcparam1.z + cfg->srcparam2.z) * 0.5f;
nthread:683:mmc_raytrace.c:    } else if (cfg->srctype == stFourierX || cfg->srctype == stFourier2D) {
nthread:684:mmc_raytrace.c:        float4 v2 = cfg->srcparam1;
nthread:685:mmc_raytrace.c:        v2.w *= 1.f / (sqrtf(cfg->srcparam1.x * cfg->srcparam1.x + cfg->srcparam1.y * cfg->srcparam1.y + cfg->srcparam1.z * cfg->srcparam1.z));
nthread:686:mmc_raytrace.c:        v2.x = v2.w * (cfg->srcdir.y * cfg->srcparam1.z - cfg->srcdir.z * cfg->srcparam1.y);
nthread:687:mmc_raytrace.c:        v2.y = v2.w * (cfg->srcdir.z * cfg->srcparam1.x - cfg->srcdir.x * cfg->srcparam1.z);
nthread:688:mmc_raytrace.c:        v2.z = v2.w * (cfg->srcdir.x * cfg->srcparam1.y - cfg->srcdir.y * cfg->srcparam1.x);
nthread:689:mmc_raytrace.c:        r->p0.x = cfg->srcpos.x + rx * cfg->srcparam1.x + ry * v2.x;
nthread:690:mmc_raytrace.c:        r->p0.y = cfg->srcpos.y + rx * cfg->srcparam1.y + ry * v2.y;
nthread:691:mmc_raytrace.c:        r->p0.z = cfg->srcpos.z + rx * cfg->srcparam1.z + ry * v2.z;
nthread:692:mmc_raytrace.c:        if (cfg->srctype == stFourier2D) {
nthread:693:mmc_raytrace.c:            r->weight = (sinf((cfg->srcparam2.x * rx + cfg->srcparam2.z) * TWO_PI) * sinf((cfg->srcparam2.y * ry + cfg->srcparam2.w) * TWO_PI) + 1.f) * 0.5f;    //between 0 and 1
nthread:694:mmc_raytrace.c:            r->weight = (cosf((cfg->srcparam2.x * rx + cfg->srcparam2.y * ry + cfg->srcparam2.z) * TWO_PI) * (1.f - cfg->srcparam2.w) + 1.f) * 0.5f;    //between 0 and 1
nthread:695:mmc_raytrace.c:        origin.x += (cfg->srcparam1.x + v2.x) * 0.5f;
nthread:696:mmc_raytrace.c:        origin.y += (cfg->srcparam1.y + v2.y) * 0.5f;
nthread:697:mmc_raytrace.c:        origin.z += (cfg->srcparam1.z + v2.z) * 0.5f;
nthread:698:mmc_raytrace.c:    } else if (cfg->srctype == stDisk || cfg->srctype == stGaussian) { // uniform disk and Gaussian beam
nthread:699:mmc_raytrace.c:        if (cfg->srctype == stDisk) {
nthread:700:mmc_raytrace.c:            r0 = sqrtf(rand_uniform01(ran)) * cfg->srcparam1.x;
nthread:701:mmc_raytrace.c:        } else if (fabs(r->focus) < 1e-5f || fabs(cfg->srcparam1.y) < 1e-5f) {
nthread:702:mmc_raytrace.c:            r0 = sqrtf(-log(rand_uniform01(ran))) * cfg->srcparam1.x;
nthread:703:mmc_raytrace.c:            float z0 = cfg->srcparam1.x * cfg->srcparam1.x * M_PI / cfg->srcparam1.y; //Rayleigh range
nthread:704:mmc_raytrace.c:            r0 = sqrtf(-log(rand_uniform01(ran)) * (1.f + (r->focus * r->focus / (z0 * z0)))) * cfg->srcparam1.x;
nthread:705:mmc_raytrace.c:        if (cfg->srcdir.z > -1.f + EPS && cfg->srcdir.z < 1.f - EPS) {
nthread:706:mmc_raytrace.c:            float tmp0 = 1.f - cfg->srcdir.z * cfg->srcdir.z;
nthread:707:mmc_raytrace.c:            r->p0.x = cfg->srcpos.x + tmp1 * (cfg->srcdir.x * cfg->srcdir.z * cphi - cfg->srcdir.y * sphi);
nthread:708:mmc_raytrace.c:            r->p0.y = cfg->srcpos.y + tmp1 * (cfg->srcdir.y * cfg->srcdir.z * cphi + cfg->srcdir.x * sphi);
nthread:709:mmc_raytrace.c:            r->p0.z = cfg->srcpos.z - tmp1 * tmp0 * cphi;
nthread:710:mmc_raytrace.c:    } else if (cfg->srctype == stCone || cfg->srctype == stIsotropic || cfg->srctype == stArcSin) {
nthread:711:mmc_raytrace.c:        if (cfg->srctype == stCone) { // a solid-angle section of a uniform sphere
nthread:712:mmc_raytrace.c:                ang = (cfg->srcparam1.y > 0) ? TWO_PI * rand_uniform01(ran) : acosf(2.f * rand_uniform01(ran) - 1.f); //sine distribution
nthread:713:mmc_raytrace.c:            } while (ang > cfg->srcparam1.x);
nthread:714:mmc_raytrace.c:            if (cfg->srctype == stIsotropic) { // uniform sphere
nthread:715:mmc_raytrace.c:    } else if (cfg->srctype == stZGaussian) {
nthread:716:mmc_raytrace.c:        ang = sqrtf(-2.f * log(rand_uniform01(ran))) * (1.f - 2.f * rand_uniform01(ran0)) * cfg->srcparam1.x;
nthread:717:mmc_raytrace.c:    } else if (cfg->srctype == stLine || cfg->srctype == stSlit) {
nthread:718:mmc_raytrace.c:        r->p0.x += t * cfg->srcparam1.x;
nthread:719:mmc_raytrace.c:        r->p0.y += t * cfg->srcparam1.y;
nthread:720:mmc_raytrace.c:        r->p0.z += t * cfg->srcparam1.z;
nthread:721:mmc_raytrace.c:        if (cfg->srctype == stLine) {
nthread:722:mmc_raytrace.c:        origin.x += (cfg->srcparam1.x) * 0.5f;
nthread:723:mmc_raytrace.c:        origin.y += (cfg->srcparam1.y) * 0.5f;
nthread:724:mmc_raytrace.c:        origin.z += (cfg->srcparam1.z) * 0.5f;
nthread:725:mmc_raytrace.c:        canfocus = (cfg->srctype == stSlit);
nthread:726:mmc_raytrace.c:            MMC_FPRINTF(cfg->flog, "all tetrahedra (%d) labeled with -1 do not enclose the source!\n", mesh->srcelemlen);
nthread:727:mmc_raytrace.c:                MMC_FPRINTF(cfg->flog, "elem %d %d [%f %f %f] \n", mesh->srcelem[0], elems[0], mesh->node[elems[0] - 1].x, mesh->node[elems[0] - 1].y, mesh->node[elems[0] - 1].z);
nthread:728:mmc_raytrace.c:                MMC_FPRINTF(cfg->flog, "elem %d %d [%f %f %f] \n", mesh->srcelem[0], elems[1], mesh->node[elems[1] - 1].x, mesh->node[elems[1] - 1].y, mesh->node[elems[1] - 1].z);
nthread:729:mmc_raytrace.c:                MMC_FPRINTF(cfg->flog, "elem %d %d [%f %f %f] \n", mesh->srcelem[0], elems[2], mesh->node[elems[2] - 1].x, mesh->node[elems[2] - 1].y, mesh->node[elems[2] - 1].z);
nthread:730:mmc_raytrace.c:                MMC_FPRINTF(cfg->flog, "elem %d %d [%f %f %f] \n", mesh->srcelem[0], elems[3], mesh->node[elems[3] - 1].x, mesh->node[elems[3] - 1].y, mesh->node[elems[3] - 1].z);
nthread:731:mmc_raytrace.c:                MMC_FPRINTF(cfg->flog, "source position [%e %e %e] \n", r->p0.x, r->p0.y, r->p0.z);
nthread:732:mmc_raytrace.c:                MMC_FPRINTF(cfg->flog, "bary centric volume [%e %e %e %e] \n", bary[0], bary[1], bary[2], bary[3]);
nthread:733:mmc_raytrace.c:    int i, tshift, datalen = (cfg->method == rtBLBadouelGrid) ? cfg->crop0.z : ( (cfg->basisorder) ? mesh->nn : mesh->ne);;
nthread:734:mmc_raytrace.c:    tshift = MIN( ((int)((r->photontimer - cfg->tstart) * visit->rtstep)), cfg->maxgate - 1 ) * datalen;
nthread:735:mmc_raytrace.c:    if (cfg->method == rtBLBadouelGrid) {
nthread:736:mmc_raytrace.c:        if (!cfg->basisorder) {
nthread:737:mmc_raytrace.c:            if (cfg->isatomic)
nthread:738:mmc_raytrace.c:            if (cfg->isatomic)
nthread:739:mmc_raytrace.c:    visit->launchweight = (double*)calloc(cfg->srcnum, sizeof(double));
nthread:740:mmc_raytrace.c:    visit->absorbweight = (double*)calloc(cfg->srcnum, sizeof(double));
nthread:741:mmc_raytrace.c:    visit->kahanc0 = (double*)calloc(cfg->srcnum, sizeof(double));
nthread:742:mmc_raytrace.c:    visit->kahanc1 = (double*)calloc(cfg->srcnum, sizeof(double));
nthread:743:mmc_utils.c:    cfg->medianum = 0;
nthread:744:mmc_utils.c:    cfg->srcnum = 1;
nthread:745:mmc_utils.c:    cfg->detnum = 0;
nthread:746:mmc_utils.c:    cfg->e0 = 0;
nthread:747:mmc_utils.c:    cfg->dim.x = 0;
nthread:748:mmc_utils.c:    cfg->dim.y = 0;
nthread:749:mmc_utils.c:    cfg->dim.z = 0;
nthread:750:mmc_utils.c:    cfg->steps.x = 1.f;
nthread:751:mmc_utils.c:    cfg->steps.y = 1.f;
nthread:752:mmc_utils.c:    cfg->steps.z = 1.f;
nthread:753:mmc_utils.c:    cfg->nblocksize = 64;
nthread:754:mmc_utils.c:    cfg->nphoton = 0;
nthread:755:mmc_utils.c:    cfg->nthread = 1024 * 8;
nthread:756:mmc_utils.c:    cfg->seed = 0x623F9A9E;
nthread:757:mmc_utils.c:    cfg->isrowmajor = 0;    /* not needed */
nthread:758:mmc_utils.c:    cfg->maxgate = 1;
nthread:759:mmc_utils.c:    cfg->implicit = 0;
nthread:760:mmc_utils.c:    cfg->isreflect = 1;
nthread:761:mmc_utils.c:    cfg->isref3 = 1;
nthread:762:mmc_utils.c:    cfg->isnormalized = 1;
nthread:763:mmc_utils.c:    cfg->issavedet = 0;
nthread:764:mmc_utils.c:    cfg->respin = 1;
nthread:765:mmc_utils.c:    cfg->issave2pt = 1;
nthread:766:mmc_utils.c:    cfg->isgpuinfo = 0;
nthread:767:mmc_utils.c:    cfg->basisorder = 1;
nthread:768:mmc_utils.c:    cfg->compute = cbOpenCL;
nthread:769:mmc_utils.c:    cfg->isdumpjson = 0;
nthread:770:mmc_utils.c:    cfg->zipid = zmZlib;
nthread:771:mmc_utils.c:    memset(cfg->jsonfile, 0, MAX_PATH_LENGTH);
nthread:772:mmc_utils.c:    cfg->shapedata = NULL;
nthread:773:mmc_utils.c:    cfg->method = rtBLBadouelGrid;
nthread:774:mmc_utils.c:    cfg->method = rtPlucker;
nthread:775:mmc_utils.c:    cfg->method = rtHavel;
nthread:776:mmc_utils.c:    cfg->prop = NULL;
nthread:777:mmc_utils.c:    cfg->detpos = NULL;
nthread:778:mmc_utils.c:    cfg->vol = NULL;
nthread:779:mmc_utils.c:    cfg->session[0] = '\0';
nthread:780:mmc_utils.c:    cfg->meshtag[0] = '\0';
nthread:781:mmc_utils.c:    cfg->minenergy = 1e-6f;
nthread:782:mmc_utils.c:    cfg->flog = stdout;
nthread:783:mmc_utils.c:    cfg->sradius = 0.f;
nthread:784:mmc_utils.c:    cfg->rootpath[0] = '\0';
nthread:785:mmc_utils.c:    cfg->seedfile[0] = '\0';
nthread:786:mmc_utils.c:    cfg->debuglevel = 0;
nthread:787:mmc_utils.c:    cfg->minstep = 1.f;
nthread:788:mmc_utils.c:    cfg->roulettesize = 10.f;
nthread:789:mmc_utils.c:    cfg->nout = 1.f;
nthread:790:mmc_utils.c:    cfg->unitinmm = 1.f;
nthread:791:mmc_utils.c:    cfg->srctype = 0;
nthread:792:mmc_utils.c:    cfg->isspecular = 0;
nthread:793:mmc_utils.c:    cfg->issaveref = 0;
nthread:794:mmc_utils.c:    cfg->outputtype = otFlux;
nthread:795:mmc_utils.c:    cfg->outputformat = ofASCII;
nthread:796:mmc_utils.c:    cfg->ismomentum = 0;
nthread:797:mmc_utils.c:    cfg->issaveseed = 0;
nthread:798:mmc_utils.c:    cfg->issaveexit = 0;
nthread:799:mmc_utils.c:    cfg->photonseed = NULL;
nthread:800:mmc_utils.c:    cfg->replaydet = 0;
nthread:801:mmc_utils.c:    cfg->replayweight = NULL;
nthread:802:mmc_utils.c:    cfg->replaytime = NULL;
nthread:803:mmc_utils.c:    cfg->isextdet = 0;
nthread:804:mmc_utils.c:    cfg->srcdir.w = 0.f;
nthread:805:mmc_utils.c:    cfg->isatomic = 1;
nthread:806:mmc_utils.c:    cfg->debugphoton = -1;
nthread:807:mmc_utils.c:    cfg->savedetflag = 0x47;
nthread:808:mmc_utils.c:    cfg->mediabyte = 1;
nthread:809:mmc_utils.c:    cfg->tstart = 0.f;
nthread:810:mmc_utils.c:    cfg->tstep = 0.f;
nthread:811:mmc_utils.c:    cfg->tend = 0.f;
nthread:812:mmc_utils.c:    cfg->mcmethod = mmMCX;
nthread:813:mmc_utils.c:    memset(&(cfg->his), 0, sizeof(history));
nthread:814:mmc_utils.c:    cfg->his.version = 1;
nthread:815:mmc_utils.c:    cfg->his.unitinmm = 1.f;
nthread:816:mmc_utils.c:    cfg->his.normalizer = 1.f;
nthread:817:mmc_utils.c:    cfg->his.respin = 1;
nthread:818:mmc_utils.c:    cfg->his.srcnum = cfg->srcnum;
nthread:819:mmc_utils.c:    cfg->his.savedetflag = 0;
nthread:820:mmc_utils.c:    memcpy(cfg->his.magic, "MCXH", 4);
nthread:821:mmc_utils.c:    memset(&(cfg->srcpos), 0, sizeof(float3));
nthread:822:mmc_utils.c:    memset(&(cfg->srcdir), 0, sizeof(float3));
nthread:823:mmc_utils.c:    memset(&(cfg->bary0), 0, sizeof(float4));
nthread:824:mmc_utils.c:    memset(&(cfg->srcparam1), 0, sizeof(float4));
nthread:825:mmc_utils.c:    memset(&(cfg->srcparam2), 0, sizeof(float4));
nthread:826:mmc_utils.c:    cfg->srcpattern = NULL;
nthread:827:mmc_utils.c:    cfg->voidtime = 1;
nthread:828:mmc_utils.c:    memset(cfg->checkpt, 0, sizeof(unsigned int)*MAX_CHECKPOINT);
nthread:829:mmc_utils.c:    memset(&(cfg->detparam1), 0, sizeof(float4));
nthread:830:mmc_utils.c:    memset(&(cfg->detparam2), 0, sizeof(float4));
nthread:831:mmc_utils.c:    cfg->detpattern = NULL;
nthread:832:mmc_utils.c:    cfg->optlevel = 3;
nthread:833:mmc_utils.c:    memset(cfg->deviceid, 0, MAX_DEVICE);
nthread:834:mmc_utils.c:    memset(cfg->workload, 0, MAX_DEVICE * sizeof(float));
nthread:835:mmc_utils.c:    cfg->deviceid[0] = '1'; /*use the first GPU device by default*/
nthread:836:mmc_utils.c:    memset(cfg->compileropt, 0, MAX_PATH_LENGTH);
nthread:837:mmc_utils.c:    memset(cfg->kernelfile, 0, MAX_SESSION_LENGTH);
nthread:838:mmc_utils.c:    cfg->maxdetphoton = 1000000;
nthread:839:mmc_utils.c:    cfg->exportfield = NULL;
nthread:840:mmc_utils.c:    cfg->exportdetected = NULL;
nthread:841:mmc_utils.c:    cfg->exportseed = NULL;
nthread:842:mmc_utils.c:    cfg->detectedcount = 0;
nthread:843:mmc_utils.c:    cfg->energytot = 0.f;
nthread:844:mmc_utils.c:    cfg->energyabs = 0.f;
nthread:845:mmc_utils.c:    cfg->energyesc = 0.f;
nthread:846:mmc_utils.c:    cfg->runtime = 0;
nthread:847:mmc_utils.c:    cfg->autopilot = 1;
nthread:848:mmc_utils.c:    cfg->nbuffer = 0;
nthread:849:mmc_utils.c:    cfg->gpuid = 0;
nthread:850:mmc_utils.c:    cfg->clsource = (char*)mmc_core_cl;
nthread:851:mmc_utils.c:    cfg->clsource = NULL;
nthread:852:mmc_utils.c:    cfg->parentid = mpMATLAB;
nthread:853:mmc_utils.c:    cfg->parentid = mpStandalone;
nthread:854:mmc_utils.c:    if (cfg->medianum) {
nthread:855:mmc_utils.c:        free(cfg->prop);
nthread:856:mmc_utils.c:    if (cfg->detnum) {
nthread:857:mmc_utils.c:        free(cfg->detpos);
nthread:858:mmc_utils.c:    if (cfg->vol) {
nthread:859:mmc_utils.c:        free(cfg->vol);
nthread:860:mmc_utils.c:    if (cfg->srcpattern) {
nthread:861:mmc_utils.c:        free(cfg->srcpattern);
nthread:862:mmc_utils.c:    if (cfg->detpattern) {
nthread:863:mmc_utils.c:        free(cfg->detpattern);
nthread:864:mmc_utils.c:    if (cfg->photonseed) {
nthread:865:mmc_utils.c:        free(cfg->photonseed);
nthread:866:mmc_utils.c:    if (cfg->replayweight) {
nthread:867:mmc_utils.c:        free(cfg->replayweight);
nthread:868:mmc_utils.c:    if (cfg->replaytime) {
nthread:869:mmc_utils.c:        free(cfg->replaytime);
nthread:870:mmc_utils.c:    if (cfg->exportseed) {
nthread:871:mmc_utils.c:        free(cfg->exportseed);
nthread:872:mmc_utils.c:    if (cfg->exportdetected) {
nthread:873:mmc_utils.c:        free(cfg->exportdetected);
nthread:874:mmc_utils.c:    if (cfg->flog && cfg->flog != stdout && cfg->flog != stderr) {
nthread:875:mmc_utils.c:        fclose(cfg->flog);
nthread:876:mmc_utils.c:    if (cfg->shapedata) {
nthread:877:mmc_utils.c:        free(cfg->shapedata);
nthread:878:mmc_utils.c:    if (cfg->clsource && cfg->clsource != (char*)mmc_core_cl) {
nthread:879:mmc_utils.c:        free(cfg->clsource);
nthread:880:mmc_utils.c:    hdr.dim[1] = cfg->dim.x;
nthread:881:mmc_utils.c:    hdr.dim[2] = cfg->dim.y;
nthread:882:mmc_utils.c:    hdr.dim[3] = cfg->dim.z;
nthread:883:mmc_utils.c:    hdr.dim[4] = len / (cfg->dim.x * cfg->dim.y * cfg->dim.z);
nthread:884:mmc_utils.c:    hdr.pixdim[1] = cfg->steps.x;
nthread:885:mmc_utils.c:    hdr.pixdim[2] = cfg->steps.y;
nthread:886:mmc_utils.c:    hdr.pixdim[3] = cfg->steps.z;
nthread:887:mmc_utils.c:        hdr.pixdim[4] = cfg->tstep * 1e6f;
nthread:888:mmc_utils.c:        hdr.dim[2] = cfg->dim.x;
nthread:889:mmc_utils.c:        hdr.dim[3] = cfg->dim.y;
nthread:890:mmc_utils.c:        hdr.dim[4] = cfg->dim.z;
nthread:891:mmc_utils.c:        hdr.pixdim[4] = cfg->unitinmm;
nthread:892:mmc_utils.c:    UBJ_WRITE_KEY(root, "LastSliceID", uint32, cfg->maxgate);
nthread:893:mmc_utils.c:    if (cfg->outputtype >= 0) {
nthread:894:mmc_utils.c:        UBJ_WRITE_KEY(root, "Description", string, typestr[(int)cfg->outputtype]);
nthread:895:mmc_utils.c:    UBJ_WRITE_KEY(root, "Name", string, cfg->session);
nthread:896:mmc_utils.c:    if (mcx_jdataencode(vol, ndim, dims, (isfloat ? "single" : "uint32"), 4, cfg->zipid, root, 1, cfg)) {
nthread:897:mmc_utils.c:    cJSON_AddNumberToObject(hdr, "LastSliceID", cfg->maxgate);
nthread:898:mmc_utils.c:    if (cfg->outputtype >= 0) {
nthread:899:mmc_utils.c:        cJSON_AddStringToObject(hdr, "Description", typestr[(int)cfg->outputtype]);
nthread:900:mmc_utils.c:    cJSON_AddStringToObject(hdr, "Name", cfg->session);
nthread:901:mmc_utils.c:    if (mcx_jdataencode(vol, ndim, dims, (isfloat ? "single" : "uint32"), 4, cfg->zipid, dat, 0, cfg)) {
nthread:902:mmc_utils.c:    if (cfg->rootpath[0])
nthread:903:mmc_utils.c:        sprintf(name, "%s\\%s", cfg->rootpath, cfg->session);
nthread:904:mmc_utils.c:        sprintf(name, "%s/%s", cfg->rootpath, cfg->session);
nthread:905:mmc_utils.c:        sprintf(name, "%s", cfg->session);
nthread:906:mmc_utils.c:    if (!isref && (cfg->outputformat == ofNifti || cfg->outputformat == ofAnalyze)) {
nthread:907:mmc_utils.c:        mcx_savenii(dat, len, name, NIFTI_TYPE_FLOAT64, cfg->outputformat, cfg);
nthread:908:mmc_utils.c:    } else if (cfg->outputformat == ofJNifti || cfg->outputformat == ofBJNifti) {
nthread:909:mmc_utils.c:        int d1 = (cfg->maxgate == 1);
nthread:910:mmc_utils.c:        if (cfg->seed == SEED_FROM_FILE && cfg->replaydet == -1 && (cfg->detnum > 1 || cfg->srcnum > 1)) {
nthread:911:mmc_utils.c:            uint dims[5] = {cfg->detnum* cfg->srcnum, cfg->maxgate, cfg->dim.z, cfg->dim.y, cfg->dim.x};
nthread:912:mmc_utils.c:            float voxelsize[] = {1, cfg->tstep, cfg->steps.z, cfg->steps.y, cfg->steps.x};
nthread:913:mmc_utils.c:            if (cfg->outputformat == ofJNifti) {
nthread:914:mmc_utils.c:            uint dims[] = {cfg->dim.x, cfg->dim.y, cfg->dim.z, cfg->maxgate};
nthread:915:mmc_utils.c:            float voxelsize[] = {cfg->steps.x, cfg->steps.y, cfg->steps.z, cfg->tstep};
nthread:916:mmc_utils.c:            size_t datalen = cfg->dim.x * cfg->dim.y * cfg->dim.z * cfg->maxgate;
nthread:917:mmc_utils.c:            if (cfg->outputformat == ofJNifti) {
nthread:918:mmc_utils.c:    sprintf(fname, "%s%s.%s", name, (isref ? "_dref" : ""), (isref ? "bin" : outputformat[(int)cfg->outputformat]));
nthread:919:mmc_utils.c:    if (!isref && cfg->outputformat == ofTX3) {
nthread:920:mmc_utils.c:        fwrite(&(cfg->dim.x), sizeof(int), 3, fp);
nthread:921:mmc_utils.c:    cJSON_AddNumberToObject(hdr, "Version", cfg->his.version);
nthread:922:mmc_utils.c:    cJSON_AddNumberToObject(hdr, "MediaNum", cfg->his.maxmedia);
nthread:923:mmc_utils.c:    cJSON_AddNumberToObject(hdr, "DetNum", cfg->his.detnum);
nthread:924:mmc_utils.c:    cJSON_AddNumberToObject(hdr, "ColumnNum", cfg->his.colcount);
nthread:925:mmc_utils.c:    cJSON_AddNumberToObject(hdr, "TotalPhoton", cfg->his.totalphoton);
nthread:926:mmc_utils.c:    cJSON_AddNumberToObject(hdr, "SavedPhoton", cfg->his.savedphoton);
nthread:927:mmc_utils.c:    cJSON_AddNumberToObject(hdr, "LengthUnit", cfg->his.unitinmm);
nthread:928:mmc_utils.c:    cJSON_AddNumberToObject(hdr, "SeedByte", cfg->his.seedbyte);
nthread:929:mmc_utils.c:    cJSON_AddNumberToObject(hdr, "Normalizer", cfg->his.normalizer);
nthread:930:mmc_utils.c:    cJSON_AddNumberToObject(hdr, "Repeat", cfg->his.respin);
nthread:931:mmc_utils.c:    cJSON_AddNumberToObject(hdr, "SrcNum", cfg->his.srcnum);
nthread:932:mmc_utils.c:    cJSON_AddNumberToObject(hdr, "SaveDetFlag", cfg->his.savedetflag);
nthread:933:mmc_utils.c:    for (i = 0; i < cfg->medianum; i++) {
nthread:934:mmc_utils.c:        cJSON_AddNumberToObject(dat, "mua", cfg->prop[i].mua / cfg->unitinmm);
nthread:935:mmc_utils.c:        cJSON_AddNumberToObject(dat, "mus", cfg->prop[i].mus / cfg->unitinmm);
nthread:936:mmc_utils.c:        cJSON_AddNumberToObject(dat, "g",   cfg->prop[i].g);
nthread:937:mmc_utils.c:        cJSON_AddNumberToObject(dat, "n",   cfg->prop[i].n);
nthread:938:mmc_utils.c:    if (cfg->his.detected == 0  && cfg->his.savedphoton) {
nthread:939:mmc_utils.c:                    buf[i * dims[1] + j] = ppath[i * cfg->his.colcount + col + j];
nthread:940:mmc_utils.c:            if (mcx_jdataencode(buf, 2, dims, dtype[id], 4, cfg->zipid, sub, 0, cfg)) {
nthread:941:mmc_utils.c:        char colnum[] = {1, cfg->his.maxmedia, cfg->his.maxmedia, cfg->his.maxmedia, 3, 3, 1};
nthread:942:mmc_utils.c:            if ((cfg->savedetflag >> id) & 0x1) {
nthread:943:mmc_utils.c:                            ibuf[i * dims[1] + j] = ppath[i * cfg->his.colcount + col + j];
nthread:944:mmc_utils.c:                            fbuf[i * dims[1] + j] = ppath[i * cfg->his.colcount + col + j];
nthread:945:mmc_utils.c:                if (mcx_jdataencode(val, 2, dims, dtype[id], 4, cfg->zipid, sub, 0, cfg)) {
nthread:946:mmc_utils.c:    if (cfg->issaveseed && seeds != NULL) {
nthread:947:mmc_utils.c:        uint dims[2] = {count, cfg->his.seedbyte};
nthread:948:mmc_utils.c:        if (mcx_jdataencode(seeds, 2, dims, "uint8", 1, cfg->zipid, sub, 0, cfg)) {
nthread:949:mmc_utils.c:    filetag = ((cfg->his.detected == 0  && cfg->his.savedphoton) ? 't' : 'h');
nthread:950:mmc_utils.c:    if (cfg->rootpath[0]) {
nthread:951:mmc_utils.c:        sprintf(fhistory, "%s%c%s_%s.jdat", cfg->rootpath, pathsep, cfg->session, (filetag == 't' ? "traj" : "detp"));
nthread:952:mmc_utils.c:        sprintf(fhistory, "%s_%s.jdat", cfg->session, (filetag == 't' ? "traj" : "detp"));
nthread:953:mmc_utils.c:    if (cfg->flog > 0) { /*stdout is 1*/
nthread:954:mmc_utils.c:        MMC_FPRINTF(cfg->flog, "%s\n", str);
nthread:955:mmc_utils.c:        if (cfg->session[0] == '\0') {
nthread:956:mmc_utils.c:            strcpy(cfg->session, "default");
nthread:957:mmc_utils.c:        if (cfg->session[0] == '\0') {
nthread:958:mmc_utils.c:            strncpy(cfg->session, fname, MAX_SESSION_LENGTH - 1);
nthread:959:mmc_utils.c:        strncpy(cfg->meshtag, FIND_JSON_KEY("MeshID", "Mesh.MeshID", Mesh, (MMC_ERROR(-1, "You must specify mesh files"), ""), valuestring), MAX_SESSION_LENGTH - 1);
nthread:960:mmc_utils.c:        cfg->e0 = FIND_JSON_KEY("InitElem", "Mesh.InitElem", Mesh, (MMC_ERROR(-1, "InitElem must be given"), 0.0), valueint);
nthread:961:mmc_utils.c:            cfg->unitinmm = FIND_JSON_KEY("LengthUnit", "Mesh.LengthUnit", Mesh, 1.0, valuedouble);
nthread:962:mmc_utils.c:                cfg->srcpos.x = subitem->child->valuedouble;
nthread:963:mmc_utils.c:                cfg->srcpos.y = subitem->child->next->valuedouble;
nthread:964:mmc_utils.c:                cfg->srcpos.z = subitem->child->next->next->valuedouble;
nthread:965:mmc_utils.c:                cfg->srcdir.x = subitem->child->valuedouble;
nthread:966:mmc_utils.c:                cfg->srcdir.y = subitem->child->next->valuedouble;
nthread:967:mmc_utils.c:                cfg->srcdir.z = subitem->child->next->next->valuedouble;
nthread:968:mmc_utils.c:                    cfg->srcdir.w = subitem->child->next->next->next->valuedouble;
nthread:969:mmc_utils.c:                cfg->srctype = mcx_keylookup(subitem->valuestring, srctypeid);
nthread:970:mmc_utils.c:                cfg->srcparam1.x = subitem->child->valuedouble;
nthread:971:mmc_utils.c:                    cfg->srcparam1.y = subitem->child->next->valuedouble;
nthread:972:mmc_utils.c:                        cfg->srcparam1.z = subitem->child->next->next->valuedouble;
nthread:973:mmc_utils.c:                            cfg->srcparam1.w = subitem->child->next->next->next->valuedouble;
nthread:974:mmc_utils.c:                cfg->srcparam2.x = subitem->child->valuedouble;
nthread:975:mmc_utils.c:                    cfg->srcparam2.y = subitem->child->next->valuedouble;
nthread:976:mmc_utils.c:                        cfg->srcparam2.z = subitem->child->next->next->valuedouble;
nthread:977:mmc_utils.c:                            cfg->srcparam2.w = subitem->child->next->next->next->valuedouble;
nthread:978:mmc_utils.c:                cfg->detnum = cJSON_GetArraySize(dets);
nthread:979:mmc_utils.c:                cfg->detpos = (float4*)malloc(sizeof(float4) * cfg->detnum);
nthread:980:mmc_utils.c:                for (i = 0; i < cfg->detnum; i++) {
nthread:981:mmc_utils.c:                        cfg->detpos[i].x = pos->child->valuedouble;
nthread:982:mmc_utils.c:                        cfg->detpos[i].y = pos->child->next->valuedouble;
nthread:983:mmc_utils.c:                        cfg->detpos[i].z = pos->child->next->next->valuedouble;
nthread:984:mmc_utils.c:                        cfg->detpos[i].w = rad->valuedouble;
nthread:985:mmc_utils.c:            cfg->seed = FIND_JSON_KEY("RNGSeed", "Session.RNGSeed", Session, -1, valueint);
nthread:986:mmc_utils.c:            cfg->nphoton = FIND_JSON_KEY("Photons", "Session.Photons", Session, 0, valueint);
nthread:987:mmc_utils.c:        if (cfg->session[0] == '\0') {
nthread:988:mmc_utils.c:            strncpy(cfg->session, FIND_JSON_KEY("ID", "Session.ID", Session, "default", valuestring), MAX_SESSION_LENGTH);
nthread:989:mmc_utils.c:            cfg->isreflect = FIND_JSON_KEY("DoMismatch", "Session.DoMismatch", Session, cfg->isreflect, valueint);
nthread:990:mmc_utils.c:            cfg->issave2pt = FIND_JSON_KEY("DoSaveVolume", "Session.DoSaveVolume", Session, cfg->issave2pt, valueint);
nthread:991:mmc_utils.c:            cfg->isnormalized = FIND_JSON_KEY("DoNormalize", "Session.DoNormalize", Session, cfg->isnormalized, valueint);
nthread:992:mmc_utils.c:            cfg->issavedet = FIND_JSON_KEY("DoPartialPath", "Session.DoPartialPath", Session, cfg->issavedet, valueint);
nthread:993:mmc_utils.c:            cfg->isspecular = FIND_JSON_KEY("DoSpecular", "Session.DoSpecular", Session, cfg->isspecular, valueint);
nthread:994:mmc_utils.c:            cfg->ismomentum = FIND_JSON_KEY("DoDCS", "Session.DoDCS", Session, cfg->ismomentum, valueint);
nthread:995:mmc_utils.c:            cfg->issaveexit = FIND_JSON_KEY("DoSaveExit", "Session.DoSaveExit", Session, cfg->issaveexit, valueint);
nthread:996:mmc_utils.c:            cfg->issaveseed = FIND_JSON_KEY("DoSaveSeed", "Session.DoSaveSeed", Session, cfg->issaveseed, valueint);
nthread:997:mmc_utils.c:            cfg->basisorder = FIND_JSON_KEY("BasisOrder", "Session.BasisOrder", Session, cfg->basisorder, valueint);
nthread:998:mmc_utils.c:        if (!cfg->outputformat) {
nthread:999:mmc_utils.c:            cfg->outputformat = mcx_keylookup((char*)FIND_JSON_KEY("OutputFormat", "Session.OutputFormat", Session, "ascii", valuestring), outputformat);
nthread:1000:mmc_utils.c:        if (cfg->outputformat < 0) {
nthread:1001:mmc_utils.c:        if (cfg->debuglevel == 0) {
nthread:1002:mmc_utils.c:            cfg->debuglevel = mcx_parsedebugopt((char*)FIND_JSON_KEY("DebugFlag", "Session.DebugFlag", Session, "", valuestring));
nthread:1003:mmc_utils.c:            strncpy(val, FIND_JSON_KEY("RayTracer", "Session.RayTracer", Session, raytracing + cfg->method, valuestring), 1);
nthread:1004:mmc_utils.c:            cfg->method = val[0];
nthread:1005:mmc_utils.c:            strncpy(val, FIND_JSON_KEY("OutputType", "Session.OutputType", Session, outputtype + cfg->outputtype, valuestring), 1);
nthread:1006:mmc_utils.c:            cfg->outputtype = val[0];
nthread:1007:mmc_utils.c:                cfg->checkpt[i] = ck->valueint;
nthread:1008:mmc_utils.c:        cfg->tstart = FIND_JSON_KEY("T0", "Forward.T0", Forward, 0.0, valuedouble);
nthread:1009:mmc_utils.c:        cfg->tend  = FIND_JSON_KEY("T1", "Forward.T1", Forward, 0.0, valuedouble);
nthread:1010:mmc_utils.c:        cfg->tstep = FIND_JSON_KEY("Dt", "Forward.Dt", Forward, 0.0, valuedouble);
nthread:1011:mmc_utils.c:        cfg->nout = FIND_JSON_KEY("N0", "Forward.N0", Forward, cfg->nout, valuedouble);
nthread:1012:mmc_utils.c:        cfg->maxgate = (int)((cfg->tend - cfg->tstart) / cfg->tstep + 0.5);
nthread:1013:mmc_utils.c:    if (cfg->meshtag[0] == '\0') {
nthread:1014:mmc_utils.c:    if (cfg->e0 == 0) {
nthread:1015:mmc_utils.c:    if (cfg->nphoton == 0) {
nthread:1016:mmc_utils.c:        cfg->nphoton = nphoton;
nthread:1017:mmc_utils.c:        MMC_FPRINTF(stdout, ">> %zu\nPlease specify the random number generator seed: [123456789]\n\t", cfg->nphoton);
nthread:1018:mmc_utils.c:    if (cfg->seed == 0x623F9A9E) {
nthread:1019:mmc_utils.c:        MMC_ASSERT(fscanf(in, "%d", &(cfg->seed) ) == 1);
nthread:1020:mmc_utils.c:        MMC_FPRINTF(stdout, ">> %d\nPlease specify the position of the source: [10 10 5]\n\t", cfg->seed);
nthread:1021:mmc_utils.c:    MMC_ASSERT(fscanf(in, "%f %f %f", &(cfg->srcpos.x), &(cfg->srcpos.y), &(cfg->srcpos.z) ) == 3);
nthread:1022:mmc_utils.c:                    cfg->srcpos.x, cfg->srcpos.y, cfg->srcpos.z);
nthread:1023:mmc_utils.c:    MMC_ASSERT(fscanf(in, "%f %f %f", &(cfg->srcdir.x), &(cfg->srcdir.y), &(cfg->srcdir.z)));
nthread:1024:mmc_utils.c:        cfg->srcdir.w = dtmp;
nthread:1025:mmc_utils.c:                    cfg->srcdir.x, cfg->srcdir.y, cfg->srcdir.z, cfg->srcdir.w);
nthread:1026:mmc_utils.c:    MMC_ASSERT(fscanf(in, "%f %f %f", &(cfg->tstart), &(cfg->tend), &(cfg->tstep) ) == 3);
nthread:1027:mmc_utils.c:                    cfg->tstart, cfg->tend, cfg->tstep);
nthread:1028:mmc_utils.c:    if (cfg->tstart > cfg->tend || cfg->tstep == 0.f) {
nthread:1029:mmc_utils.c:    if (cfg->tstep > cfg->tend - cfg->tstart) {
nthread:1030:mmc_utils.c:        cfg->tstep = cfg->tend - cfg->tstart;
nthread:1031:mmc_utils.c:    gates = (int)((cfg->tend - cfg->tstart) / cfg->tstep + 0.5);
nthread:1032:mmc_utils.c:    /*if(cfg->maxgate>gates)*/
nthread:1033:mmc_utils.c:    cfg->maxgate = gates;
nthread:1034:mmc_utils.c:    MMC_ASSERT(fscanf(in, "%s", cfg->meshtag) == 1);
nthread:1035:mmc_utils.c:    if (cfg->rootpath[0]) {
nthread:1036:mmc_utils.c:        sprintf(comment, "%s\\%s", cfg->rootpath, cfg->meshtag);
nthread:1037:mmc_utils.c:        sprintf(comment, "%s/%s", cfg->rootpath, cfg->meshtag);
nthread:1038:mmc_utils.c:        memcpy(cfg->meshtag, comment, MAX_SESSION_LENGTH);
nthread:1039:mmc_utils.c:        MMC_FPRINTF(stdout, ">> %s\nPlease specify the index to the tetrahedral element enclosing the source [start from 1]:\n\t", cfg->meshtag);
nthread:1040:mmc_utils.c:    MMC_ASSERT(fscanf(in, "%d", &(cfg->e0)) == 1);
nthread:1041:mmc_utils.c:        MMC_FPRINTF(stdout, ">> %d\nPlease specify the total number of detectors and detector diameter (in mm):\n\t", cfg->e0);
nthread:1042:mmc_utils.c:    MMC_ASSERT(fscanf(in, "%d %f", &(cfg->detnum), &(cfg->detradius)) == 2);
nthread:1043:mmc_utils.c:        MMC_FPRINTF(stdout, ">> %d %f\n", cfg->detnum, cfg->detradius);
nthread:1044:mmc_utils.c:    cfg->detpos = (float4*)malloc(sizeof(float4) * cfg->detnum);
nthread:1045:mmc_utils.c:    if (cfg->issavedet) {
nthread:1046:mmc_utils.c:        cfg->issavedet = (cfg->detpos > 0);
nthread:1047:mmc_utils.c:    for (i = 0; i < cfg->detnum; i++) {
nthread:1048:mmc_utils.c:        MMC_ASSERT(fscanf(in, "%f %f %f", &(cfg->detpos[i].x), &(cfg->detpos[i].y), &(cfg->detpos[i].z)) == 3);
nthread:1049:mmc_utils.c:            cfg->detpos[i].w = dtmp;
nthread:1050:mmc_utils.c:            cfg->detpos[i].w = cfg->detradius;
nthread:1051:mmc_utils.c:            MMC_FPRINTF(stdout, ">> %f %f %f\n", cfg->detpos[i].x, cfg->detpos[i].y, cfg->detpos[i].z);
nthread:1052:mmc_utils.c:            cfg->srctype = srctype;
nthread:1053:mmc_utils.c:                MMC_FPRINTF(stdout, ">> %d\nPlease specify the source parameters set 1 (4 floating-points):\n\t", cfg->srctype);
nthread:1054:mmc_utils.c:            MMC_ASSERT(fscanf(in, "%f %f %f %f", &(cfg->srcparam1.x), &(cfg->srcparam1.y), &(cfg->srcparam1.z), &(cfg->srcparam1.w)) == 4);
nthread:1055:mmc_utils.c:                            cfg->srcparam1.x, cfg->srcparam1.y, cfg->srcparam1.z, cfg->srcparam1.w);
nthread:1056:mmc_utils.c:            if (fscanf(in, "%f %f %f %f", &(cfg->srcparam2.x), &(cfg->srcparam2.y), &(cfg->srcparam2.z), &(cfg->srcparam2.w)) == 4) {
nthread:1057:mmc_utils.c:                    MMC_FPRINTF(stdout, ">> %f %f %f %f\n", cfg->srcparam2.x, cfg->srcparam2.y, cfg->srcparam2.z, cfg->srcparam2.w);
nthread:1058:mmc_utils.c:                if (cfg->srctype == stPattern && cfg->srcparam1.w * cfg->srcparam2.w > 0) {
nthread:1059:mmc_utils.c:                    if (cfg->srcpattern) {
nthread:1060:mmc_utils.c:                        free(cfg->srcpattern);
nthread:1061:mmc_utils.c:                    MMC_ASSERT(fscanf(in, "%s %d", srcpatternfile, &(cfg->srcnum)) >= 1);
nthread:1062:mmc_utils.c:                    if (cfg->srcnum < 1) {
nthread:1063:mmc_utils.c:                    cfg->srcpattern = (float*)calloc((cfg->srcparam1.w * cfg->srcparam2.w * cfg->srcnum), sizeof(float));
nthread:1064:mmc_utils.c:                    MMC_ASSERT(fread(cfg->srcpattern, cfg->srcparam1.w * cfg->srcparam2.w * cfg->srcnum, sizeof(float), fp) == sizeof(float));
nthread:1065:mmc_utils.c:            if (cfg->detnum == 1 && cfg->detpos[0].w == 0.0) {
nthread:1066:mmc_utils.c:                MMC_ASSERT(fscanf(in, "%f %f %f %f", &(cfg->detparam1.x), &(cfg->detparam1.y), &(cfg->detparam1.z), &(cfg->detparam1.w)) == 4);
nthread:1067:mmc_utils.c:                                cfg->detparam1.x, cfg->detparam1.y, cfg->detparam1.z, cfg->detparam1.w);
nthread:1068:mmc_utils.c:                MMC_ASSERT(fscanf(in, "%f %f %f %f", &(cfg->detparam2.x), &(cfg->detparam2.y), &(cfg->detparam2.z), &(cfg->detparam2.w)) == 4);
nthread:1069:mmc_utils.c:                    MMC_FPRINTF(stdout, ">> %f %f %f %f\n", cfg->detparam2.x, cfg->detparam2.y, cfg->detparam2.z, cfg->detparam2.w);
nthread:1070:mmc_utils.c:                if (cfg->seed == SEED_FROM_FILE && (cfg->outputtype == otWL || cfg->outputtype == otWP) && cfg->detparam1.w * cfg->detparam2.w > 0) {
nthread:1071:mmc_utils.c:                    if (cfg->detpattern) {
nthread:1072:mmc_utils.c:                        free(cfg->detpattern);
nthread:1073:mmc_utils.c:                    cfg->detpattern = (float*)calloc((cfg->detparam1.w * cfg->detparam2.w), sizeof(float));
nthread:1074:mmc_utils.c:                    MMC_ASSERT(fread(cfg->detpattern, cfg->detparam1.w * cfg->detparam2.w, sizeof(float), fp) == sizeof(float));
nthread:1075:mmc_utils.c:    MMC_FPRINTF(out, "%zu\n", (cfg->nphoton) );
nthread:1076:mmc_utils.c:    MMC_FPRINTF(out, "%d\n", (cfg->seed) );
nthread:1077:mmc_utils.c:    MMC_FPRINTF(out, "%f %f %f\n", (cfg->srcpos.x), (cfg->srcpos.y), (cfg->srcpos.z) );
nthread:1078:mmc_utils.c:    MMC_FPRINTF(out, "%f %f %f\n", (cfg->srcdir.x), (cfg->srcdir.y), (cfg->srcdir.z) );
nthread:1079:mmc_utils.c:    MMC_FPRINTF(out, "%f %f %f\n", (cfg->tstart), (cfg->tend), (cfg->tstep) );
nthread:1080:mmc_utils.c:    MMC_FPRINTF(out, "%f %d %d %d\n", (cfg->steps.x), (cfg->dim.x), (cfg->crop0.x), (cfg->crop1.x));
nthread:1081:mmc_utils.c:    MMC_FPRINTF(out, "%f %d %d %d\n", (cfg->steps.y), (cfg->dim.y), (cfg->crop0.y), (cfg->crop1.y));
nthread:1082:mmc_utils.c:    MMC_FPRINTF(out, "%f %d %d %d\n", (cfg->steps.z), (cfg->dim.z), (cfg->crop0.z), (cfg->crop1.z));
nthread:1083:mmc_utils.c:    MMC_FPRINTF(out, "%d", (cfg->medianum));
nthread:1084:mmc_utils.c:    for (i = 0; i < cfg->medianum; i++) {
nthread:1085:mmc_utils.c:        MMC_FPRINTF(out, "%f %f %f %f\n", (cfg->prop[i].mus), (cfg->prop[i].g), (cfg->prop[i].mua), (cfg->prop[i].n));
nthread:1086:mmc_utils.c:    MMC_FPRINTF(out, "%d", (cfg->detnum));
nthread:1087:mmc_utils.c:    for (i = 0; i < cfg->detnum; i++) {
nthread:1088:mmc_utils.c:        MMC_FPRINTF(out, "%f %f %f %f\n", (cfg->detpos[i].x), (cfg->detpos[i].y), (cfg->detpos[i].z), (cfg->detpos[i].w));
nthread:1089:mmc_utils.c:    cJSON_AddStringToObject(obj, "ID", cfg->session);
nthread:1090:mmc_utils.c:    cJSON_AddNumberToObject(obj, "Photons", cfg->nphoton);
nthread:1091:mmc_utils.c:    cJSON_AddNumberToObject(obj, "RNGSeed", (uint)cfg->seed);
nthread:1092:mmc_utils.c:    if (cfg->isreflect > 1) {
nthread:1093:mmc_utils.c:        cJSON_AddNumberToObject(obj, "DoMismatch", cfg->isreflect);
nthread:1094:mmc_utils.c:        cJSON_AddBoolToObject(obj, "DoMismatch", cfg->isreflect);
nthread:1095:mmc_utils.c:    cJSON_AddBoolToObject(obj, "DoSaveVolume", cfg->issave2pt);
nthread:1096:mmc_utils.c:    if (cfg->isreflect > 1) {
nthread:1097:mmc_utils.c:        cJSON_AddNumberToObject(obj, "DoNormalize", cfg->isnormalized);
nthread:1098:mmc_utils.c:        cJSON_AddBoolToObject(obj, "DoNormalize", cfg->isnormalized);
nthread:1099:mmc_utils.c:    cJSON_AddBoolToObject(obj, "DoPartialPath", cfg->issavedet);
nthread:1100:mmc_utils.c:    if (cfg->issaveref) {
nthread:1101:mmc_utils.c:        cJSON_AddNumberToObject(obj, "DoSaveRef", cfg->issaveref);
nthread:1102:mmc_utils.c:        cJSON_AddBoolToObject(obj, "DoSaveRef", cfg->issaveref);
nthread:1103:mmc_utils.c:    cJSON_AddBoolToObject(obj, "DoSaveExit", cfg->issaveexit);
nthread:1104:mmc_utils.c:    cJSON_AddBoolToObject(obj, "DoSaveSeed", cfg->issaveseed);
nthread:1105:mmc_utils.c:    cJSON_AddBoolToObject(obj, "DoAutoThread", cfg->autopilot);
nthread:1106:mmc_utils.c:    cJSON_AddBoolToObject(obj, "DoDCS", cfg->ismomentum);
nthread:1107:mmc_utils.c:    cJSON_AddBoolToObject(obj, "DoSpecular", cfg->isspecular);
nthread:1108:mmc_utils.c:    if (cfg->rootpath[0] != '\0') {
nthread:1109:mmc_utils.c:        cJSON_AddStringToObject(obj, "RootPath", cfg->rootpath);
nthread:1110:mmc_utils.c:    cJSON_AddNumberToObject(obj, "DebugFlag", cfg->debuglevel);
nthread:1111:mmc_utils.c:    cJSON_AddNumberToObject(obj, "SaveDataMask", cfg->savedetflag);
nthread:1112:mmc_utils.c:    if (cfg->outputformat >= 0) {
nthread:1113:mmc_utils.c:        cJSON_AddStringToObject(obj, "OutputFormat", outputformat[(int)cfg->outputformat]);
nthread:1114:mmc_utils.c:    if (cfg->outputtype >= 0) {
nthread:1115:mmc_utils.c:        outputtypestr[0] = outputtype[(int)cfg->outputtype];
nthread:1116:mmc_utils.c:    cJSON_AddNumberToObject(obj, "T0", cfg->tstart);
nthread:1117:mmc_utils.c:    cJSON_AddNumberToObject(obj, "T1", cfg->tend);
nthread:1118:mmc_utils.c:    cJSON_AddNumberToObject(obj, "Dt", cfg->tstep);
nthread:1119:mmc_utils.c:    cJSON_AddNumberToObject(obj, "LengthUnit", cfg->unitinmm);
nthread:1120:mmc_utils.c:    for (i = 0; i < cfg->medianum; i++) {
nthread:1121:mmc_utils.c:        cJSON_AddNumberToObject(tmp, "mua", cfg->prop[i].mua / cfg->unitinmm);
nthread:1122:mmc_utils.c:        cJSON_AddNumberToObject(tmp, "mus", cfg->prop[i].mus / cfg->unitinmm);
nthread:1123:mmc_utils.c:        cJSON_AddNumberToObject(tmp, "g",   cfg->prop[i].g);
nthread:1124:mmc_utils.c:        cJSON_AddNumberToObject(tmp, "n",   cfg->prop[i].n);
nthread:1125:mmc_utils.c:    cJSON_AddItemToObject(obj, "Dim", cJSON_CreateIntArray((int*) & (cfg->dim.x), 3));
nthread:1126:mmc_utils.c:    if (cfg->srctype >= 0) {
nthread:1127:mmc_utils.c:        cJSON_AddStringToObject(sub, "Type", srctypeid[(int)cfg->srctype]);
nthread:1128:mmc_utils.c:    cJSON_AddItemToObject(sub, "Pos", cJSON_CreateFloatArray(&(cfg->srcpos.x), 3));
nthread:1129:mmc_utils.c:    cJSON_AddItemToObject(sub, "Dir", cJSON_CreateFloatArray(&(cfg->srcdir.x), 4));
nthread:1130:mmc_utils.c:    cJSON_AddItemToObject(sub, "Param1", cJSON_CreateFloatArray(&(cfg->srcparam1.x), 4));
nthread:1131:mmc_utils.c:    cJSON_AddItemToObject(sub, "Param2", cJSON_CreateFloatArray(&(cfg->srcparam2.x), 4));
nthread:1132:mmc_utils.c:    cJSON_AddNumberToObject(sub, "SrcNum", cfg->srcnum);
nthread:1133:mmc_utils.c:    for (i = 0; i < cfg->detnum; i++) {
nthread:1134:mmc_utils.c:        cJSON_AddItemToObject(tmp, "Pos", cJSON_CreateFloatArray(&(cfg->detpos[i].x), 3));
nthread:1135:mmc_utils.c:        cJSON_AddNumberToObject(tmp, "R", cfg->detpos[i].w);
nthread:1136:mmc_utils.c:    if (cfg->shapedata) {
nthread:1137:mmc_utils.c:        cJSON* shape = cJSON_Parse(cfg->shapedata), *sp;
nthread:1138:mmc_utils.c:        fprintf(cfg->flog, "%s\n", jsonstr);
nthread:1139:mmc_utils.c:        cfg->mediabyte = 4;
nthread:1140:mmc_utils.c:            cfg->mediabyte = 1;
nthread:1141:mmc_utils.c:            cfg->mediabyte = 2;
nthread:1142:mmc_utils.c:            cfg->isrowmajor = 1;
nthread:1143:mmc_utils.c:    if (!cfg->isdumpjson) {
nthread:1144:mmc_utils.c:        if (!cfg->isdumpjson) {
nthread:1145:mmc_utils.c:            if (!cfg->isdumpjson) {
nthread:1146:mmc_utils.c:    if (cfg->nphoton <= 0) {
nthread:1147:mmc_utils.c:    if (cfg->tstart > cfg->tend || cfg->tstep == 0.f) {
nthread:1148:mmc_utils.c:    if (cfg->tstep > cfg->tend - cfg->tstart) {
nthread:1149:mmc_utils.c:        cfg->tstep = cfg->tend - cfg->tstart;
nthread:1150:mmc_utils.c:    if (cfg->steps.x != cfg->steps.y || cfg->steps.y != cfg->steps.z) {
nthread:1151:mmc_utils.c:    if (fabs(cfg->srcdir.x * cfg->srcdir.x + cfg->srcdir.y * cfg->srcdir.y + cfg->srcdir.z * cfg->srcdir.z - 1.f) > 1e-4) {
nthread:1152:mmc_utils.c:    if (cfg->tend <= cfg->tstart) {
nthread:1153:mmc_utils.c:    cfg->maxgate = (int)((cfg->tend - cfg->tstart) / cfg->tstep + 0.5);
nthread:1154:mmc_utils.c:    cfg->tend = cfg->tstart + cfg->tstep * cfg->maxgate;
nthread:1155:mmc_utils.c:    if (cfg->srctype == stPattern && cfg->srcpattern == NULL) {
nthread:1156:mmc_utils.c:    if (cfg->srcnum > 1 && cfg->seed == SEED_FROM_FILE) {
nthread:1157:mmc_utils.c:    if (cfg->seed < 0 && cfg->seed != SEED_FROM_FILE) {
nthread:1158:mmc_utils.c:        cfg->seed = time(NULL);
nthread:1159:mmc_utils.c:    if (cfg->compute != cbSSE && (cfg->method != rtBLBadouelGrid && cfg->method != rtBLBadouel)) {
nthread:1160:mmc_utils.c:        cfg->method = rtBLBadouel;
nthread:1161:mmc_utils.c:    if (cfg->method == rtBLBadouelGrid) {
nthread:1162:mmc_utils.c:        cfg->basisorder = 0;
nthread:1163:mmc_utils.c:        if (cfg->deviceid[i] == '0') {
nthread:1164:mmc_utils.c:            cfg->deviceid[i] = '\0';
nthread:1165:mmc_utils.c:    if (cfg->issavedet && cfg->detnum == 0 && cfg->isextdet == 0) {
nthread:1166:mmc_utils.c:        cfg->issavedet = 0;
nthread:1167:mmc_utils.c:    if (cfg->issavedet == 0) {
nthread:1168:mmc_utils.c:        cfg->ismomentum = 0;
nthread:1169:mmc_utils.c:        cfg->issaveexit = 0;
nthread:1170:mmc_utils.c:    cfg->savedetflag = 0x47;
nthread:1171:mmc_utils.c:    if (cfg->ismomentum) {
nthread:1172:mmc_utils.c:        cfg->savedetflag = SET_SAVE_MOM(cfg->savedetflag);
nthread:1173:mmc_utils.c:    if (cfg->issaveexit) {
nthread:1174:mmc_utils.c:        cfg->savedetflag = SET_SAVE_PEXIT(cfg->savedetflag);
nthread:1175:mmc_utils.c:        cfg->savedetflag = SET_SAVE_VEXIT(cfg->savedetflag);
nthread:1176:mmc_utils.c:                    MMC_FPRINTF(cfg->flog, "option: %s\n", argv[i]);
nthread:1177:mmc_utils.c:                    cfg->nphoton = (size_t)np;
nthread:1178:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->nthread), "int");
nthread:1179:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->nblocksize), "int");
nthread:1180:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, cfg->session, "string");
nthread:1181:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->issaveseed), "bool");
nthread:1182:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->maxgate), "int");
nthread:1183:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->isreflect), "bool");
nthread:1184:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->issavedet), "bool");
nthread:1185:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->mcmethod), "int");
nthread:1186:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->issaveexit), "bool");
nthread:1187:mmc_utils.c:                    if (cfg->issaveexit) {
nthread:1188:mmc_utils.c:                        cfg->issavedet = 1;
nthread:1189:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->issaveref), "char");
nthread:1190:mmc_utils.c:                    if (cfg->issaveref) {
nthread:1191:mmc_utils.c:                        cfg->issaveref = 1;
nthread:1192:mmc_utils.c:                        cfg->zipid = mcx_keylookup(argv[++i], zipformat);
nthread:1193:mmc_utils.c:                        i = mcx_readarg(argc, argv, i, &(cfg->zipid), "int");
nthread:1194:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->basisorder), "bool");
nthread:1195:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->isspecular), "bool");
nthread:1196:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->respin), "int");
nthread:1197:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->issave2pt), "bool");
nthread:1198:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->minenergy), "float");
nthread:1199:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->isnormalized), "bool");
nthread:1200:mmc_utils.c:                        i = mcx_readarg(argc, argv, i, cfg->seedfile, "string");
nthread:1201:mmc_utils.c:                        cfg->seed = SEED_FROM_FILE;
nthread:1202:mmc_utils.c:                        i = mcx_readarg(argc, argv, i, &(cfg->seed), "int");
nthread:1203:mmc_utils.c:                    if ((cfg->outputformat = mcx_keylookup(argv[++i], outputformat)) < 0) {
nthread:1204:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->outputtype), "char");
nthread:1205:mmc_utils.c:                    if (mcx_lookupindex(&(cfg->outputtype), outputtype)) {
nthread:1206:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->method), "char");
nthread:1207:mmc_utils.c:                    if (mcx_lookupindex(&(cfg->method), raytracing)) {
nthread:1208:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->sradius), "float");
nthread:1209:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->replaydet), "int");
nthread:1210:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->unitinmm), "float");
nthread:1211:mmc_utils.c:                    cfg->isgpuinfo = 2;
nthread:1212:mmc_utils.c:                    cfg->isgpuinfo = 1;
nthread:1213:mmc_utils.c:                    cfg->compileropt[strlen(cfg->compileropt)] = ' ';
nthread:1214:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, cfg->compileropt + strlen(cfg->compileropt), "string");
nthread:1215:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->optlevel), "int");
nthread:1216:mmc_utils.c:                        cfg->debuglevel = mcx_parsedebugopt(argv[++i]);
nthread:1217:mmc_utils.c:                        i = mcx_readarg(argc, argv, i, &(cfg->debuglevel), "int");
nthread:1218:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->voidtime), "int");
nthread:1219:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->maxdetphoton), "int");
nthread:1220:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, &(cfg->autopilot), "int");
nthread:1221:mmc_utils.c:                        cfg->compute = mcx_keylookup(argv[++i], computebackend);
nthread:1222:mmc_utils.c:                        i = mcx_readarg(argc, argv, i, &(cfg->compute), "int");
nthread:1223:mmc_utils.c:                        i = mcx_readarg(argc, argv, i, cfg->deviceid, "string");
nthread:1224:mmc_utils.c:                        i = mcx_readarg(argc, argv, i, &(cfg->gpuid), "int");
nthread:1225:mmc_utils.c:                        memset(cfg->deviceid, '0', MAX_DEVICE);
nthread:1226:mmc_utils.c:                        if (cfg->gpuid > 0 && cfg->gpuid < MAX_DEVICE) {
nthread:1227:mmc_utils.c:                            cfg->deviceid[cfg->gpuid - 1] = '1';
nthread:1228:mmc_utils.c:                    i = mcx_readarg(argc, argv, i, cfg->workload, "floatlist");
nthread:1229:mmc_utils.c:                        i = mcx_readarg(argc, argv, i, &(cfg->ismomentum), "bool");
nthread:1230:mmc_utils.c:                        if (cfg->ismomentum) {
nthread:1231:mmc_utils.c:                            cfg->issavedet = 1;
nthread:1232:mmc_utils.c:                        i = mcx_readarg(argc, argv, i, &(cfg->isatomic), "bool");
nthread:1233:mmc_utils.c:                        i = mcx_readarg(argc, argv, i, cfg->rootpath, "string");
nthread:1234:mmc_utils.c:                        cfg->jsonfile[0] = '-';
nthread:1235:mmc_utils.c:                            cfg->isdumpjson = 1;
nthread:1236:mmc_utils.c:                            cfg->isdumpjson = 1;
nthread:1237:mmc_utils.c:                            memcpy(cfg->jsonfile, argv[i + 1], MIN(strlen(argv[i + 1]), MAX_PATH_LENGTH));
nthread:1238:mmc_utils.c:                            i = mcx_readarg(argc, argv, i, &(cfg->isdumpjson), "int");
nthread:1239:mmc_utils.c:                            MMC_FPRINTF(cfg->flog, "Built-in benchmarks:\n");
nthread:1240:mmc_utils.c:                                MMC_FPRINTF(cfg->flog, "\t%s\n", benchname[i]);
nthread:1241:mmc_utils.c:                        i = mcx_readarg(argc, argv, i, &(cfg->debugphoton), "int");
nthread:1242:mmc_utils.c:                        i = mcx_readarg(argc, argv, i, &(cfg->nbuffer), "int");
nthread:1243:mmc_utils.c:                        i = mcx_readarg(argc, argv, i, &(cfg->steps.x), "int");
nthread:1244:mmc_utils.c:                        cfg->steps.y = cfg->steps.x;
nthread:1245:mmc_utils.c:                        cfg->steps.z = cfg->steps.x;
nthread:1246:mmc_utils.c:                        MMC_FPRINTF(cfg->flog, "unknown verbose option: --%s\n", argv[i] + 2);
nthread:1247:mmc_utils.c:                    MMC_FPRINTF(cfg->flog, "option: %s\n", argv[i]);
nthread:1248:mmc_utils.c:    if (issavelog && cfg->session[0]) {
nthread:1249:mmc_utils.c:        sprintf(logfile, "%s.log", cfg->session);
nthread:1250:mmc_utils.c:        cfg->flog = fopen(logfile, "wt");
nthread:1251:mmc_utils.c:        if (cfg->flog == NULL) {
nthread:1252:mmc_utils.c:            cfg->flog = stdout;
nthread:1253:mmc_utils.c:            MMC_FPRINTF(cfg->flog, "unable to save to log file, will print from stdout\n");
nthread:1254:mmc_utils.c:    if (cfg->kernelfile[0] != '\0' && cfg->isgpuinfo != 2) {
nthread:1255:mmc_utils.c:        FILE* fp = fopen(cfg->kernelfile, "rb");
nthread:1256:mmc_utils.c:        if (cfg->clsource != (char*)mmc_core_cl) {
nthread:1257:mmc_utils.c:            free(cfg->clsource);
nthread:1258:mmc_utils.c:        cfg->clsource = (char*)malloc(srclen + 1);
nthread:1259:mmc_utils.c:        MMC_ASSERT((fread(cfg->clsource, srclen, 1, fp) == 1));
nthread:1260:mmc_utils.c:        cfg->clsource[srclen] = '\0';
nthread:1261:mmc_utils.c:    if ((cfg->outputtype == otJacobian || cfg->outputtype == otWL || cfg->outputtype == otWP) && cfg->seed != SEED_FROM_FILE) {
nthread:1262:mmc_utils.c:    if (cfg->isgpuinfo != 2) { /*print gpu info only*/
nthread:1263:mmc_utils.c:    if (cfg->isgpuinfo == 0) {
nthread:1264:mmc_utils.c:    if (cfg->outputformat == ofJNifti || cfg->outputformat == ofBJNifti) {
nthread:1265:mmc_utils.c:    if (cfg->rootpath[0]) {
nthread:1266:mmc_utils.c:        sprintf(fhistory, "%s%c%s.mch", cfg->rootpath, pathsep, cfg->session);
nthread:1267:mmc_utils.c:        sprintf(fhistory, "%s.mch", cfg->session);
nthread:1268:mmc_utils.c:    fwrite(&(cfg->his), sizeof(history), 1, fp);
nthread:1269:mmc_utils.c:    fwrite(ppath, sizeof(float), count * cfg->his.colcount, fp);
nthread:1270:mmc_utils.c:    MMC_FPRINTF(cfg->flog, S_YELLOW"\
nthread:1271:mmclab.cpp:    if (strcmp(name, "nphoton") == 0 && cfg->photonseed != NULL) {
nthread:1272:mmclab.cpp:    cfg->flog = stderr;
nthread:1273:mmclab.cpp:        cfg->e0 = val[0];
nthread:1274:mmclab.cpp:        printf("mmc.e0=%d;\n", cfg->e0);
nthread:1275:mmclab.cpp:        cfg->implicit = 1;
nthread:1276:mmclab.cpp:        cfg->implicit = 1;
nthread:1277:mmclab.cpp:        cfg->implicit = 2;
nthread:1278:mmclab.cpp:        cfg->detnum = arraydim[0];
nthread:1279:mmclab.cpp:        if (cfg->detpos) {
nthread:1280:mmclab.cpp:            free(cfg->detpos);
nthread:1281:mmclab.cpp:        cfg->detpos = (float4*)malloc(cfg->detnum * sizeof(float4));
nthread:1282:mmclab.cpp:            for (i = 0; i < cfg->detnum; i++) {
nthread:1283:mmclab.cpp:                ((float*)(&cfg->detpos[i]))[j] = val[j * cfg->detnum + i];
nthread:1284:mmclab.cpp:        printf("mmc.detnum=%d;\n", cfg->detnum);
nthread:1285:mmclab.cpp:        cfg->his.maxmedia = mesh->prop;
nthread:1286:mmclab.cpp:        cfg->debuglevel = mcx_parsedebugopt(buf);
nthread:1287:mmclab.cpp:        cfg->srctype = mcx_keylookup(strtypestr, srctypeid);
nthread:1288:mmclab.cpp:        if (cfg->srctype == -1) {
nthread:1289:mmclab.cpp:        int status = mxGetString(item, cfg->session, MAX_SESSION_LENGTH);
nthread:1290:mmclab.cpp:        printf("mmc.session='%s';\n", cfg->session);
nthread:1291:mmclab.cpp:        if (cfg->srcpattern) {
nthread:1292:mmclab.cpp:            free(cfg->srcpattern);
nthread:1293:mmclab.cpp:            cfg->srcnum = arraydim[2];
nthread:1294:mmclab.cpp:            cfg->srcnum = 1;
nthread:1295:mmclab.cpp:        cfg->srcpattern = (float*)malloc(arraydim[0] * arraydim[1] * cfg->srcnum * sizeof(float));
nthread:1296:mmclab.cpp:        for (k = 0; k < arraydim[0]*arraydim[1]*cfg->srcnum; k++) {
nthread:1297:mmclab.cpp:            cfg->srcpattern[k] = val[k];
nthread:1298:mmclab.cpp:        printf("mmc.srcpattern=[%d %d %d];\n", (int)arraydim[0], (int)arraydim[1], cfg->srcnum);
nthread:1299:mmclab.cpp:        cfg->method = mcx_keylookup(methodstr, methods);
nthread:1300:mmclab.cpp:        if (cfg->method == -1) {
nthread:1301:mmclab.cpp:        cfg->outputtype = mcx_keylookup(outputstr, outputtype);
nthread:1302:mmclab.cpp:        if (cfg->outputtype == -1) {
nthread:1303:mmclab.cpp:        cfg->compute = mcx_keylookup(computestr, computebackend);
nthread:1304:mmclab.cpp:        if (cfg->compute == -1) {
nthread:1305:mmclab.cpp:            cfg->seed = val[0];
nthread:1306:mmclab.cpp:            printf("mmc.seed=%d;\n", cfg->seed);
nthread:1307:mmclab.cpp:            cfg->photonseed = malloc(arraydim[0] * arraydim[1]);
nthread:1308:mmclab.cpp:            memcpy(cfg->photonseed, mxGetData(item), arraydim[0]*arraydim[1]);
nthread:1309:mmclab.cpp:            cfg->seed = SEED_FROM_FILE;
nthread:1310:mmclab.cpp:            cfg->nphoton = arraydim[1];
nthread:1311:mmclab.cpp:            printf("mmc.nphoton=%zu;\n", cfg->nphoton);
nthread:1312:mmclab.cpp:        cfg->his.detected = arraydim[0] * arraydim[1];
nthread:1313:mmclab.cpp:        cfg->replayweight = (float*)malloc(cfg->his.detected * sizeof(float));
nthread:1314:mmclab.cpp:        memcpy(cfg->replayweight, mxGetData(item), cfg->his.detected * sizeof(float));
nthread:1315:mmclab.cpp:        printf("mmc.replayweight=%d;\n", cfg->his.detected);
nthread:1316:mmclab.cpp:        cfg->his.detected = arraydim[0] * arraydim[1];
nthread:1317:mmclab.cpp:        cfg->replaytime = (float*)malloc(cfg->his.detected * sizeof(float));
nthread:1318:mmclab.cpp:        memcpy(cfg->replaytime, mxGetData(item), cfg->his.detected * sizeof(float));
nthread:1319:mmclab.cpp:        printf("mmc.replaytime=%d;\n", cfg->his.detected);
nthread:1320:mmclab.cpp:            int status = mxGetString(item, cfg->deviceid, MAX_DEVICE);
nthread:1321:mmclab.cpp:            printf("mmc.gpuid='%s';\n", cfg->deviceid);
nthread:1322:mmclab.cpp:            cfg->gpuid = val[0];
nthread:1323:mmclab.cpp:            memset(cfg->deviceid, 0, MAX_DEVICE);
nthread:1324:mmclab.cpp:            if (cfg->gpuid > 0 && cfg->gpuid < MAX_DEVICE) {
nthread:1325:mmclab.cpp:                memset(cfg->deviceid, '0', cfg->gpuid - 1);
nthread:1326:mmclab.cpp:                cfg->deviceid[cfg->gpuid - 1] = '1';
nthread:1327:mmclab.cpp:            printf("mmc.gpuid=%d;\n", cfg->gpuid);
nthread:1328:mmclab.cpp:            if (cfg->deviceid[i] == '0') {
nthread:1329:mmclab.cpp:                cfg->deviceid[i] = '\0';
nthread:1330:mmclab.cpp:            cfg->workload[i] = val[i];
nthread:1331:mmclab.cpp:    if (cfg->nphoton <= 0) {
nthread:1332:mmclab.cpp:    if (cfg->tstart > cfg->tend || cfg->tstep == 0.f) {
nthread:1333:mmclab.cpp:    if (cfg->tstep > cfg->tend - cfg->tstart) {
nthread:1334:mmclab.cpp:        cfg->tstep = cfg->tend - cfg->tstart;
nthread:1335:mmclab.cpp:    if (ABS(cfg->srcdir.x * cfg->srcdir.x + cfg->srcdir.y * cfg->srcdir.y + cfg->srcdir.z * cfg->srcdir.z - 1.f) > 1e-5) {
nthread:1336:mmclab.cpp:    if (cfg->tend <= cfg->tstart) {
nthread:1337:mmclab.cpp:    cfg->maxgate = (int)((cfg->tend - cfg->tstart) / cfg->tstep + 0.5);
nthread:1338:mmclab.cpp:    cfg->tend = cfg->tstart + cfg->tstep * cfg->maxgate;
nthread:1339:mmclab.cpp:    if (cfg->method == rtBLBadouelGrid) {
nthread:1340:mmclab.cpp:        cfg->basisorder = 0;
nthread:1341:mmclab.cpp:    datalen = (cfg->method == rtBLBadouelGrid) ? cfg->crop0.z : ( (cfg->basisorder) ? mesh->nn : mesh->ne);
nthread:1342:mmclab.cpp:    mesh->weight = (double*)calloc(sizeof(double) * datalen * cfg->srcnum, cfg->maxgate);
nthread:1343:mmclab.cpp:    if (cfg->srctype == stPattern && cfg->srcpattern == NULL) {
nthread:1344:mmclab.cpp:    if (cfg->srcnum > 1 && cfg->seed == SEED_FROM_FILE) {
nthread:1345:mmclab.cpp:    if (cfg->method != rtBLBadouelGrid && cfg->unitinmm != 1.f) {
nthread:1346:mmclab.cpp:            mesh->med[i].mus *= cfg->unitinmm;
nthread:1347:mmclab.cpp:            mesh->med[i].mua *= cfg->unitinmm;
nthread:1348:mmclab.cpp:    cfg->his.unitinmm = cfg->unitinmm;
nthread:1349:mmclab.cpp:    if (cfg->steps.x != cfg->steps.y || cfg->steps.y != cfg->steps.z) {
nthread:1350:mmclab.cpp:    if (cfg->isextdet) {
nthread:1351:mmclab.cpp:    if (cfg->issavedet && cfg->detnum == 0 && cfg->isextdet == 0) {
nthread:1352:mmclab.cpp:        cfg->issavedet = 0;
nthread:1353:mmclab.cpp:    if (cfg->seed < 0 && cfg->seed != SEED_FROM_FILE) {
nthread:1354:mmclab.cpp:        cfg->seed = time(NULL);
nthread:1355:mmclab.cpp:    if (cfg->issavedet == 0) {
nthread:1356:mmclab.cpp:        cfg->ismomentum = 0;
nthread:1357:mmclab.cpp:        cfg->issaveexit = 0;
nthread:1358:mmclab.cpp:    if (cfg->seed == SEED_FROM_FILE && cfg->his.detected != cfg->nphoton) {
nthread:1359:mmclab.cpp:        cfg->his.detected = 0;
nthread:1360:mmclab.cpp:        if (cfg->replayweight == NULL) {
nthread:1361:mmclab.cpp:        } else if (cfg->replaytime == NULL) {
nthread:1362:mmclab.cpp:    // cfg->his.maxmedia=cfg->medianum-1; /*skip medium 0*/
nthread:1363:mmclab.cpp:    cfg->his.detnum = cfg->detnum;
nthread:1364:mmclab.cpp:    cfg->his.colcount = (1 + (cfg->ismomentum > 0)) * cfg->his.maxmedia + (cfg->issaveexit > 0) * 6 + 1;
nthread:1365:mmc_optix_utils.cpp:    MMC_FPRINTF(cfg->flog, "optix init complete:  \t%d ms\n", GetTimeMillis() - tic0);
nthread:1366:mmc_optix_utils.cpp:    fflush(cfg->flog);
nthread:1367:mmc_optix_utils.cpp:    MMC_FPRINTF(cfg->flog, "optix module complete:  \t%d ms\n", GetTimeMillis() - tic0);
nthread:1368:mmc_optix_utils.cpp:    fflush(cfg->flog);
nthread:1369:mmc_optix_utils.cpp:    MMC_FPRINTF(cfg->flog, "optix device programs complete:  \t%d ms\n",
nthread:1370:mmc_optix_utils.cpp:    fflush(cfg->flog);
nthread:1371:mmc_optix_utils.cpp:    MMC_FPRINTF(cfg->flog, "optix acceleration structure complete:  \t%d ms\n",
nthread:1372:mmc_optix_utils.cpp:    fflush(cfg->flog);
nthread:1373:mmc_optix_utils.cpp:    MMC_FPRINTF(cfg->flog, "optix pipeline complete:  \t%d ms\n",
nthread:1374:mmc_optix_utils.cpp:    fflush(cfg->flog);
nthread:1375:mmc_optix_utils.cpp:    MMC_FPRINTF(cfg->flog, "optix shader binding table complete:  \t%d ms\n",
nthread:1376:mmc_optix_utils.cpp:    fflush(cfg->flog);
nthread:1377:mmc_optix_utils.cpp:    MMC_FPRINTF(cfg->flog, "optix launch parameters complete:  \t%d ms\n",
nthread:1378:mmc_optix_utils.cpp:    fflush(cfg->flog);
nthread:1379:mmc_optix_utils.cpp:    MMC_FPRINTF(cfg->flog, "lauching OptiX for time window [%.1fns %.1fns] ...\n",
nthread:1380:mmc_optix_utils.cpp:        cfg->tstart * 1e9, cfg->tend * 1e9);
nthread:1381:mmc_optix_utils.cpp:    fflush(cfg->flog);
nthread:1382:mmc_optix_utils.cpp:    MMC_FPRINTF(cfg->flog, "kernel complete:  \t%d ms\nretrieving flux ... \t",
nthread:1383:mmc_optix_utils.cpp:    fflush(cfg->flog);
nthread:1384:mmc_optix_utils.cpp:    MMC_FPRINTF(cfg->flog, "transfer complete:        %d ms\n", GetTimeMillis() - tic0);
nthread:1385:mmc_optix_utils.cpp:    fflush(cfg->flog);
nthread:1386:mmc_optix_utils.cpp:    if (cfg->isnormalized) {
nthread:1387:mmc_optix_utils.cpp:        MMC_FPRINTF(cfg->flog, "normalizing raw data ...\t");
nthread:1388:mmc_optix_utils.cpp:        fflush(cfg->flog);
nthread:1389:mmc_optix_utils.cpp:        // not used if cfg->method == rtBLBadouelGrid
nthread:1390:mmc_optix_utils.cpp:        cfg->energyabs = 0.0f;
nthread:1391:mmc_optix_utils.cpp:        cfg->energytot = cfg->nphoton;
nthread:1392:mmc_optix_utils.cpp:        mesh_normalize(mesh, cfg, cfg->energyabs, cfg->energytot, 0);
nthread:1393:mmc_optix_utils.cpp:        MMC_FPRINTF(cfg->flog, "normalization complete:    %d ms\n",
nthread:1394:mmc_optix_utils.cpp:        fflush(cfg->flog);
nthread:1395:mmc_optix_utils.cpp:        if (cfg->issave2pt && cfg->parentid == mpStandalone) {
nthread:1396:mmc_optix_utils.cpp:            MMC_FPRINTF(cfg->flog, "saving data to file ...\t");
nthread:1397:mmc_optix_utils.cpp:            MMC_FPRINTF(cfg->flog, "saving data complete : %d ms\n\n",
nthread:1398:mmc_optix_utils.cpp:            fflush(cfg->flog);
nthread:1399:mmc_optix_utils.cpp:    if (cfg->method != rtBLBadouelGrid) {
nthread:1400:mmc_optix_utils.cpp:    int timeSteps = (int)((cfg->tend - cfg->tstart) / cfg->tstep + 0.5);
nthread:1401:mmc_optix_utils.cpp:        optixcfg->launchParams.medium[i].mua = mesh->med[i].mua;
nthread:1402:mmc_optix_utils.cpp:        optixcfg->launchParams.medium[i].mus = mesh->med[i].mus;
nthread:1403:mmc_optix_utils.cpp:        optixcfg->launchParams.medium[i].g = mesh->med[i].g;
nthread:1404:mmc_optix_utils.cpp:        optixcfg->launchParams.medium[i].n = mesh->med[i].n;
nthread:1405:mmc_optix_utils.cpp:    optixcfg->launchParams.srcpos = make_float3(cfg->srcpos.x,
nthread:1406:mmc_optix_utils.cpp:                                                cfg->srcpos.y,
nthread:1407:mmc_optix_utils.cpp:                                                cfg->srcpos.z);
nthread:1408:mmc_optix_utils.cpp:    optixcfg->launchParams.srcdir = make_float3(cfg->srcdir.x,
nthread:1409:mmc_optix_utils.cpp:                                                cfg->srcdir.y,
nthread:1410:mmc_optix_utils.cpp:                                                cfg->srcdir.z);
nthread:1411:mmc_optix_utils.cpp:    optixcfg->launchParams.nmin = make_float3(mesh->nmin.x,
nthread:1412:mmc_optix_utils.cpp:    optixcfg->launchParams.nmax = make_float3(mesh->nmax.x - mesh->nmin.x,
nthread:1413:mmc_optix_utils.cpp:    optixcfg->launchParams.crop0 = make_uint4(cfg->crop0.x,
nthread:1414:mmc_optix_utils.cpp:                                               cfg->crop0.y,
nthread:1415:mmc_optix_utils.cpp:                                               cfg->crop0.z,
nthread:1416:mmc_optix_utils.cpp:                                               cfg->crop0.z * timeSteps);
nthread:1417:mmc_optix_utils.cpp:    optixcfg->launchParams.dstep = 1.0f / cfg->unitinmm;
nthread:1418:mmc_optix_utils.cpp:    optixcfg->launchParams.tstart = cfg->tstart;
nthread:1419:mmc_optix_utils.cpp:    optixcfg->launchParams.tend = cfg->tend;
nthread:1420:mmc_optix_utils.cpp:    optixcfg->launchParams.Rtstep = 1.0f / cfg->tstep;
nthread:1421:mmc_optix_utils.cpp:    optixcfg->launchParams.maxgate = cfg->maxgate;
nthread:1422:mmc_optix_utils.cpp:    optixcfg->launchParams.mediumid0 = mesh->type[cfg->e0-1];
nthread:1423:mmc_optix_utils.cpp:    optixcfg->launchParams.gashandle0 = optixcfg->gashandles[optixcfg->launchParams.mediumid0];
nthread:1424:mmc_optix_utils.cpp:    optixcfg->launchParams.isreflect = cfg->isreflect;
nthread:1425:mmc_optix_utils.cpp:    optixcfg->launchParams.outputtype = static_cast<int>(cfg->outputtype);
nthread:1426:mmc_optix_utils.cpp:    int totalthread = cfg->nthread;
nthread:1427:mmc_optix_utils.cpp:    gpuid = cfg->deviceid[threadid] - 1;
nthread:1428:mmc_optix_utils.cpp:    if (cfg->autopilot)
nthread:1429:mmc_optix_utils.cpp:    optixcfg->launchWidth = totalthread;
nthread:1430:mmc_optix_utils.cpp:    optixcfg->launchParams.threadphoton = cfg->nphoton / optixcfg->launchWidth;
nthread:1431:mmc_optix_utils.cpp:    optixcfg->launchParams.oddphoton =
nthread:1432:mmc_optix_utils.cpp:        cfg->nphoton - optixcfg->launchParams.threadphoton * totalthread;
nthread:1433:mmc_optix_utils.cpp:    optixcfg->outputBufferSize = (optixcfg->launchParams.crop0.w << 1);
nthread:1434:mmc_optix_utils.cpp:    optixcfg->outputHostBuffer = (float*)calloc(optixcfg->outputBufferSize, sizeof(float));
nthread:1435:mmc_optix_utils.cpp:    optixcfg->outputBuffer.alloc_and_upload(optixcfg->outputHostBuffer,
nthread:1436:mmc_optix_utils.cpp:        optixcfg->outputBufferSize);
nthread:1437:mmc_optix_utils.cpp:    optixcfg->launchParams.outputbuffer = optixcfg->outputBuffer.d_pointer();
nthread:1438:mmc_optix_utils.cpp:    if (cfg->seed > 0) {
nthread:1439:mmc_optix_utils.cpp:        srand(cfg->seed);
nthread:1440:mmc_optix_utils.cpp:    optixcfg->seedBuffer.alloc_and_upload(hseed, totalthread);
nthread:1441:mmc_optix_utils.cpp:    optixcfg->launchParams.seedbuffer = optixcfg->seedBuffer.d_pointer();
nthread:1442:mmc_optix_utils.cpp:    optixcfg->launchParamsBuffer.alloc_and_upload(&optixcfg->launchParams, 1);
nthread:1443:mmc_optix_utils.cpp:    gpuid = cfg->deviceid[threadid] - 1;
nthread:1444:mmc_optix_utils.cpp:    CUDA_ASSERT(cudaStreamCreate(&optixcfg->stream));
nthread:1445:mmc_optix_utils.cpp:    cudaGetDeviceProperties(&optixcfg->deviceProps, gpuid);
nthread:1446:mmc_optix_utils.cpp:    std::cout << "Running on device: " << optixcfg->deviceProps.name << std::endl;
nthread:1447:mmc_optix_utils.cpp:    CUresult cuRes = cuCtxGetCurrent(&optixcfg->cudaContext);
nthread:1448:mmc_optix_utils.cpp:    OPTIX_CHECK(optixDeviceContextCreate(optixcfg->cudaContext, &options,
nthread:1449:mmc_optix_utils.cpp:        &optixcfg->optixContext));
nthread:1450:mmc_optix_utils.cpp:    optixcfg->moduleCompileOptions.maxRegisterCount = OPTIX_COMPILE_DEFAULT_MAX_REGISTER_COUNT;
nthread:1451:mmc_optix_utils.cpp:    optixcfg->moduleCompileOptions.debugLevel = OPTIX_COMPILE_DEBUG_LEVEL_FULL;
nthread:1452:mmc_optix_utils.cpp:    optixcfg->moduleCompileOptions.optLevel = OPTIX_COMPILE_OPTIMIZATION_LEVEL_0;
nthread:1453:mmc_optix_utils.cpp:    optixcfg->moduleCompileOptions.debugLevel = OPTIX_COMPILE_DEBUG_LEVEL_NONE;
nthread:1454:mmc_optix_utils.cpp:    optixcfg->moduleCompileOptions.optLevel = OPTIX_COMPILE_OPTIMIZATION_LEVEL_3;
nthread:1455:mmc_optix_utils.cpp:    optixcfg->pipelineCompileOptions = {};
nthread:1456:mmc_optix_utils.cpp:    optixcfg->pipelineCompileOptions.traversableGraphFlags =
nthread:1457:mmc_optix_utils.cpp:    optixcfg->pipelineCompileOptions.usesMotionBlur     = false;
nthread:1458:mmc_optix_utils.cpp:    optixcfg->pipelineCompileOptions.numPayloadValues   = 16;
nthread:1459:mmc_optix_utils.cpp:    optixcfg->pipelineCompileOptions.numAttributeValues = 2;  // for triangle
nthread:1460:mmc_optix_utils.cpp:    optixcfg->pipelineCompileOptions.exceptionFlags = OPTIX_EXCEPTION_FLAG_DEBUG |
nthread:1461:mmc_optix_utils.cpp:    optixcfg->pipelineCompileOptions.exceptionFlags = OPTIX_EXCEPTION_FLAG_NONE;
nthread:1462:mmc_optix_utils.cpp:    optixcfg->pipelineCompileOptions.pipelineLaunchParamsVariableName = "gcfg";
nthread:1463:mmc_optix_utils.cpp:    optixcfg->pipelineLinkOptions.maxTraceDepth = 1;
nthread:1464:mmc_optix_utils.cpp:    OPTIX_CHECK(optixModuleCreateFromPTX(optixcfg->optixContext,
nthread:1465:mmc_optix_utils.cpp:                                         &optixcfg->moduleCompileOptions,
nthread:1466:mmc_optix_utils.cpp:                                         &optixcfg->pipelineCompileOptions,
nthread:1467:mmc_optix_utils.cpp:                                         &optixcfg->module
nthread:1468:mmc_optix_utils.cpp:    optixcfg->raygenPGs.resize(1);
nthread:1469:mmc_optix_utils.cpp:    pgDesc.raygen.module            = optixcfg->module;
nthread:1470:mmc_optix_utils.cpp:    OPTIX_CHECK(optixProgramGroupCreate(optixcfg->optixContext,
nthread:1471:mmc_optix_utils.cpp:                                        &optixcfg->raygenPGs[0]
nthread:1472:mmc_optix_utils.cpp:    optixcfg->missPGs.resize(1);
nthread:1473:mmc_optix_utils.cpp:    pgDesc.raygen.module            = optixcfg->module;
nthread:1474:mmc_optix_utils.cpp:    OPTIX_CHECK(optixProgramGroupCreate(optixcfg->optixContext,
nthread:1475:mmc_optix_utils.cpp:                                        &optixcfg->missPGs[0]
nthread:1476:mmc_optix_utils.cpp:    optixcfg->hitgroupPGs.resize(1);
nthread:1477:mmc_optix_utils.cpp:    pgDesc.hitgroup.moduleCH            = optixcfg->module;
nthread:1478:mmc_optix_utils.cpp:    OPTIX_CHECK(optixProgramGroupCreate(optixcfg->optixContext,
nthread:1479:mmc_optix_utils.cpp:                                        &optixcfg->hitgroupPGs[0]
nthread:1480:mmc_optix_utils.cpp:    optixcfg->vertexBuffer.alloc_and_upload(tmesh->fnode, tmesh->nn);
nthread:1481:mmc_optix_utils.cpp:    optixcfg->indexBuffer.alloc_and_upload(smesh->face);
nthread:1482:mmc_optix_utils.cpp:    CUdeviceptr d_vertices = optixcfg->vertexBuffer.d_pointer();
nthread:1483:mmc_optix_utils.cpp:    CUdeviceptr d_indices  = optixcfg->indexBuffer.d_pointer();
nthread:1484:mmc_optix_utils.cpp:                (optixcfg->optixContext,
nthread:1485:mmc_optix_utils.cpp:    OPTIX_CHECK(optixAccelBuild(optixcfg->optixContext,
nthread:1486:mmc_optix_utils.cpp:                                optixcfg->stream,
nthread:1487:mmc_optix_utils.cpp:    optixcfg->asBuffer.alloc(compactedSize);
nthread:1488:mmc_optix_utils.cpp:    OPTIX_CHECK(optixAccelCompact(optixcfg->optixContext,
nthread:1489:mmc_optix_utils.cpp:                                  optixcfg->stream,
nthread:1490:mmc_optix_utils.cpp:                                  optixcfg->asBuffer.d_pointer(),
nthread:1491:mmc_optix_utils.cpp:                                  optixcfg->asBuffer.sizeInBytes,
nthread:1492:mmc_optix_utils.cpp:    for (auto pg : optixcfg->raygenPGs)
nthread:1493:mmc_optix_utils.cpp:    for (auto pg : optixcfg->missPGs)
nthread:1494:mmc_optix_utils.cpp:    for (auto pg : optixcfg->hitgroupPGs)
nthread:1495:mmc_optix_utils.cpp:    OPTIX_CHECK(optixPipelineCreate(optixcfg->optixContext,
nthread:1496:mmc_optix_utils.cpp:                                    &optixcfg->pipelineCompileOptions,
nthread:1497:mmc_optix_utils.cpp:                                    &optixcfg->pipelineLinkOptions,
nthread:1498:mmc_optix_utils.cpp:                                    &optixcfg->pipeline
nthread:1499:mmc_optix_utils.cpp:    for (size_t i = 0;i < optixcfg->raygenPGs.size();i++) {
nthread:1500:mmc_optix_utils.cpp:      OPTIX_CHECK(optixSbtRecordPackHeader(optixcfg->raygenPGs[i],&rec));
nthread:1501:mmc_optix_utils.cpp:    optixcfg->raygenRecordsBuffer.alloc_and_upload(raygenRecords);
nthread:1502:mmc_optix_utils.cpp:    optixcfg->sbt.raygenRecord = optixcfg->raygenRecordsBuffer.d_pointer();
nthread:1503:mmc_optix_utils.cpp:    for (size_t i = 0;i < optixcfg->missPGs.size();i++) {
nthread:1504:mmc_optix_utils.cpp:      OPTIX_CHECK(optixSbtRecordPackHeader(optixcfg->missPGs[i],&rec));
nthread:1505:mmc_optix_utils.cpp:    optixcfg->missRecordsBuffer.alloc_and_upload(missRecords);
nthread:1506:mmc_optix_utils.cpp:    optixcfg->sbt.missRecordBase          = optixcfg->missRecordsBuffer.d_pointer();
nthread:1507:mmc_optix_utils.cpp:    optixcfg->sbt.missRecordStrideInBytes = sizeof(MissRecord);
nthread:1508:mmc_optix_utils.cpp:    optixcfg->sbt.missRecordCount         = (int)missRecords.size();
nthread:1509:mmc_optix_utils.cpp:    OPTIX_CHECK(optixSbtRecordPackHeader(optixcfg->hitgroupPGs[0],&rec));
nthread:1510:mmc_optix_utils.cpp:            nbgashandle.push_back(optixcfg->gashandles[smesh[i].nbtype[j]]);
nthread:1511:mmc_optix_utils.cpp:    optixcfg->fnormBuffer.alloc_and_upload(fnorm);
nthread:1512:mmc_optix_utils.cpp:    optixcfg->nbgashandleBuffer.alloc_and_upload(nbgashandle);
nthread:1513:mmc_optix_utils.cpp:    rec.data.fnorm = (float4*)optixcfg->fnormBuffer.d_pointer();
nthread:1514:mmc_optix_utils.cpp:    rec.data.nbgashandle = (OptixTraversableHandle*)optixcfg->nbgashandleBuffer.d_pointer();
nthread:1515:mmc_optix_utils.cpp:    optixcfg->hitgroupRecordsBuffer.alloc_and_upload(hitgroupRecords);
nthread:1516:mmc_optix_utils.cpp:    optixcfg->sbt.hitgroupRecordBase          = optixcfg->hitgroupRecordsBuffer.d_pointer();
nthread:1517:mmc_optix_utils.cpp:    optixcfg->sbt.hitgroupRecordStrideInBytes = sizeof(HitgroupRecord);
nthread:1518:mmc_optix_utils.cpp:    optixcfg->sbt.hitgroupRecordCount         = (int)hitgroupRecords.size();
nthread:1519:mmc_optix_utils.cpp:    optixcfg->raygenRecordsBuffer.free();
nthread:1520:mmc_optix_utils.cpp:    optixcfg->missRecordsBuffer.free();
nthread:1521:mmc_optix_utils.cpp:    optixcfg->hitgroupRecordsBuffer.free();
nthread:1522:mmc_optix_utils.cpp:    optixcfg->launchParamsBuffer.free();
nthread:1523:mmc_optix_utils.cpp:    optixcfg->vertexBuffer.free();
nthread:1524:mmc_optix_utils.cpp:    optixcfg->indexBuffer.free();
nthread:1525:mmc_optix_utils.cpp:    optixcfg->fnormBuffer.free();
nthread:1526:mmc_optix_utils.cpp:    optixcfg->nbgashandleBuffer.free();
nthread:1527:mmc_optix_utils.cpp:    optixcfg->asBuffer.free();
nthread:1528:mmc_optix_utils.cpp:    optixcfg->seedBuffer.free();
nthread:1529:mmc_optix_utils.cpp:    optixcfg->outputBuffer.free();
nthread:1530:mmc_optix_utils.cpp:    free(optixcfg->outputHostBuffer);
nthread:1531:mmc_cl_host.c:    cl_uint meshlen = ((cfg->method == rtBLBadouelGrid) ? cfg->crop0.z : mesh->ne) << cfg->nbuffer; // use 4 copies to reduce racing
nthread:1532:mmc_cl_host.c:    cfg->crop0.w = meshlen * cfg->maxgate; // offset for the second buffer
nthread:1533:mmc_cl_host.c:    cl_uint detreclen = (2 + ((cfg->ismomentum) > 0)) * mesh->prop + (cfg->issaveexit > 0) * 6 + 1;
nthread:1534:mmc_cl_host.c:    MCXParam param = {{{cfg->srcpos.x, cfg->srcpos.y, cfg->srcpos.z}}, {{cfg->srcdir.x, cfg->srcdir.y, cfg->srcdir.z}},
nthread:1535:mmc_cl_host.c:        cfg->tstart, cfg->tend, (uint)cfg->isreflect, (uint)cfg->issavedet, (uint)cfg->issaveexit,
nthread:1536:mmc_cl_host.c:        (uint)cfg->ismomentum, (uint)cfg->isatomic, (uint)cfg->isspecular, 1.f / cfg->tstep, cfg->minenergy,
nthread:1537:mmc_cl_host.c:        cfg->maxdetphoton, mesh->prop, cfg->detnum, (uint)cfg->voidtime, (uint)cfg->srctype,
nthread:1538:mmc_cl_host.c:        {{cfg->srcparam1.x, cfg->srcparam1.y, cfg->srcparam1.z, cfg->srcparam1.w}},
nthread:1539:mmc_cl_host.c:        {{cfg->srcparam2.x, cfg->srcparam2.y, cfg->srcparam2.z, cfg->srcparam2.w}},
nthread:1540:mmc_cl_host.c:        cfg->issaveref, cfg->maxgate, (uint)cfg->debuglevel, detreclen, cfg->outputtype, mesh->elemlen,
nthread:1541:mmc_cl_host.c:        cfg->mcmethod, cfg->method, 1.f / cfg->steps.x,
nthread:1542:mmc_cl_host.c:        cfg->srcdir.w,
nthread:1543:mmc_cl_host.c:        mesh->nn, mesh->ne, mesh->nf, {{mesh->nmin.x, mesh->nmin.y, mesh->nmin.z}}, cfg->nout,
nthread:1544:mmc_cl_host.c:        cfg->roulettesize, cfg->srcnum, {{cfg->crop0.x, cfg->crop0.y, cfg->crop0.z, cfg->crop0.w}},
nthread:1545:mmc_cl_host.c:        mesh->srcelemlen, {{cfg->bary0.x, cfg->bary0.y, cfg->bary0.z, cfg->bary0.w}},
nthread:1546:mmc_cl_host.c:        cfg->e0, cfg->isextdet, meshlen, cfg->nbuffer, (mesh->prop + 1 + cfg->isextdet) + cfg->detnum,
nthread:1547:mmc_cl_host.c:        cfg->issaveseed, cfg->seed
nthread:1548:mmc_cl_host.c:        cfg->debuglevel = cfg->debuglevel & (~MCX_DEBUG_PROGRESS);
nthread:1549:mmc_cl_host.c:        if (!cfg->autopilot) {
nthread:1550:mmc_cl_host.c:            gpu[i].autothread = cfg->nthread;
nthread:1551:mmc_cl_host.c:            gpu[i].autoblock = cfg->nblocksize;
nthread:1552:mmc_cl_host.c:            gpu[i].maxgate = cfg->maxgate;
nthread:1553:mmc_cl_host.c:            int needmem = meshlen + gpu[i].autothread * sizeof(float4) * 4 + sizeof(float) * cfg->maxdetphoton * hostdetreclen + 10 * 1024 * 1024; /*keep 10M for other things*/
nthread:1554:mmc_cl_host.c:            gpu[i].maxgate = MIN(((cfg->tend - cfg->tstart) / cfg->tstep + 0.5), gpu[i].maxgate);
nthread:1555:mmc_cl_host.c:    cfg->maxgate = (int)((cfg->tend - cfg->tstart) / cfg->tstep + 0.5);
nthread:1556:mmc_cl_host.c:    param.maxgate = cfg->maxgate;
nthread:1557:mmc_cl_host.c:    cl_uint nflen = mesh->nf * cfg->maxgate;
nthread:1558:mmc_cl_host.c:        fullload += cfg->workload[i];
nthread:1559:mmc_cl_host.c:            cfg->workload[i] = gpu[i].core;
nthread:1560:mmc_cl_host.c:    field = (cl_float*)calloc(sizeof(cl_float) * meshlen * 2, cfg->maxgate);
nthread:1561:mmc_cl_host.c:    dref = (cl_float*)calloc(sizeof(cl_float) * mesh->nf, cfg->maxgate);
nthread:1562:mmc_cl_host.c:    Pdet = (float*)calloc(cfg->maxdetphoton * sizeof(float), hostdetreclen);
nthread:1563:mmc_cl_host.c:    if (cfg->issaveseed) {
nthread:1564:mmc_cl_host.c:        Pphotonseed = (RandType*)calloc(cfg->maxdetphoton, (sizeof(RandType) * RAND_BUF_LEN));
nthread:1565:mmc_cl_host.c:    fieldlen = meshlen * cfg->maxgate;
nthread:1566:mmc_cl_host.c:    if (cfg->seed > 0) {
nthread:1567:mmc_cl_host.c:        srand(cfg->seed);
nthread:1568:mmc_cl_host.c:    memcpy(propdet, mesh->med, (mesh->prop + 1 + cfg->isextdet)*sizeof(medium));
nthread:1569:mmc_cl_host.c:    if (cfg->detpos && cfg->detnum) {
nthread:1570:mmc_cl_host.c:        memcpy(propdet + (mesh->prop + 1 + cfg->isextdet), cfg->detpos, cfg->detnum * sizeof(float4));
nthread:1571:mmc_cl_host.c:        OCL_ASSERT(((gdetphoton[i] = clCreateBuffer(mcxcontext, RW_MEM, sizeof(float) * cfg->maxdetphoton * hostdetreclen, Pdet, &status), status)));
nthread:1572:mmc_cl_host.c:        if (cfg->issaveseed) {
nthread:1573:mmc_cl_host.c:            OCL_ASSERT(((gphotonseed[i] = clCreateBuffer(mcxcontext, RW_MEM, cfg->maxdetphoton * (sizeof(RandType) * RAND_BUF_LEN), Pphotonseed, &status), status)));
nthread:1574:mmc_cl_host.c:        if (cfg->srctype == MCX_SRC_PATTERN) {
nthread:1575:mmc_cl_host.c:            OCL_ASSERT(((gsrcpattern[i] = clCreateBuffer(mcxcontext, RO_MEM, sizeof(float) * (int)(cfg->srcparam1.w * cfg->srcparam2.w), cfg->srcpattern, &status), status)));
nthread:1576:mmc_cl_host.c:        } else if (cfg->srctype == MCX_SRC_PATTERN3D) {
nthread:1577:mmc_cl_host.c:            OCL_ASSERT(((gsrcpattern[i] = clCreateBuffer(mcxcontext, RO_MEM, sizeof(float) * (int)(cfg->srcparam1.x * cfg->srcparam1.y * cfg->srcparam1.z), cfg->srcpattern, &status), status)));
nthread:1578:mmc_cl_host.c:        if (cfg->seed == SEED_FROM_FILE) {
nthread:1579:mmc_cl_host.c:            OCL_ASSERT(((greplayweight[i] = clCreateBuffer(mcxcontext, RO_MEM, sizeof(float) * cfg->nphoton, cfg->replayweight, &status), status)));
nthread:1580:mmc_cl_host.c:            OCL_ASSERT(((greplaytime[i] = clCreateBuffer(mcxcontext, RO_MEM, sizeof(float) * cfg->nphoton, cfg->replaytime, &status), status)));
nthread:1581:mmc_cl_host.c:            OCL_ASSERT(((greplayseed[i] = clCreateBuffer(mcxcontext, RO_MEM, (sizeof(RandType) * RAND_BUF_LEN) * cfg->nphoton, cfg->photonseed, &status), status)));
nthread:1582:mmc_cl_host.c:    if (cfg->issavedet) {
nthread:1583:mmc_cl_host.c:        MMC_FPRINTF(cfg->flog, "- variant name: [%s] compiled with OpenCL version [%d]\n",
nthread:1584:mmc_cl_host.c:        MMC_FPRINTF(cfg->flog, "- code name: [MMC-OpenCL] compiled with OpenCL version [%d]\n",
nthread:1585:mmc_cl_host.c:    MMC_FPRINTF(cfg->flog, "- compiled with: [RNG] %s [Seed Length] %d\n", MCX_RNG_NAME, RAND_SEED_WORD_LEN);
nthread:1586:mmc_cl_host.c:    MMC_FPRINTF(cfg->flog, "initializing streams ...\t");
nthread:1587:mmc_cl_host.c:    MMC_FPRINTF(cfg->flog, "init complete : %d ms\n", GetTimeMillis() - tic);
nthread:1588:mmc_cl_host.c:    fflush(cfg->flog);
nthread:1589:mmc_cl_host.c:    OCL_ASSERT(((mcxprogram = clCreateProgramWithSource(mcxcontext, 1, (const char**) & (cfg->clsource), NULL, &status), status)));
nthread:1590:mmc_cl_host.c:    if (cfg->optlevel >= 1) {
nthread:1591:mmc_cl_host.c:    if (cfg->optlevel >= 3) {
nthread:1592:mmc_cl_host.c:    if (cfg->optlevel >= 4) {
nthread:1593:mmc_cl_host.c:    if ((uint)cfg->srctype < sizeof(sourceflag) / sizeof(sourceflag[0])) {
nthread:1594:mmc_cl_host.c:        sprintf(opt + strlen(opt), "%s ", sourceflag[(uint)cfg->srctype]);
nthread:1595:mmc_cl_host.c:    sprintf(opt + strlen(opt), "%s ", cfg->compileropt);
nthread:1596:mmc_cl_host.c:    if (cfg->isatomic) {
nthread:1597:mmc_cl_host.c:    if (cfg->issave2pt == 0) {
nthread:1598:mmc_cl_host.c:    if (cfg->issavedet) {
nthread:1599:mmc_cl_host.c:    if (cfg->issaveref) {
nthread:1600:mmc_cl_host.c:    if (cfg->issaveseed) {
nthread:1601:mmc_cl_host.c:    if (cfg->isreflect) {
nthread:1602:mmc_cl_host.c:    if (cfg->method == rtBLBadouelGrid) {
nthread:1603:mmc_cl_host.c:    if (cfg->method == rtBLBadouel) {
nthread:1604:mmc_cl_host.c:    MMC_FPRINTF(cfg->flog, "Building kernel with option: %s\n", opt);
nthread:1605:mmc_cl_host.c:                MMC_FPRINTF(cfg->flog, "Kernel build log:\n%s\n", msg);
nthread:1606:mmc_cl_host.c:    MMC_FPRINTF(cfg->flog, "build program complete : %d ms\n", GetTimeMillis() - tic);
nthread:1607:mmc_cl_host.c:    fflush(cfg->flog);
nthread:1608:mmc_cl_host.c:        threadphoton = (int)(cfg->nphoton * cfg->workload[i] / (fullload * gpu[i].autothread * cfg->respin));
nthread:1609:mmc_cl_host.c:        oddphotons = (int)(cfg->nphoton * cfg->workload[i] / (fullload * cfg->respin) - threadphoton * gpu[i].autothread);
nthread:1610:mmc_cl_host.c:        MMC_FPRINTF(cfg->flog, "- [device %d(%d): %s] threadph=%d oddphotons=%d np=%.1f nthread=%d nblock=%d repetition=%d\n", i, gpu[i].id, gpu[i].name, threadphoton, oddphotons,
nthread:1611:mmc_cl_host.c:                    cfg->nphoton * cfg->workload[i] / fullload, (int)gpu[i].autothread, (int)gpu[i].autoblock, cfg->respin);
nthread:1612:mmc_cl_host.c:        OCL_ASSERT((clSetKernelArg(mcxkernel[i], 3, cfg->issavedet ? sizeof(cl_float) * ((int)gpu[i].autoblock)*detreclen : sizeof(int), NULL)));
nthread:1613:mmc_cl_host.c:    MMC_FPRINTF(cfg->flog, "set kernel arguments complete : %d ms %d\n", GetTimeMillis() - tic, param.method);
nthread:1614:mmc_cl_host.c:    fflush(cfg->flog);
nthread:1615:mmc_cl_host.c:    if (cfg->exportfield == NULL) {
nthread:1616:mmc_cl_host.c:        cfg->exportfield = mesh->weight;
nthread:1617:mmc_cl_host.c:    if (cfg->exportdetected == NULL) {
nthread:1618:mmc_cl_host.c:        cfg->exportdetected = (float*)malloc(hostdetreclen * cfg->maxdetphoton * sizeof(float));
nthread:1619:mmc_cl_host.c:    if (cfg->issaveseed && cfg->exportseed == NULL) {
nthread:1620:mmc_cl_host.c:        cfg->exportseed = (unsigned char*)malloc(cfg->maxdetphoton * (sizeof(RandType) * RAND_BUF_LEN));
nthread:1621:mmc_cl_host.c:    cfg->energytot = 0.f;
nthread:1622:mmc_cl_host.c:    cfg->energyesc = 0.f;
nthread:1623:mmc_cl_host.c:    cfg->runtime = 0;
nthread:1624:mmc_cl_host.c:    for (t = cfg->tstart; t < cfg->tend; t += cfg->tstep * cfg->maxgate) {
nthread:1625:mmc_cl_host.c:        twindow1 = t + cfg->tstep * cfg->maxgate;
nthread:1626:mmc_cl_host.c:        MMC_FPRINTF(cfg->flog, "lauching mcx_main_loop for time window [%.1fns %.1fns] ...\n"
nthread:1627:mmc_cl_host.c:        fflush(cfg->flog);
nthread:1628:mmc_cl_host.c:        for (iter = 0; iter < cfg->respin; iter++) {
nthread:1629:mmc_cl_host.c:            MMC_FPRINTF(cfg->flog, "simulation run#%2d ... \n", iter + 1);
nthread:1630:mmc_cl_host.c:            fflush(cfg->flog);
nthread:1631:mmc_cl_host.c:            fflush(cfg->flog);
nthread:1632:mmc_cl_host.c:            if ((cfg->debuglevel & MCX_DEBUG_PROGRESS)) {
nthread:1633:mmc_cl_host.c:                progressfun(cfg->nphoton, handle);
nthread:1634:mmc_cl_host.c:                MMC_FPRINTF(cfg->flog, "\n");
nthread:1635:mmc_cl_host.c:            MMC_FPRINTF(cfg->flog, "kernel complete:  \t%d ms\nretrieving flux ... \t", tic1 - tic);
nthread:1636:mmc_cl_host.c:            fflush(cfg->flog);
nthread:1637:mmc_cl_host.c:            if (cfg->runtime < tic1 - tic) {
nthread:1638:mmc_cl_host.c:                cfg->runtime = tic1 - tic;
nthread:1639:mmc_cl_host.c:                if (cfg->issavedet) {
nthread:1640:mmc_cl_host.c:                    OCL_ASSERT((clEnqueueReadBuffer(mcxqueue[devid], gdetphoton[devid], CL_TRUE, 0, sizeof(float)*cfg->maxdetphoton * hostdetreclen,
nthread:1641:mmc_cl_host.c:                    if (cfg->issaveseed) {
nthread:1642:mmc_cl_host.c:                        OCL_ASSERT((clEnqueueReadBuffer(mcxqueue[devid], gphotonseed[devid], CL_TRUE, 0, cfg->maxdetphoton * (sizeof(RandType)*RAND_BUF_LEN),
nthread:1643:mmc_cl_host.c:                    if (detected > cfg->maxdetphoton) {
nthread:1644:mmc_cl_host.c:                        MMC_FPRINTF(cfg->flog, "WARNING: the detected photon (%d) \
nthread:1645:mmc_cl_host.c:                                    , detected, cfg->maxdetphoton);
nthread:1646:mmc_cl_host.c:                        MMC_FPRINTF(cfg->flog, "detected %d photons, total: %d\t", detected, cfg->detectedcount + detected);
nthread:1647:mmc_cl_host.c:                    cfg->his.detected += detected;
nthread:1648:mmc_cl_host.c:                    detected = MIN(detected, cfg->maxdetphoton);
nthread:1649:mmc_cl_host.c:                    if (cfg->exportdetected) {
nthread:1650:mmc_cl_host.c:                        cfg->exportdetected = (float*)realloc(cfg->exportdetected, (cfg->detectedcount + detected) * hostdetreclen * sizeof(float));
nthread:1651:mmc_cl_host.c:                        memcpy(cfg->exportdetected + cfg->detectedcount * (hostdetreclen), Pdet, detected * (hostdetreclen)*sizeof(float));
nthread:1652:mmc_cl_host.c:                        if (cfg->issaveseed) {
nthread:1653:mmc_cl_host.c:                            cfg->exportseed = (unsigned char*)realloc(cfg->exportseed, (cfg->detectedcount + detected) * (sizeof(RandType) * RAND_BUF_LEN));
nthread:1654:mmc_cl_host.c:                            memcpy(cfg->exportseed + cfg->detectedcount * sizeof(RandType)*RAND_BUF_LEN, Pphotonseed, detected * (sizeof(RandType)*RAND_BUF_LEN));
nthread:1655:mmc_cl_host.c:                        cfg->detectedcount += detected;
nthread:1656:mmc_cl_host.c:                if (cfg->issaveref) {
nthread:1657:mmc_cl_host.c:                if (cfg->issave2pt) {
nthread:1658:mmc_cl_host.c:                    MMC_FPRINTF(cfg->flog, "transfer complete:        %d ms\n", GetTimeMillis() - tic);
nthread:1659:mmc_cl_host.c:                    fflush(cfg->flog);
nthread:1660:mmc_cl_host.c:                        field[(i >> cfg->nbuffer)] += rawfield[i] + rawfield[i + fieldlen];    //+rawfield[i+fieldlen];
nthread:1661:mmc_cl_host.c:                    /*          if(cfg->respin>1){
nthread:1662:mmc_cl_host.c:                                if(iter+1==cfg->respin){
nthread:1663:mmc_cl_host.c:                                        if(cfg->respin>1)  //copy the accumulated fields back
nthread:1664:mmc_cl_host.c:                        cfg->energyesc += energy[(i << 1)];
nthread:1665:mmc_cl_host.c:                        cfg->energytot += energy[(i << 1) + 1];
nthread:1666:mmc_cl_host.c:                if (cfg->respin > 1 && RAND_SEED_WORD_LEN > 1) {
nthread:1667:mmc_cl_host.c:    fieldlen = (fieldlen >> cfg->nbuffer);
nthread:1668:mmc_cl_host.c:    if (cfg->exportfield) {
nthread:1669:mmc_cl_host.c:        if (cfg->basisorder == 0 || cfg->method == rtBLBadouelGrid) {
nthread:1670:mmc_cl_host.c:                cfg->exportfield[i] += field[i];
nthread:1671:mmc_cl_host.c:            for (i = 0; i < cfg->maxgate; i++)
nthread:1672:mmc_cl_host.c:                        cfg->exportfield[i * mesh->nn + mesh->elem[j * mesh->elemlen + k] - 1] += ww;
nthread:1673:mmc_cl_host.c:    if (cfg->issaveref && mesh->dref) {
nthread:1674:mmc_cl_host.c:    if (cfg->isnormalized) {
nthread:1675:mmc_cl_host.c:        MMC_FPRINTF(cfg->flog, "normalizing raw data ...\t");
nthread:1676:mmc_cl_host.c:        fflush(cfg->flog);
nthread:1677:mmc_cl_host.c:        cfg->energyabs = cfg->energytot - cfg->energyesc;
nthread:1678:mmc_cl_host.c:        mesh_normalize(mesh, cfg, cfg->energyabs, cfg->energytot, 0);
nthread:1679:mmc_cl_host.c:    if (cfg->issave2pt && cfg->parentid == mpStandalone) {
nthread:1680:mmc_cl_host.c:        MMC_FPRINTF(cfg->flog, "saving data to file ...\t");
nthread:1681:mmc_cl_host.c:        MMC_FPRINTF(cfg->flog, "saving data complete : %d ms\n\n", GetTimeMillis() - tic);
nthread:1682:mmc_cl_host.c:        fflush(cfg->flog);
nthread:1683:mmc_cl_host.c:    if (cfg->issavedet && cfg->parentid == mpStandalone && cfg->exportdetected) {
nthread:1684:mmc_cl_host.c:        cfg->his.unitinmm = cfg->unitinmm;
nthread:1685:mmc_cl_host.c:        cfg->his.savedphoton = cfg->detectedcount;
nthread:1686:mmc_cl_host.c:        cfg->his.detected = cfg->detectedcount;
nthread:1687:mmc_cl_host.c:        mesh_savedetphoton(cfg->exportdetected, (void*)(cfg->exportseed), cfg->detectedcount, (sizeof(RandType)*RAND_BUF_LEN), cfg);
nthread:1688:mmc_cl_host.c:    if (cfg->issaveref) {
nthread:1689:mmc_cl_host.c:        MMC_FPRINTF(cfg->flog, "saving surface diffuse reflectance ...");
nthread:1690:mmc_cl_host.c:    MMC_FPRINTF(cfg->flog, "simulated %zu photons (%zu) with %d devices (ray-tet %.0f)\nMCX simulation speed: %.2f photon/ms\n",
nthread:1691:mmc_cl_host.c:                cfg->nphoton, cfg->nphoton, workdev, reporter.raytet, (double)cfg->nphoton / toc);
nthread:1692:mmc_cl_host.c:    MMC_FPRINTF(cfg->flog, "total simulated energy: %.2f\tabsorbed: %5.5f%%\n(loss due to initial specular reflection is excluded in the total)\n",
nthread:1693:mmc_cl_host.c:                cfg->energytot, (cfg->energytot - cfg->energyesc) / cfg->energytot * 100.f);
nthread:1694:mmc_cl_host.c:    fflush(cfg->flog);
nthread:1695:mmc_host.c:    if (cfg->isgpuinfo == 0) {
nthread:1696:mmc_host.c:    tracer_init(tracer, mesh, cfg->method);
nthread:1697:mmc_host.c:    tracer_init(tracer, mesh, cfg->method);
nthread:1698:mmc_host.c:        cfg->debuglevel = cfg->debuglevel & (~dlProgress);
nthread:1699:mmc_host.c:    cfg->issaveseed = 0;
nthread:1700:mmc_host.c:    MMCDEBUG(cfg, dlTime, (cfg->flog, "seed=%u\nsimulating ... \n", cfg->seed));
nthread:1701:mmc_host.c:    if (cfg->debugphoton >= 0) {
nthread:1702:mmc_host.c:        debuglevel = cfg->debuglevel;
nthread:1703:mmc_host.c:        cfg->debuglevel &= 0xFFFFEA00;
nthread:1704:mmc_host.c:        visitor visit = {0.f, 0.f, 1.f / cfg->tstep, DET_PHOTON_BUF, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL};
nthread:1705:mmc_host.c:            srand(cfg->seed);
nthread:1706:mmc_host.c:        visit.reclen = (2 + ((cfg->ismomentum) > 0)) * mesh->prop + (cfg->issaveexit > 0) * 6 + 2;
nthread:1707:mmc_host.c:        if (cfg->issavedet) {
nthread:1708:mmc_host.c:            if (cfg->issaveseed) {
nthread:1709:mmc_host.c:        if ((cfg->debuglevel & dlProgress) && threadid == 0) {
nthread:1710:mmc_host.c:        for (id = 0; id < cfg->nphoton; id++) {
nthread:1711:mmc_host.c:            if (id == cfg->debugphoton) {
nthread:1712:mmc_host.c:                cfg->debuglevel = debuglevel;
nthread:1713:mmc_host.c:            if (cfg->seed == SEED_FROM_FILE) {
nthread:1714:mmc_host.c:                onephoton(id, tracer, mesh, cfg, ((RandType*)cfg->photonseed) + id * RAND_BUF_LEN, ran1, &visit);
nthread:1715:mmc_host.c:            if (id == cfg->debugphoton) {
nthread:1716:mmc_host.c:                cfg->debuglevel &= 0xFFFFEA00;
nthread:1717:mmc_host.c:            if ((cfg->debuglevel & dlProgress) && threadid == 0) {
nthread:1718:mmc_host.c:                progressfun((float)ncomplete / cfg->nphoton, handle);
nthread:1719:mmc_host.c:        for (j = 0; j < cfg->srcnum; j++) {
nthread:1720:mmc_host.c:        if (cfg->issavedet) {
nthread:1721:mmc_host.c:                if (cfg->issaveseed) {
nthread:1722:mmc_host.c:                if (cfg->issaveseed)
nthread:1723:mmc_host.c:        if (cfg->issaveseed && visit.photonseed) {
nthread:1724:mmc_host.c:    if ((cfg->debuglevel & dlProgress)) {
nthread:1725:mmc_host.c:    MMCDEBUG(cfg, dlProgress, (cfg->flog, "\n"));
nthread:1726:mmc_host.c:    MMCDEBUG(cfg, dlTime, (cfg->flog, "\tdone\t%d\n", dt));
nthread:1727:mmc_host.c:    MMCDEBUG(cfg, dlTime, (cfg->flog, "speed ...\t"S_BOLD""S_BLUE"%.2f photon/ms"S_RESET", %.0f ray-tetrahedron tests (%.0f overhead, %.2f test/ms)\n", (double)cfg->nphoton / dt, raytri, raytri0, raytri / dt));
nthread:1728:mmc_host.c:    if (cfg->issavedet) {
nthread:1729:mmc_host.c:        MMC_FPRINTF(cfg->flog, "detected %d photons\n", master.detcount);
nthread:1730:mmc_host.c:    if (cfg->isnormalized) {
nthread:1731:mmc_host.c:        for (j = 0; j < cfg->srcnum; j++) {
nthread:1732:mmc_host.c:            MMCDEBUG(cfg, dlTime, (cfg->flog, "source %d\ttotal simulated energy: %f\tabsorbed: "S_BOLD""S_BLUE"%5.5f%%"S_RESET"\tnormalizor=%g\n",
nthread:1733:mmc_host.c:        cfg->his.normalizer = sum_normalizer / cfg->srcnum; // average normalizer value for all simulated sources
nthread:1734:mmc_host.c:    if (cfg->issave2pt) {
nthread:1735:mmc_host.c:        switch (cfg->outputtype) {
nthread:1736:mmc_host.c:                MMCDEBUG(cfg, dlTime, (cfg->flog, "saving flux ..."));
nthread:1737:mmc_host.c:                MMCDEBUG(cfg, dlTime, (cfg->flog, "saving fluence ..."));
nthread:1738:mmc_host.c:                MMCDEBUG(cfg, dlTime, (cfg->flog, "saving energy deposit ..."));
nthread:1739:mmc_host.c:    if (cfg->issavedet) {
nthread:1740:mmc_host.c:        MMCDEBUG(cfg, dlTime, (cfg->flog, "saving detected photons ..."));
nthread:1741:mmc_host.c:        if (cfg->issaveexit) {
nthread:1742:mmc_host.c:        if (cfg->issaveexit == 2) {
nthread:1743:mmc_host.c:            float* detimage = (float*)calloc(cfg->detparam1.w * cfg->detparam2.w * cfg->maxgate, sizeof(float));
nthread:1744:mmc_host.c:        if (cfg->issaveseed && master.photonseed) {
nthread:1745:mmc_host.c:            cfg->exportseed = (unsigned char*)malloc(cfg->detectedcount * sizeof(RandType) * RAND_BUF_LEN);
nthread:1746:mmc_host.c:            memcpy(cfg->exportseed, master.photonseed, cfg->detectedcount * sizeof(RandType)*RAND_BUF_LEN);
nthread:1747:mmc_host.c:    if (cfg->issaveref) {
nthread:1748:mmc_host.c:        MMCDEBUG(cfg, dlTime, (cfg->flog, "saving surface diffuse reflectance ..."));
nthread:1749:mmc_host.c:    MMCDEBUG(cfg, dlTime, (cfg->flog, "\tdone\t%d\n", GetTimeMillis() - t0));
nthread:1750:mmc_highorder.cpp:    mesh->weight = (double*)realloc((void*)mesh->weight, sizeof(double) * mesh->nn * cfg->maxgate);
nthread:1751:mmc_highorder.cpp:    memset(mesh->weight, 0, sizeof(double)*mesh->nn * cfg->maxgate); // if mesh->weight is filled, need to allocate a new buffer, and copy the old buffer gate by gate
mexopts_msys2_gcc.xml:1:<?xml version="1.0" encoding="UTF-8" ?>
mexopts_msys2_gcc.xml:4:    ShortName = "mingw64-g++"
mexopts_msys2_gcc.xml:24:        CompilerDefineFormatter="-D%s"
mexopts_msys2_gcc.xml:25:        LinkerLibrarySwitchFormatter="-l%s;-llib%s"
mexopts_msys2_gcc.xml:26:        LinkerPathFormatter="-L%s"
mexopts_msys2_gcc.xml:30:        CMDLINE1="$CXX -c $DEFINES $INCLUDE $CXXFLAGS $OPTIM $SRC -o $OBJ"
mexopts_msys2_gcc.xml:31:        CMDLINE2="$LDXX $LDFLAGS $LDTYPE $LINKOPTIM $LINKEXPORTVER $OBJS $CXXLIBS $LINKLIBS -o $EXE"
mexopts_msys2_gcc.xml:35:        DEFINES="-m64 $MATLABMEX"
mexopts_msys2_gcc.xml:36:        MATLABMEX="-DMATLAB_MEX_FILE "
mexopts_msys2_gcc.xml:37:        CFLAGS="$COMPFLAGS -fexceptions -fno-omit-frame-pointer"
mexopts_msys2_gcc.xml:39:        INCLUDE="-I&quot;$MINGWROOT\usr\include&quot; -I&quot;$MATLABROOT/extern/include&quot; -I&quot;$MATLABROOT/simulink/include&quot;"
mexopts_msys2_gcc.xml:40:        CXXOPTIMFLAGS="-O -DNDEBUG"
mexopts_msys2_gcc.xml:41:        CXXDEBUGFLAGS="-g"
mexopts_msys2_gcc.xml:45:        LDFLAGS="-m64 -Wl,--no-undefined"
mexopts_msys2_gcc.xml:46:        LDTYPE="-shared -static"
mexopts_msys2_gcc.xml:47:        LINKEXPORT="-Wl,&quot;$MATLABROOT/extern/lib/win64/mingw64/mexFunction.def&quot;"
mexopts_msys2_gcc.xml:48:        LINKEXPORTVER="-Wl,&quot;$MATLABROOT/extern/lib/win64/mingw64/exportsmexfileversion.def&quot;"
mexopts_msys2_gcc.xml:50:        LINKLIBS="-L&quot;$MATLABROOT\extern\lib\$ARCH\mingw64&quot; -llibmx -llibmex -llibmat"
mexopts_msys2_gcc.xml:51:        LDOPTIMFLAGS="-s"
mexopts_msys2_gcc.xml:52:        LDDEBUGFLAGS="-g"
mexopts_msys2_gcc.xml:58:                set COMPFLAGS=-c $CFLAGS $DEFINES $MATLABMEX
mexopts_msys2_gcc.xml:59:                set CXXCOMPFLAGS=-c $COMPFLAGS $DEFINES $MATLABMEX
mexopts_msys2_gcc.xml:66:                set NAME_OUTPUT= -o &quot;%OUTDIR%%MEX_NAME%%MEX_EXT%&quot;"
mexopts_msys2_gcc.xml:70:            LINKLIBS="$LINKLIBS -llibeng -llibMatlabDataArray -llibMatlabEngine"
mexopts_msys2_gcc.xml:76:            LDTYPE="-static"
mexopts_msys2_gcc.xml:80:          CXXFLAGS="$CXXFLAGS -Wno-endif-labels"
mexopts_msys2_gcc.xml:82:          LINKLIBS="-L&quot;$MATLABROOT\extern\lib\$ARCH\mingw64&quot; -Bstatic -lkernel32 -luser32 -lgdi32 -lwinspool -lcomdlg32 -ladvapi32 -lshell32 -lole32 -loleaut32 -luuid -lodbc32 -lodbccp32 "
mexopts_msys2_gcc.xml:86:          LDFLAGS="-m64 -Wl,--no-undefined,--out-implib,$LIB,&quot;$DEFFILE&quot;"
mexopts_msys2_gcc.xml:89:          LDTYPE="-static"
mexopts_msys2_gcc.xml:90:          INCLUDE="$INCLUDE -I&quot;$MATLABROOT\extern\include\$ARCH&quot;"
mexopts_msys2_gcc.xml:104:           <cmdReturns name="$$\bin\g++ -dumpmachine"/>
mmc_mesh.c:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_mesh.c:5:**  \copyright Qianqian Fang, 2010-2021
mmc_mesh.c:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_mesh.c:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_mesh.c:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_mesh.c:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_mesh.c:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_mesh.c:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_mesh.c:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_mesh.c:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_mesh.c:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_mesh.c:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_mesh.c:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_mesh.c:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_mesh.c:50: * \brief Tetrahedron faces, in counter-clock-wise orders, represented using local node indices
mmc_mesh.c:52: * node-connectivity, i.e. nc[4] points to the 4 facets of a tetrahedron, with each
mmc_mesh.c:53: * triangular face made of 3 nodes. The numbers [0-4] are the
mmc_mesh.c:55: * are in counter-clock-wise orders.
mmc_mesh.c:61: * \brief The local index of the node with an opposite face to the i-th face defined in nc[][]
mmc_mesh.c:63: * nc[i] <-> node[facemap[i]]
mmc_mesh.c:74: * nc[ifacemap[i]] <-> node[i]
mmc_mesh.c:83: * \brief Index mapping from the i-th face-neighbors (facenb) to the face defined in nc[][]
mmc_mesh.c:85: * facenb[i] <-> nc[faceorder[i]]
mmc_mesh.c:91:const int faceorder[] = {1, 3, 2, 0, -1};
mmc_mesh.c:94: * \brief Index mapping from the i-th face defined in nc[][] to the face-neighbor (facenb) face orders
mmc_mesh.c:96: * nc[ifaceorder[i]] <-> facenb[i]
mmc_mesh.c:112:    mesh->nn = 0;
mmc_mesh.c:113:    mesh->ne = 0;
mmc_mesh.c:114:    mesh->nf = 0;
mmc_mesh.c:115:    mesh->prop = 0;
mmc_mesh.c:116:    mesh->elemlen = 4;
mmc_mesh.c:117:    mesh->node = NULL;
mmc_mesh.c:118:    mesh->elem = NULL;
mmc_mesh.c:119:    mesh->elem2 = NULL;
mmc_mesh.c:120:    mesh->edgeroi = NULL;
mmc_mesh.c:121:    mesh->faceroi = NULL;
mmc_mesh.c:122:    mesh->noderoi = NULL;
mmc_mesh.c:123:    mesh->srcelemlen = 0;
mmc_mesh.c:124:    mesh->srcelem = NULL;
mmc_mesh.c:125:    mesh->detelemlen = 0;
mmc_mesh.c:126:    mesh->detelem = NULL;
mmc_mesh.c:127:    mesh->facenb = NULL;
mmc_mesh.c:128:    mesh->type = NULL;
mmc_mesh.c:129:    mesh->med = NULL;
mmc_mesh.c:130:    mesh->atte = NULL;
mmc_mesh.c:131:    mesh->weight = NULL;
mmc_mesh.c:132:    mesh->evol = NULL;
mmc_mesh.c:133:    mesh->nvol = NULL;
mmc_mesh.c:134:    mesh->dref = NULL;
mmc_mesh.c:135:    mesh->nmin.x = VERY_BIG;
mmc_mesh.c:136:    mesh->nmin.y = VERY_BIG;
mmc_mesh.c:137:    mesh->nmin.z = VERY_BIG;
mmc_mesh.c:138:    mesh->nmin.w = 1.f;
mmc_mesh.c:139:    mesh->nmax.x = -VERY_BIG;
mmc_mesh.c:140:    mesh->nmax.y = -VERY_BIG;
mmc_mesh.c:141:    mesh->nmax.z = -VERY_BIG;
mmc_mesh.c:142:    mesh->nmax.w = 1.f;
mmc_mesh.c:143:    mesh->nface = 0;
mmc_mesh.c:144:    mesh->fnode = NULL;
mmc_mesh.c:145:    mesh->fnorm = NULL;
mmc_mesh.c:146:    mesh->face = NULL;
mmc_mesh.c:147:    mesh->front = NULL;
mmc_mesh.c:148:    mesh->back = NULL;
mmc_mesh.c:152: * @brief Loading user-specified mesh data
mmc_mesh.c:162:    if (cfg->basisorder == 2) {
mmc_mesh.c:171:    if (cfg->seed == SEED_FROM_FILE && cfg->seedfile[0]) {
mmc_mesh.c:177: * @brief Error-handling in mesh operations
mmc_mesh.c:203:    sprintf(filename, format, cfg->meshtag);
mmc_mesh.c:205:    if (cfg->rootpath[0]) {
mmc_mesh.c:206:        sprintf(foutput, "%s%c%s", cfg->rootpath, pathsep, filename);
mmc_mesh.c:229:    len = fscanf(fp, "%d %d", &tmp, &(mesh->nn));
mmc_mesh.c:231:    if (len != 2 || mesh->nn <= 0) {
mmc_mesh.c:235:    mesh->node = (MMCfloat3*)calloc(sizeof(MMCfloat3), mesh->nn);
mmc_mesh.c:237:    for (i = 0; i < mesh->nn; i++) {
mmc_mesh.c:238:        if (fscanf(fp, "%d %f %f %f", &tmp, &(mesh->node[i].x), &(mesh->node[i].y), &(mesh->node[i].z)) != 4) {
mmc_mesh.c:245:    if (cfg->method == rtBLBadouelGrid) {
mmc_mesh.c:252:    mesh->nmin.x = VERY_BIG;
mmc_mesh.c:253:    mesh->nmin.y = VERY_BIG;
mmc_mesh.c:254:    mesh->nmin.z = VERY_BIG;
mmc_mesh.c:255:    mesh->nmax.x = -VERY_BIG;
mmc_mesh.c:256:    mesh->nmax.y = -VERY_BIG;
mmc_mesh.c:257:    mesh->nmax.z = -VERY_BIG;
mmc_mesh.c:259:    for (i = 0; i < mesh->nn; i++) {
mmc_mesh.c:260:        mesh->nmin.x = MIN(mesh->node[i].x, mesh->nmin.x);
mmc_mesh.c:261:        mesh->nmin.y = MIN(mesh->node[i].y, mesh->nmin.y);
mmc_mesh.c:262:        mesh->nmin.z = MIN(mesh->node[i].z, mesh->nmin.z);
mmc_mesh.c:263:        mesh->nmax.x = MAX(mesh->node[i].x, mesh->nmax.x);
mmc_mesh.c:264:        mesh->nmax.y = MAX(mesh->node[i].y, mesh->nmax.y);
mmc_mesh.c:265:        mesh->nmax.z = MAX(mesh->node[i].z, mesh->nmax.z);
mmc_mesh.c:268:    mesh->nmin.x -= EPS;
mmc_mesh.c:269:    mesh->nmin.y -= EPS;
mmc_mesh.c:270:    mesh->nmin.z -= EPS;
mmc_mesh.c:271:    mesh->nmax.x += EPS;
mmc_mesh.c:272:    mesh->nmax.y += EPS;
mmc_mesh.c:273:    mesh->nmax.z += EPS;
mmc_mesh.c:275:    cfg->dim.x = (int)((mesh->nmax.x - mesh->nmin.x) / cfg->steps.x) + 1;
mmc_mesh.c:276:    cfg->dim.y = (int)((mesh->nmax.y - mesh->nmin.y) / cfg->steps.y) + 1;
mmc_mesh.c:277:    cfg->dim.z = (int)((mesh->nmax.z - mesh->nmin.z) / cfg->steps.z) + 1;
mmc_mesh.c:279:    cfg->crop0.x = cfg->dim.x;
mmc_mesh.c:280:    cfg->crop0.y = cfg->dim.y * cfg->dim.x;
mmc_mesh.c:281:    cfg->crop0.z = cfg->dim.y * cfg->dim.x * cfg->dim.z;
mmc_mesh.c:301:    len = fscanf(fp, "%d %d", &tmp, &(mesh->prop));
mmc_mesh.c:303:    if (len != 2 || mesh->prop <= 0) {
mmc_mesh.c:308:    mesh->med = (medium*)calloc(sizeof(medium), mesh->prop + 1 + cfg->isextdet);
mmc_mesh.c:309:    mesh->atte = (float*)calloc(sizeof(float), mesh->prop + 1 + cfg->isextdet);
mmc_mesh.c:311:    mesh->med[0].mua = 0.f;
mmc_mesh.c:312:    mesh->med[0].mus = 0.f;
mmc_mesh.c:313:    mesh->med[0].n = cfg->nout;
mmc_mesh.c:314:    mesh->med[0].g = 1.f;
mmc_mesh.c:317:    if (cfg->isextdet) {
mmc_mesh.c:318:        memcpy(mesh->med + mesh->prop + 1, mesh->med, sizeof(medium));
mmc_mesh.c:320:        for (i = 0; i < mesh->ne; i++) {
mmc_mesh.c:321:            if (mesh->type[i] == -2) {
mmc_mesh.c:322:                mesh->type[i] = mesh->prop + 1;
mmc_mesh.c:327:    for (i = 1; i <= mesh->prop; i++) {
mmc_mesh.c:328:        if (fscanf(fp, "%d %f %f %f %f", &tmp, &(mesh->med[i].mua), &(mesh->med[i].mus),
mmc_mesh.c:329:                   &(mesh->med[i].g), &(mesh->med[i].n)) != 5) {
mmc_mesh.c:333:        /*mesh->atte[i]=expf(-cfg->minstep*mesh->med[i].mua);*/
mmc_mesh.c:338:    if (cfg->method != rtBLBadouelGrid && cfg->unitinmm != 1.f) {
mmc_mesh.c:339:        for (i = 1; i <= mesh->prop; i++) {
mmc_mesh.c:340:            mesh->med[i].mus *= cfg->unitinmm;
mmc_mesh.c:341:            mesh->med[i].mua *= cfg->unitinmm;
mmc_mesh.c:345:    cfg->his.maxmedia = mesh->prop; /*skip media 0*/
mmc_mesh.c:374:        mesh->edgeroi = (float*)malloc(sizeof(float) * 6 * mesh->ne);
mmc_mesh.c:375:        pe = mesh->edgeroi;
mmc_mesh.c:377:        mesh->noderoi = (float*)malloc(sizeof(float) * mesh->nn);
mmc_mesh.c:378:        pe = mesh->noderoi;
mmc_mesh.c:380:        mesh->faceroi = (float*)malloc(sizeof(float) * 4 * mesh->ne);
mmc_mesh.c:381:        pe = mesh->faceroi;
mmc_mesh.c:419:    len = fscanf(fp, "%d %d", &(mesh->elemlen), &(mesh->ne));
mmc_mesh.c:421:    if (len != 2 || mesh->ne <= 0) {
mmc_mesh.c:425:    if (mesh->elemlen < 4) {
mmc_mesh.c:426:        mesh->elemlen = 4;
mmc_mesh.c:429:    mesh->elem = (int*)malloc(sizeof(int) * mesh->elemlen * mesh->ne);
mmc_mesh.c:430:    mesh->type = (int*)malloc(sizeof(int ) * mesh->ne);
mmc_mesh.c:432:    datalen = (cfg->method == rtBLBadouelGrid) ? cfg->crop0.z : ( (cfg->basisorder) ? mesh->nn : mesh->ne);
mmc_mesh.c:433:    mesh->weight = (double*)calloc(sizeof(double) * datalen, cfg->maxgate * cfg->srcnum);
mmc_mesh.c:435:    for (i = 0; i < mesh->ne; i++) {
mmc_mesh.c:436:        pe = mesh->elem + i * mesh->elemlen;
mmc_mesh.c:442:        for (j = 0; j < mesh->elemlen; j++)
mmc_mesh.c:447:        if (fscanf(fp, "%d", mesh->type + i) != 1) {
mmc_mesh.c:454:    if (i < mesh->ne) {
mmc_mesh.c:462: * @brief Identify wide-field source and detector-related elements (type=-1 for source, type=-2 for det)
mmc_mesh.c:471:    mesh->srcelemlen = 0;
mmc_mesh.c:472:    mesh->detelemlen = 0;
mmc_mesh.c:474:    for (i = 0; i < mesh->ne; i++) {
mmc_mesh.c:475:        if (mesh->type[i] == -1) { /*number of elements in the initial candidate list*/
mmc_mesh.c:476:            mesh->srcelemlen++;
mmc_mesh.c:477:            cfg->e0 = (cfg->e0 == 0) ? i + 1 : cfg->e0;
mmc_mesh.c:480:        if (mesh->type[i] == -2) { /*number of elements in the initial candidate list*/
mmc_mesh.c:481:            mesh->detelemlen++;
mmc_mesh.c:482:            cfg->isextdet = 1;
mmc_mesh.c:483:            cfg->detnum = 0; // when detecting wide-field detectors, suppress point detectors
mmc_mesh.c:489:    if (mesh->srcelemlen > 0 ||  mesh->detelemlen > 0) {
mmc_mesh.c:491:        mesh->srcelem = (int*)calloc(mesh->srcelemlen, sizeof(int));
mmc_mesh.c:492:        mesh->detelem = (int*)calloc(mesh->detelemlen, sizeof(int));
mmc_mesh.c:494:        for (i = 0; i < mesh->ne; i++) {
mmc_mesh.c:495:            if (mesh->type[i] < 0) {
mmc_mesh.c:496:                if (mesh->type[i] == -1) {
mmc_mesh.c:497:                    mesh->srcelem[is++] = i + 1;
mmc_mesh.c:498:                    mesh->type[i] = 0;
mmc_mesh.c:499:                } else if (mesh->type[i] == -2) { /*keep -2, will be replaced to medianum+1 in loadmedia*/
mmc_mesh.c:500:                    mesh->detelem[id++] = i + 1;
mmc_mesh.c:524:    len = fscanf(fp, "%d %d", &tmp, &(mesh->ne));
mmc_mesh.c:526:    if (len != 2 || mesh->ne <= 0) {
mmc_mesh.c:530:    mesh->evol = (float*)malloc(sizeof(float) * mesh->ne);
mmc_mesh.c:531:    mesh->nvol = (float*)calloc(sizeof(float), mesh->nn);
mmc_mesh.c:533:    for (i = 0; i < mesh->ne; i++) {
mmc_mesh.c:534:        if (fscanf(fp, "%d %f", &tmp, mesh->evol + i) != 2) {
mmc_mesh.c:538:        if (mesh->type[i] == 0) {
mmc_mesh.c:542:        ee = (int*)(mesh->elem + i * mesh->elemlen);
mmc_mesh.c:544:        for (j = 0; j < mesh->elemlen; j++) {
mmc_mesh.c:545:            mesh->nvol[ee[j] - 1] += mesh->evol[i] * 0.25f;
mmc_mesh.c:553: * @brief Load face-neightbor element list and initialize the related mesh properties
mmc_mesh.c:567:        MESH_ERROR("can not open face-neighbor list file");
mmc_mesh.c:570:    len = fscanf(fp, "%d %d", &(mesh->elemlen), &(mesh->ne));
mmc_mesh.c:572:    if (len != 2 || mesh->ne <= 0) {
mmc_mesh.c:576:    if (mesh->elemlen < 4) {
mmc_mesh.c:577:        mesh->elemlen = 4;
mmc_mesh.c:580:    mesh->facenb = (int*)malloc(sizeof(int) * mesh->elemlen * mesh->ne);
mmc_mesh.c:582:    for (i = 0; i < mesh->ne; i++) {
mmc_mesh.c:583:        pe = mesh->facenb + i * mesh->elemlen;
mmc_mesh.c:585:        for (j = 0; j < mesh->elemlen; j++)
mmc_mesh.c:587:                MESH_ERROR("face-neighbor list file has wrong format");
mmc_mesh.c:603:    FILE* fp = fopen(cfg->seedfile, "rb");
mmc_mesh.c:618:    if (his.maxmedia != mesh->prop) {
mmc_mesh.c:626:    cfg->photonseed = malloc(his.savedphoton * his.seedbyte);
mmc_mesh.c:628:    if (cfg->photonseed == NULL) {
mmc_mesh.c:632:    if (fread(cfg->photonseed, his.seedbyte, his.savedphoton, fp) != his.savedphoton) {
mmc_mesh.c:636:    cfg->seed = SEED_FROM_FILE;
mmc_mesh.c:637:    cfg->nphoton = his.savedphoton;
mmc_mesh.c:639:    if (cfg->outputtype == otJacobian || cfg->outputtype == otWL || cfg->outputtype == otWP || cfg->replaydet > 0) {
mmc_mesh.c:642:        cfg->replayweight = (float*)malloc(his.savedphoton * sizeof(float));
mmc_mesh.c:643:        cfg->replaytime = (float*)malloc(his.savedphoton * sizeof(float));
mmc_mesh.c:650:        cfg->nphoton = 0;
mmc_mesh.c:653:            if (cfg->replaydet == 0 || cfg->replaydet == (int)(ppath[i * his.colcount])) {
mmc_mesh.c:654:                memcpy((char*)(cfg->photonseed) + cfg->nphoton * his.seedbyte, (char*)(cfg->photonseed) + i * his.seedbyte, his.seedbyte);
mmc_mesh.c:656:                // replay with wide-field detection pattern, the partial path has to contain photon exit information
mmc_mesh.c:657:                if ((cfg->detparam1.w * cfg->detparam2.w > 0) && (cfg->detpattern != NULL)) {
mmc_mesh.c:658:                    cfg->replayweight[cfg->nphoton] = mesh_getdetweight(i, his.colcount, ppath, cfg);
mmc_mesh.c:660:                    cfg->replayweight[cfg->nphoton] = ppath[(i + 1) * his.colcount - 1];
mmc_mesh.c:664:                    cfg->replayweight[cfg->nphoton] *= expf(-mesh->med[j - 1].mua * ppath[i * his.colcount + j] * his.unitinmm);
mmc_mesh.c:667:                cfg->replaytime[cfg->nphoton] = 0.f;
mmc_mesh.c:670:                    cfg->replaytime[cfg->nphoton] += mesh->med[j - 1].n * ppath[i * his.colcount + j] * R_C0;
mmc_mesh.c:673:                cfg->nphoton++;
mmc_mesh.c:677:        cfg->photonseed = realloc(cfg->photonseed, cfg->nphoton * his.seedbyte);
mmc_mesh.c:678:        cfg->replayweight = (float*)realloc(cfg->replayweight, cfg->nphoton * sizeof(float));
mmc_mesh.c:679:        cfg->replaytime = (float*)realloc(cfg->replaytime, cfg->nphoton * sizeof(float));
mmc_mesh.c:680:        cfg->minenergy = 0.f;
mmc_mesh.c:694:    mesh->nn = 0;
mmc_mesh.c:695:    mesh->ne = 0;
mmc_mesh.c:696:    mesh->nf = 0;
mmc_mesh.c:697:    mesh->srcelemlen = 0;
mmc_mesh.c:698:    mesh->detelemlen = 0;
mmc_mesh.c:700:    if (mesh->node) {
mmc_mesh.c:701:        free(mesh->node);
mmc_mesh.c:702:        mesh->node = NULL;
mmc_mesh.c:705:    if (mesh->elem) {
mmc_mesh.c:706:        free(mesh->elem);
mmc_mesh.c:707:        mesh->elem = NULL;
mmc_mesh.c:710:    if (mesh->elem2) {
mmc_mesh.c:711:        free(mesh->elem2);
mmc_mesh.c:712:        mesh->elem2 = NULL;
mmc_mesh.c:715:    if (mesh->facenb) {
mmc_mesh.c:716:        free(mesh->facenb);
mmc_mesh.c:717:        mesh->facenb = NULL;
mmc_mesh.c:720:    if (mesh->dref) {
mmc_mesh.c:721:        free(mesh->dref);
mmc_mesh.c:722:        mesh->dref = NULL;
mmc_mesh.c:725:    if (mesh->type) {
mmc_mesh.c:726:        free(mesh->type);
mmc_mesh.c:727:        mesh->type = NULL;
mmc_mesh.c:730:    if (mesh->med) {
mmc_mesh.c:731:        free(mesh->med);
mmc_mesh.c:732:        mesh->med = NULL;
mmc_mesh.c:735:    if (mesh->atte) {
mmc_mesh.c:736:        free(mesh->atte);
mmc_mesh.c:737:        mesh->atte = NULL;
mmc_mesh.c:740:    if (mesh->weight) {
mmc_mesh.c:741:        free(mesh->weight);
mmc_mesh.c:742:        mesh->weight = NULL;
mmc_mesh.c:745:    if (mesh->evol) {
mmc_mesh.c:746:        free(mesh->evol);
mmc_mesh.c:747:        mesh->evol = NULL;
mmc_mesh.c:750:    if (mesh->nvol) {
mmc_mesh.c:751:        free(mesh->nvol);
mmc_mesh.c:752:        mesh->nvol = NULL;
mmc_mesh.c:755:    if (mesh->srcelem) {
mmc_mesh.c:756:        free(mesh->srcelem);
mmc_mesh.c:757:        mesh->srcelem = NULL;
mmc_mesh.c:760:    if (mesh->detelem) {
mmc_mesh.c:761:        free(mesh->detelem);
mmc_mesh.c:762:        mesh->detelem = NULL;
mmc_mesh.c:765:    if (mesh->noderoi) {
mmc_mesh.c:766:        free(mesh->noderoi);
mmc_mesh.c:767:        mesh->noderoi = NULL;
mmc_mesh.c:770:    if (mesh->edgeroi) {
mmc_mesh.c:771:        free(mesh->edgeroi);
mmc_mesh.c:772:        mesh->edgeroi = NULL;
mmc_mesh.c:775:    if (mesh->faceroi) {
mmc_mesh.c:776:        free(mesh->faceroi);
mmc_mesh.c:777:        mesh->faceroi = NULL;
mmc_mesh.c:780:    if (mesh->fnode) {
mmc_mesh.c:781:        free(mesh->fnode);
mmc_mesh.c:782:        mesh->fnode = NULL;
mmc_mesh.c:785:    if (mesh->fnorm) {
mmc_mesh.c:786:        free(mesh->fnorm);
mmc_mesh.c:787:        mesh->fnorm = NULL;
mmc_mesh.c:790:    if (mesh->face) {
mmc_mesh.c:791:        free(mesh->face);
mmc_mesh.c:792:        mesh->face = NULL;
mmc_mesh.c:795:    if (mesh->front) {
mmc_mesh.c:796:        free(mesh->front);
mmc_mesh.c:797:        mesh->front = NULL;
mmc_mesh.c:800:    if (mesh->back) {
mmc_mesh.c:801:        free(mesh->back);
mmc_mesh.c:802:        mesh->back = NULL;
mmc_mesh.c:808: * @brief Initialize a data structure storing all pre-computed ray-tracing related data
mmc_mesh.c:810: * the pre-computed ray-tracing data include
mmc_mesh.c:812: * m: the cross-product of the end-nodes of the 6-edges n1 x n2
mmc_mesh.c:815: * @param[out] tracer: the ray-tracer data structure
mmc_mesh.c:817: * @param[in] methodid: the ray-tracing algorithm to be used
mmc_mesh.c:821:    tracer->d = NULL;
mmc_mesh.c:822:    tracer->m = NULL;
mmc_mesh.c:823:    tracer->n = NULL;
mmc_mesh.c:824:    tracer->mesh = pmesh;
mmc_mesh.c:825:    tracer->method = methodid;
mmc_mesh.c:830: * @brief Preparing for the ray-tracing calculations
mmc_mesh.c:832: * This function build the ray-tracing precomputed data and test if the initial
mmc_mesh.c:835: * @param[out] tracer: the ray-tracer data structure
mmc_mesh.c:840:    int i, j, ne = tracer->mesh->ne;
mmc_mesh.c:842:    if (cfg->compute == cbOptiX) {
mmc_mesh.c:843:        tetmesh* pmesh = tracer->mesh;
mmc_mesh.c:844:        int* fnb = (int*)malloc(pmesh->ne * pmesh->elemlen * sizeof(int));
mmc_mesh.c:845:        memcpy(fnb, tracer->mesh->facenb, (pmesh->ne * pmesh->elemlen) * sizeof(int));
mmc_mesh.c:848:        pmesh->fnode = (float3*)malloc(pmesh->nn * sizeof(float3));
mmc_mesh.c:850:        for (int i = 0; i < pmesh->nn; ++i) {
mmc_mesh.c:851:            pmesh->fnode[i].x = pmesh->node[i].x;
mmc_mesh.c:852:            pmesh->fnode[i].y = pmesh->node[i].y;
mmc_mesh.c:853:            pmesh->fnode[i].z = pmesh->node[i].z;
mmc_mesh.c:857:        pmesh->nface = 0;
mmc_mesh.c:858:        pmesh->face = (uint3*)malloc((pmesh->ne * pmesh->elemlen) * sizeof(uint3));
mmc_mesh.c:859:        pmesh->fnorm = (float3*)malloc((pmesh->ne * pmesh->elemlen) * sizeof(float3));
mmc_mesh.c:860:        pmesh->front = (uint*)malloc((pmesh->ne * pmesh->elemlen) * sizeof(uint));
mmc_mesh.c:861:        pmesh->back = (uint*)malloc((pmesh->ne * pmesh->elemlen) * sizeof(uint));
mmc_mesh.c:864:        for (int i = 0; i < pmesh->ne; ++i) {
mmc_mesh.c:865:            for (int j = 0; j < pmesh->elemlen; ++j) {
mmc_mesh.c:866:                int nexteid = fnb[(i * pmesh->elemlen) + j];
mmc_mesh.c:868:                if ((nexteid > 0 && pmesh->type[nexteid - 1] != pmesh->type[i]) || nexteid == 0) {
mmc_mesh.c:870:                    pmesh->face[pmesh->nface].x = pmesh->elem[(i * pmesh->elemlen) + out[ifaceorder[j]][0]] - 1;
mmc_mesh.c:871:                    pmesh->face[pmesh->nface].y = pmesh->elem[(i * pmesh->elemlen) + out[ifaceorder[j]][1]] - 1;
mmc_mesh.c:872:                    pmesh->face[pmesh->nface].z = pmesh->elem[(i * pmesh->elemlen) + out[ifaceorder[j]][2]] - 1;
mmc_mesh.c:874:                    v0 = pmesh->fnode[pmesh->face[pmesh->nface].x];
mmc_mesh.c:875:                    v1 = pmesh->fnode[pmesh->face[pmesh->nface].y];
mmc_mesh.c:876:                    v2 = pmesh->fnode[pmesh->face[pmesh->nface].z];
mmc_mesh.c:882:                    pmesh->fnorm[pmesh->nface] = vnorm;
mmc_mesh.c:884:                    pmesh->front[pmesh->nface] = ((nexteid == 0) ? 0 : pmesh->type[nexteid - 1]);
mmc_mesh.c:885:                    pmesh->back[pmesh->nface] = pmesh->type[i];
mmc_mesh.c:886:                    fnb[(i * pmesh->elemlen) + j] = -1;
mmc_mesh.c:889:                        for (int k = 0; k < pmesh->elemlen; ++k) {
mmc_mesh.c:890:                            if (fnb[((nexteid - 1) * pmesh->elemlen) + k] == i + 1) {
mmc_mesh.c:891:                                fnb[((nexteid - 1) * pmesh->elemlen) + k] = -1;
mmc_mesh.c:897:                    ++pmesh->nface;
mmc_mesh.c:902:        pmesh->face = (uint3*)realloc(pmesh->face, pmesh->nface * sizeof(uint3));
mmc_mesh.c:903:        pmesh->fnorm = (float3*)realloc(pmesh->fnorm, pmesh->nface * sizeof(float3));
mmc_mesh.c:904:        pmesh->front = (uint*)realloc(pmesh->front, pmesh->nface * sizeof(uint));
mmc_mesh.c:905:        pmesh->back = (uint*)realloc(pmesh->back, pmesh->nface * sizeof(uint));
mmc_mesh.c:912:    if (tracer->n == NULL && tracer->m == NULL && tracer->d == NULL) {
mmc_mesh.c:913:        if (tracer->mesh != NULL) {
mmc_mesh.c:918:    } else if ( (cfg->srctype == stPencil || cfg->srctype == stIsotropic || cfg->srctype == stCone || cfg->srctype == stArcSin)  && cfg->e0 > 0) {
mmc_mesh.c:919:        int eid = cfg->e0 - 1;
mmc_mesh.c:920:        MMCfloat3 vecS = {0.f}, *nodes = tracer->mesh->node, vecAB, vecAC, vecN;
mmc_mesh.c:922:        float s = 0.f, *bary = &(cfg->bary0.x);
mmc_mesh.c:923:        int* elems = (int*)(tracer->mesh->elem + eid * tracer->mesh->elemlen); // convert int4* to int*
mmc_mesh.c:925:        if (eid >= tracer->mesh->ne) {
mmc_mesh.c:930:            ea = elems[out[i][0]] - 1;
mmc_mesh.c:931:            eb = elems[out[i][1]] - 1;
mmc_mesh.c:932:            ec = elems[out[i][2]] - 1;
mmc_mesh.c:935:            vec_diff(&nodes[ea], &(cfg->srcpos), &vecS);
mmc_mesh.c:937:            bary[facemap[i]] = -vec_dot(&vecS, &vecN);
mmc_mesh.c:940:        if (cfg->debuglevel & dlWeight)
mmc_mesh.c:941:            fprintf(cfg->flog, "initial bary-centric volumes [%e %e %e %e]\n",
mmc_mesh.c:957:    // build acceleration data structure to speed up first-neighbor immc face-roi calculation
mmc_mesh.c:959:    if (tracer->mesh->faceroi) {
mmc_mesh.c:964:                if (tracer->mesh->faceroi[(i << 2) + j] > 0.f) {
mmc_mesh.c:968:            if (count && fabs(tracer->mesh->faceroi[i << 2]) < EPS) {
mmc_mesh.c:969:                tracer->mesh->faceroi[i << 2] = -count;    // number -1 to -4 indicates how many faces have ROIs
mmc_mesh.c:974:            if (fabs(tracer->mesh->faceroi[i << 2]) < EPS) { // if I don't have roi
mmc_mesh.c:975:                for (j = 0; j < tracer->mesh->elemlen; j++) { // loop over my neighbors
mmc_mesh.c:976:                    int id = tracer->mesh->facenb[i * tracer->mesh->elemlen + j]; // loop over neighboring elements
mmc_mesh.c:978:                    if (id > 0 && tracer->mesh->faceroi[(id - 1) << 2] < 0.f) { // if I don't have roi, but neighbor has, set ref id as -elemid-4, only handle 1 roi neighbor case
mmc_mesh.c:979:                        tracer->mesh->faceroi[i << 2] = -id - 4;
mmc_mesh.c:988:    ne = tracer->mesh->ne * tracer->mesh->elemlen;
mmc_mesh.c:989:    tracer->mesh->nf = 0;
mmc_mesh.c:992:        if (tracer->mesh->facenb[i] == 0) {
mmc_mesh.c:993:            tracer->mesh->facenb[i] = -(++tracer->mesh->nf);
mmc_mesh.c:997:    if (tracer->mesh->dref) {
mmc_mesh.c:998:        free(tracer->mesh->dref);
mmc_mesh.c:1001:    if (cfg->issaveref) {
mmc_mesh.c:1002:        tracer->mesh->dref = (double*)calloc(sizeof(double) * tracer->mesh->nf * cfg->srcnum, cfg->maxgate);
mmc_mesh.c:1007: * @brief Pre-computed ray-tracing related data
mmc_mesh.c:1009: * the pre-computed ray-tracing data include
mmc_mesh.c:1010: * d: the vector of the 6 edges: edge[i]=[ni1,ni2]: d[i]=ni2 - ni1
mmc_mesh.c:1011: * m: the cross-product of the end-nodes of the 6-edges: edge[i]=[ni1,ni2]: m[i]=ni1 x ni2
mmc_mesh.c:1014: * @param[out] tracer: the ray-tracer data structure
mmc_mesh.c:1026:    if (tracer->d || tracer->m || tracer->n || tracer->mesh == NULL) {
mmc_mesh.c:1030:    if (tracer->mesh->node == NULL || tracer->mesh->elem == NULL ||
mmc_mesh.c:1031:            tracer->mesh->facenb == NULL || tracer->mesh->med == NULL) {
mmc_mesh.c:1035:    ne = tracer->mesh->ne;
mmc_mesh.c:1036:    nodes = tracer->mesh->node;
mmc_mesh.c:1037:    elems = (int*)(tracer->mesh->elem); // convert int4* to int*
mmc_mesh.c:1039:    if (tracer->method == rtPlucker) {
mmc_mesh.c:1043:        tracer->d = (MMCfloat3*)calloc(sizeof(MMCfloat3), ne * 6); // 6 edges/elem
mmc_mesh.c:1044:        tracer->m = (MMCfloat3*)calloc(sizeof(MMCfloat3), ne * 6); // 6 edges/elem
mmc_mesh.c:1045:        tracer->n = (MMCfloat3*)calloc(sizeof(MMCfloat3), ne * 4); // 4 face norms
mmc_mesh.c:1051:                e1 = elems[ebase + pairs[j][1]] - 1;
mmc_mesh.c:1052:                e0 = elems[ebase + pairs[j][0]] - 1;
mmc_mesh.c:1053:                vec_diff(&nodes[e0], &nodes[e1], tracer->d + i * 6 + j);
mmc_mesh.c:1054:                vec_cross(&nodes[e0], &nodes[e1], tracer->m + i * 6 + j);
mmc_mesh.c:1058:                ea = elems[ebase + out[j][0]] - 1;
mmc_mesh.c:1059:                eb = elems[ebase + out[j][1]] - 1;
mmc_mesh.c:1060:                ec = elems[ebase + out[j][2]] - 1;
mmc_mesh.c:1063:                vec_cross(&vecAB, &vecAC, tracer->n + ebase + j);
mmc_mesh.c:1064:                Rn2 = 1.f / sqrt(vec_dot(tracer->n + ebase + j, tracer->n + ebase + j));
mmc_mesh.c:1065:                vec_mult(tracer->n + ebase + j, Rn2, tracer->n + ebase + j);
mmc_mesh.c:1068:    } else if (tracer->method == rtHavel || tracer->method == rtBadouel) {
mmc_mesh.c:1072:        tracer->d = NULL;
mmc_mesh.c:1073:        tracer->m = (MMCfloat3*)calloc(sizeof(MMCfloat3), ne * 12);
mmc_mesh.c:1079:                MMCfloat3* vecN = tracer->m + 3 * (ebase + j);
mmc_mesh.c:1081:                ea = elems[ebase + out[j][0]] - 1;
mmc_mesh.c:1082:                eb = elems[ebase + out[j][1]] - 1;
mmc_mesh.c:1083:                ec = elems[ebase + out[j][2]] - 1;
mmc_mesh.c:1098:                vecN->w    = vec_dot(vecN,  &nodes[ea]);
mmc_mesh.c:1099:                (vecN + 1)->w = -vec_dot(vecN + 1, &nodes[ea]);
mmc_mesh.c:1100:                (vecN + 2)->w = -vec_dot(vecN + 2, &nodes[ea]);
mmc_mesh.c:1104:    } else if (tracer->method == rtBLBadouel || tracer->method == rtBLBadouelGrid) {
mmc_mesh.c:1108:        tracer->d = NULL;
mmc_mesh.c:1109:        tracer->n = (MMCfloat3*)calloc(sizeof(MMCfloat3), ne * 4);
mmc_mesh.c:1113:            float* vecN = &(tracer->n[ebase].x);
mmc_mesh.c:1116:                ea = elems[ebase + out[j][0]] - 1;
mmc_mesh.c:1117:                eb = elems[ebase + out[j][1]] - 1;
mmc_mesh.c:1118:                ec = elems[ebase + out[j][2]] - 1;
mmc_mesh.c:1138: * @brief Clear the ray-tracing data structure
mmc_mesh.c:1140: * Deconstructor of the ray-tracing data structure
mmc_mesh.c:1142: * @param[out] tracer: the ray-tracer data structure
mmc_mesh.c:1146:    if (tracer->d) {
mmc_mesh.c:1147:        free(tracer->d);
mmc_mesh.c:1148:        tracer->d = NULL;
mmc_mesh.c:1151:    if (tracer->m) {
mmc_mesh.c:1152:        free(tracer->m);
mmc_mesh.c:1153:        tracer->m = NULL;
mmc_mesh.c:1156:    if (tracer->n) {
mmc_mesh.c:1157:        free(tracer->n);
mmc_mesh.c:1158:        tracer->n = NULL;
mmc_mesh.c:1161:    tracer->mesh = NULL;
mmc_mesh.c:1200:    //Henyey-Greenstein Phase Function, "Handbook of Optical Biomedical Diagnostics",2002,Chap3,p234
mmc_mesh.c:1204:        tmp0 = (1.f - g * g) / (1.f - g + 2.f * g * rand_next_zangle(ran));
mmc_mesh.c:1206:        tmp0 = (1.f + g * g - tmp0) / (2.f * g);
mmc_mesh.c:1213:        if (tmp0 < -1.f) {
mmc_mesh.c:1214:            tmp0 = -1.f;
mmc_mesh.c:1218:        stheta = sqrt(1.f - tmp0 * tmp0);
mmc_mesh.c:1222:        theta = acosf(2.f * rand_next_zangle(ran) - 1.f);
mmc_mesh.c:1226:    if ( dir->z > -1.f + EPS && dir->z < 1.f - EPS ) {
mmc_mesh.c:1227:        tmp0 = 1.f - dir->z * dir->z; //reuse tmp to minimize registers
mmc_mesh.c:1231:        p.x = tmp1 * (dir->x * dir->z * cphi - dir->y * sphi) + dir->x * ctheta;
mmc_mesh.c:1232:        p.y = tmp1 * (dir->y * dir->z * cphi + dir->x * sphi) + dir->y * ctheta;
mmc_mesh.c:1233:        p.z = -tmp1 * tmp0 * cphi             + dir->z * ctheta;
mmc_mesh.c:1237:        p.z = (dir->z > 0.f) ? ctheta : -ctheta;
mmc_mesh.c:1240:    if (cfg->ismomentum) {
mmc_mesh.c:1241:        pmom[0] += (1.f - ctheta);
mmc_mesh.c:1244:    dir->x = p.x;
mmc_mesh.c:1245:    dir->y = p.y;
mmc_mesh.c:1246:    dir->z = p.z;
mmc_mesh.c:1259:    int i, j, datalen = (cfg->method == rtBLBadouelGrid) ? cfg->crop0.z : ( (cfg->basisorder) ? mesh->nn : mesh->ne);
mmc_mesh.c:1261:    double* data = mesh->weight;
mmc_mesh.c:1264:        data = mesh->dref;
mmc_mesh.c:1265:        datalen = mesh->nf;
mmc_mesh.c:1268:    if (cfg->rootpath[0]) {
mmc_mesh.c:1269:        sprintf(fweight, "%s%c%s%s.dat", cfg->rootpath, pathsep, cfg->session, (isref ? "_dref" : ""));
mmc_mesh.c:1271:        sprintf(fweight, "%s%s.dat", cfg->session, (isref ? "_dref" : ""));
mmc_mesh.c:1274:    if (cfg->outputformat >= ofBin && cfg->outputformat <= ofBJNifti) {
mmc_mesh.c:1275:        uint3 dim0 = cfg->dim;
mmc_mesh.c:1277:        if (cfg->method != rtBLBadouelGrid) {
mmc_mesh.c:1278:            cfg->dim.x = cfg->srcnum;
mmc_mesh.c:1279:            cfg->dim.y = cfg->maxgate;
mmc_mesh.c:1280:            cfg->dim.z = datalen;
mmc_mesh.c:1283:        mcx_savedata(mesh->weight, datalen * cfg->maxgate * cfg->srcnum, cfg, isref);
mmc_mesh.c:1284:        cfg->dim = dim0;
mmc_mesh.c:1292:    for (i = 0; i < cfg->maxgate; i++) {
mmc_mesh.c:1294:            if (1 == cfg->srcnum) {
mmc_mesh.c:1301:                for (k = 0; k < cfg->srcnum; k++) {
mmc_mesh.c:1302:                    shift = (i * datalen + j) * cfg->srcnum + k;
mmc_mesh.c:1318: * @param[in] ppath: buffer points to the detected photon data (partial-path, det id, etc)
mmc_mesh.c:1329:    if (cfg->rootpath[0]) {
mmc_mesh.c:1330:        sprintf(fhistory, "%s%c%s.mch", cfg->rootpath, pathsep, cfg->session);
mmc_mesh.c:1332:        sprintf(fhistory, "%s.mch", cfg->session);
mmc_mesh.c:1339:    cfg->his.totalphoton = cfg->nphoton;
mmc_mesh.c:1340:    cfg->his.unitinmm = 1.f;
mmc_mesh.c:1342:    if (cfg->method != rtBLBadouelGrid) {
mmc_mesh.c:1343:        cfg->his.unitinmm = cfg->unitinmm;
mmc_mesh.c:1346:    cfg->his.detected = count;
mmc_mesh.c:1347:    cfg->his.savedphoton = count;
mmc_mesh.c:1348:    cfg->his.srcnum = cfg->srcnum;
mmc_mesh.c:1349:    cfg->his.detnum = cfg->detnum;
mmc_mesh.c:1351:    if (cfg->issaveseed && seeds != NULL) {
mmc_mesh.c:1352:        cfg->his.seedbyte = seedbyte;
mmc_mesh.c:1355:    cfg->his.colcount = (2 + (cfg->ismomentum > 0)) * cfg->his.maxmedia + (cfg->issaveexit > 0) * 6 + 2; /*column count=maxmedia+3*/
mmc_mesh.c:1357:    if (count > 0 && cfg->exportdetected == NULL) {
mmc_mesh.c:1358:        cfg->detectedcount = count;
mmc_mesh.c:1359:        cfg->exportdetected = (float*)malloc(cfg->his.colcount * cfg->detectedcount * sizeof(float));
mmc_mesh.c:1362:    if (cfg->exportdetected != ppath) {
mmc_mesh.c:1363:        memcpy(cfg->exportdetected, ppath, count * cfg->his.colcount * sizeof(float));
mmc_mesh.c:1366:    fwrite(&(cfg->his), sizeof(history), 1, fp);
mmc_mesh.c:1367:    fwrite(ppath, sizeof(float), count * cfg->his.colcount, fp);
mmc_mesh.c:1369:    if (cfg->issaveseed && seeds != NULL) {
mmc_mesh.c:1378: * @brief Save binned detected photon data over an area-detector as time-resolved 2D images
mmc_mesh.c:1385: * @param[in] ppath: buffer points to the detected photon data (partial-path, det id, etc)
mmc_mesh.c:1392:    // cfg->issaveexit is 2 for this mode
mmc_mesh.c:1393:    int colcount = (2 + (cfg->ismomentum > 0)) * cfg->his.maxmedia + 6 + 2;
mmc_mesh.c:1394:    float x0 = cfg->detpos[0].x;
mmc_mesh.c:1395:    float y0 = cfg->detpos[0].y;
mmc_mesh.c:1396:    float xrange = cfg->detparam1.x + cfg->detparam2.x;
mmc_mesh.c:1397:    float yrange = cfg->detparam1.y + cfg->detparam2.y;
mmc_mesh.c:1398:    int xsize = cfg->detparam1.w;
mmc_mesh.c:1399:    int ysize = cfg->detparam2.w;
mmc_mesh.c:1401:    float unitinmm = (cfg->method != rtBLBadouelGrid) ? cfg->his.unitinmm : 1.f;
mmc_mesh.c:1407:        weight = ppath[(i + 1) * colcount - 1];
mmc_mesh.c:1409:        for (j = 1; j <= cfg->his.maxmedia; j++) {
mmc_mesh.c:1410:            path += ppath[i * colcount + j + cfg->his.maxmedia] * mesh->med[j].n;
mmc_mesh.c:1411:            weight *= expf(-ppath[i * colcount + j + cfg->his.maxmedia] * mesh->med[j].mua * unitinmm);
mmc_mesh.c:1414:        ntg = (int) path * R_C0 / cfg->tstep;
mmc_mesh.c:1416:        if (ntg > cfg->maxgate - 1) {
mmc_mesh.c:1417:            ntg = cfg->maxgate - 1;
mmc_mesh.c:1420:        xloc = ppath[(i + 1) * colcount - 7];
mmc_mesh.c:1421:        yloc = ppath[(i + 1) * colcount - 6];
mmc_mesh.c:1422:        xindex = (xloc - x0) / xrange * xsize;
mmc_mesh.c:1424:        if (xindex < 0 || xindex > xsize - 1) {
mmc_mesh.c:1428:        yindex = (yloc - y0) / yrange * ysize;
mmc_mesh.c:1430:        if (yindex < 0 || yindex > ysize - 1) {
mmc_mesh.c:1440: * @brief Save binned detected photon data over an area-detector
mmc_mesh.c:1442: * function for saving binned detected photon data into time-resolved 2D images
mmc_mesh.c:1453:    if (cfg->rootpath[0]) {
mmc_mesh.c:1454:        sprintf(fhistory, "%s%c%s.img", cfg->rootpath, pathsep, cfg->session);
mmc_mesh.c:1456:        sprintf(fhistory, "%s.img", cfg->session);
mmc_mesh.c:1463:    fwrite(detmap, sizeof(float), cfg->detparam1.w * cfg->detparam2.w * cfg->maxgate, fp);
mmc_mesh.c:1468: * @brief Recompute the detected photon weight from the partial-pathlengths
mmc_mesh.c:1474: * @param[in] colcount: how many 4-byte records per detected photon
mmc_mesh.c:1475: * @param[in] ppath: buffer points to the detected photon data (partial-path, det id, etc)
mmc_mesh.c:1481:    float x0 = cfg->detpos[0].x;
mmc_mesh.c:1482:    float y0 = cfg->detpos[0].y;
mmc_mesh.c:1483:    float xrange = cfg->detparam1.x + cfg->detparam2.x;
mmc_mesh.c:1484:    float yrange = cfg->detparam1.y + cfg->detparam2.y;
mmc_mesh.c:1485:    int xsize = cfg->detparam1.w;
mmc_mesh.c:1486:    int ysize = cfg->detparam2.w;
mmc_mesh.c:1487:    float xloc = ppath[(photonid + 1) * colcount - 7];
mmc_mesh.c:1488:    float yloc = ppath[(photonid + 1) * colcount - 6];
mmc_mesh.c:1489:    int xindex = (xloc - x0) / xrange * xsize;
mmc_mesh.c:1490:    int yindex = (yloc - y0) / yrange * ysize;
mmc_mesh.c:1492:    if (xindex < 0 || xindex > xsize - 1 || yindex < 0 || yindex > ysize - 1) {
mmc_mesh.c:1496:    return cfg->detpattern[yindex * xsize + xindex];
mmc_mesh.c:1504: * and consider the length unit and time-gates
mmc_mesh.c:1508: * @param[in] Eabsorb: total absorbed energy from ray-tracing accummulation
mmc_mesh.c:1509: * @param[in] Etotal: total launched energy, equal to photon number if not pattern-source
mmc_mesh.c:1512:/*see Eq (1) in Fang&Boas, Opt. Express, vol 17, No.22, pp. 20178-20190, Oct 2009*/
mmc_mesh.c:1517:    int datalen = (cfg->method == rtBLBadouelGrid) ? cfg->crop0.z : ( (cfg->basisorder) ? mesh->nn : mesh->ne);
mmc_mesh.c:1519:    if (cfg->issaveref && mesh->dref) {
mmc_mesh.c:1522:        for (i = 0; i < cfg->maxgate; i++)
mmc_mesh.c:1523:            for (j = 0; j < mesh->nf; j++) {
mmc_mesh.c:1524:                mesh->dref[i * mesh->nf + j] *= normalizor;
mmc_mesh.c:1528:    if (cfg->seed == SEED_FROM_FILE && (cfg->outputtype == otJacobian || cfg->outputtype == otWL || cfg->outputtype == otWP)) {
mmc_mesh.c:1529:        float normalizor = 1.f / (DELTA_MUA * cfg->nphoton);
mmc_mesh.c:1531:        if (cfg->outputtype == otWL || cfg->outputtype == otWP) {
mmc_mesh.c:1535:        for (i = 0; i < cfg->maxgate; i++)
mmc_mesh.c:1537:                mesh->weight[(i * datalen + j)*cfg->srcnum + pair] *= normalizor;
mmc_mesh.c:1543:    if (cfg->outputtype == otEnergy) {
mmc_mesh.c:1546:        for (i = 0; i < cfg->maxgate; i++)
mmc_mesh.c:1548:                mesh->weight[(i * datalen + j)*cfg->srcnum + pair] *= normalizor;
mmc_mesh.c:1555:    if (cfg->method == rtBLBadouelGrid) {
mmc_mesh.c:1556:        normalizor = 1.0 / (Etotal * cfg->unitinmm * cfg->unitinmm * cfg->unitinmm); /*scaling factor*/
mmc_mesh.c:1560:        if (cfg->basisorder) {
mmc_mesh.c:1561:            for (i = 0; i < cfg->maxgate; i++)
mmc_mesh.c:1563:                    if (mesh->nvol[j] > 0.f) {
mmc_mesh.c:1564:                        mesh->weight[(i * datalen + j)*cfg->srcnum + pair] /= mesh->nvol[j];
mmc_mesh.c:1567:            for (i = 0; i < mesh->ne; i++) {
mmc_mesh.c:1568:                ee = (int*)(mesh->elem + i * mesh->elemlen);
mmc_mesh.c:1571:                for (j = 0; j < cfg->maxgate; j++)
mmc_mesh.c:1573:                        energyelem += mesh->weight[(j * mesh->nn + ee[k] - 1) * cfg->srcnum + pair];    /*1/4 factor is absorbed two lines below*/
mmc_mesh.c:1576:                energydeposit += energyelem * mesh->evol[i] * mesh->med[mesh->type[i]].mua; /**mesh->med[mesh->type[i]].n;*/
mmc_mesh.c:1582:                for (j = 0; j < cfg->maxgate; j++) {
mmc_mesh.c:1583:                    energydeposit += mesh->weight[(j * datalen + i) * cfg->srcnum + pair];
mmc_mesh.c:1587:                energyelem = mesh->evol[i] * mesh->med[mesh->type[i]].mua;
mmc_mesh.c:1589:                for (j = 0; j < cfg->maxgate; j++) {
mmc_mesh.c:1590:                    mesh->weight[(j * datalen + i)*cfg->srcnum + pair] /= energyelem;
mmc_mesh.c:1598:    if (cfg->outputtype == otFlux) {
mmc_mesh.c:1599:        normalizor /= cfg->tstep;
mmc_mesh.c:1603:    // mesh->weight is an linearized array to hold all photon voxels/tetrahedrons
mmc_mesh.c:1605:    for (i = 0; i < cfg->maxgate; i++)
mmc_mesh.c:1607:            mesh->weight[(i * datalen + j)*cfg->srcnum + pair] *= normalizor;
mmc_tictoc.h:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_tictoc.h:5:**  \copyright Qianqian Fang, 2010-2021
mmc_tictoc.h:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_tictoc.h:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_tictoc.h:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_tictoc.h:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_tictoc.h:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_tictoc.h:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_tictoc.h:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_tictoc.h:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_tictoc.h:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_tictoc.h:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_tictoc.h:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_tictoc.h:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
Binary file built/mmc_cuda_query_gpu.o matches
Binary file built/mmc_host.o matches
Binary file built/mmc_optix_utils.ptx.o matches
Binary file built/mmc_rand_xorshift128p.o matches
built/mmc_optix_utils.ptx.d:2: /home/users/aidenlewis/OptiX-7.6.0/include/optix_function_table_definition.h \
built/mmc_optix_utils.ptx.d:3: /home/users/aidenlewis/OptiX-7.6.0/include/optix_function_table.h \
built/mmc_optix_utils.ptx.d:4: /home/users/aidenlewis/OptiX-7.6.0/include/optix_types.h \
built/mmc_optix_utils.ptx.d:5: /home/users/aidenlewis/OptiX-7.6.0/include/optix_7_types.h \
built/mmc_optix_utils.ptx.d:7: /home/users/aidenlewis/OptiX-7.6.0/SDK/sutil/vec_math.h \
built/mmc_optix_utils.ptx.d:8: /home/users/aidenlewis/OptiX-7.6.0/SDK/sutil/Preprocessor.h \
built/mmc_optix_utils.ptx.d:27: /home/users/aidenlewis/OptiX-7.6.0/include/optix.h \
built/mmc_optix_utils.ptx.d:28: /home/users/aidenlewis/OptiX-7.6.0/include/optix_host.h \
built/mmc_optix_utils.ptx.d:29: /home/users/aidenlewis/OptiX-7.6.0/include/optix_7_host.h \
built/mmc_optix_utils.ptx.d:30: /home/users/aidenlewis/OptiX-7.6.0/include/optix_stubs.h incbin.h \
built/mmc_optix_utils.ptx.d:37:/home/users/aidenlewis/OptiX-7.6.0/include/optix_function_table_definition.h:
built/mmc_optix_utils.ptx.d:39:/home/users/aidenlewis/OptiX-7.6.0/include/optix_function_table.h:
built/mmc_optix_utils.ptx.d:41:/home/users/aidenlewis/OptiX-7.6.0/include/optix_types.h:
built/mmc_optix_utils.ptx.d:43:/home/users/aidenlewis/OptiX-7.6.0/include/optix_7_types.h:
built/mmc_optix_utils.ptx.d:47:/home/users/aidenlewis/OptiX-7.6.0/SDK/sutil/vec_math.h:
built/mmc_optix_utils.ptx.d:49:/home/users/aidenlewis/OptiX-7.6.0/SDK/sutil/Preprocessor.h:
built/mmc_optix_utils.ptx.d:91:/home/users/aidenlewis/OptiX-7.6.0/include/optix.h:
built/mmc_optix_utils.ptx.d:93:/home/users/aidenlewis/OptiX-7.6.0/include/optix_host.h:
built/mmc_optix_utils.ptx.d:95:/home/users/aidenlewis/OptiX-7.6.0/include/optix_7_host.h:
built/mmc_optix_utils.ptx.d:97:/home/users/aidenlewis/OptiX-7.6.0/include/optix_stubs.h:
Binary file built/mmc_highorder.o matches
Binary file built/mmc_utils.o matches
Binary file built/mmc_cl_host.o matches
Binary file built/mmc_raytrace.o matches
Binary file built/mmc.o matches
Binary file built/mmc_mesh.o matches
Binary file built/mmc_cl_utils.o matches
Binary file built/mmc_tictoc.o matches
Binary file built/cjson/cJSON.o matches
built/mmc_optix_core.d:54:    /home/users/aidenlewis/OptiX-7.6.0/include/optix.h \
built/mmc_optix_core.d:55:    /home/users/aidenlewis/OptiX-7.6.0/include/optix_device.h \
built/mmc_optix_core.d:56:    /home/users/aidenlewis/OptiX-7.6.0/include/optix_7_device.h \
built/mmc_optix_core.d:57:    /home/users/aidenlewis/OptiX-7.6.0/include/optix_7_types.h \
built/mmc_optix_core.d:58:    /home/users/aidenlewis/OptiX-7.6.0/include/internal/optix_7_device_impl.h \
built/mmc_optix_core.d:59:    /home/users/aidenlewis/OptiX-7.6.0/include/internal/optix_7_device_impl_exception.h \
built/mmc_optix_core.d:60:    /home/users/aidenlewis/OptiX-7.6.0/include/internal/optix_7_device_impl_transformations.h \
built/mmc_optix_core.d:61:    /home/users/aidenlewis/OptiX-7.6.0/include/optix_types.h \
built/mmc_optix_core.d:62:    /home/users/aidenlewis/OptiX-7.6.0/SDK/sutil/vec_math.h \
built/mmc_optix_core.d:63:    /home/users/aidenlewis/OptiX-7.6.0/SDK/sutil/Preprocessor.h \
built/mmc_optix_core.d:175:/home/users/aidenlewis/OptiX-7.6.0/include/optix.h:
built/mmc_optix_core.d:177:/home/users/aidenlewis/OptiX-7.6.0/include/optix_device.h:
built/mmc_optix_core.d:179:/home/users/aidenlewis/OptiX-7.6.0/include/optix_7_device.h:
built/mmc_optix_core.d:181:/home/users/aidenlewis/OptiX-7.6.0/include/optix_7_types.h:
built/mmc_optix_core.d:183:/home/users/aidenlewis/OptiX-7.6.0/include/internal/optix_7_device_impl.h:
built/mmc_optix_core.d:185:/home/users/aidenlewis/OptiX-7.6.0/include/internal/optix_7_device_impl_exception.h:
built/mmc_optix_core.d:187:/home/users/aidenlewis/OptiX-7.6.0/include/internal/optix_7_device_impl_transformations.h:
built/mmc_optix_core.d:189:/home/users/aidenlewis/OptiX-7.6.0/include/optix_types.h:
built/mmc_optix_core.d:191:/home/users/aidenlewis/OptiX-7.6.0/SDK/sutil/vec_math.h:
built/mmc_optix_core.d:193:/home/users/aidenlewis/OptiX-7.6.0/SDK/sutil/Preprocessor.h:
Binary file built/mmc_optix_host.o matches
Binary file built/ubj/ubjw.o matches
built/mmc_optix_host.d:21: /home/users/aidenlewis/OptiX-7.6.0/include/optix.h \
built/mmc_optix_host.d:22: /home/users/aidenlewis/OptiX-7.6.0/include/optix_host.h \
built/mmc_optix_host.d:23: /home/users/aidenlewis/OptiX-7.6.0/include/optix_7_host.h \
built/mmc_optix_host.d:24: /home/users/aidenlewis/OptiX-7.6.0/include/optix_7_types.h \
built/mmc_optix_host.d:26: /home/users/aidenlewis/OptiX-7.6.0/include/optix_function_table.h \
built/mmc_optix_host.d:27: /home/users/aidenlewis/OptiX-7.6.0/include/optix_types.h \
built/mmc_optix_host.d:28: /home/users/aidenlewis/OptiX-7.6.0/include/optix_stubs.h \
built/mmc_optix_host.d:91:/home/users/aidenlewis/OptiX-7.6.0/include/optix.h:
built/mmc_optix_host.d:93:/home/users/aidenlewis/OptiX-7.6.0/include/optix_host.h:
built/mmc_optix_host.d:95:/home/users/aidenlewis/OptiX-7.6.0/include/optix_7_host.h:
built/mmc_optix_host.d:97:/home/users/aidenlewis/OptiX-7.6.0/include/optix_7_types.h:
built/mmc_optix_host.d:101:/home/users/aidenlewis/OptiX-7.6.0/include/optix_function_table.h:
built/mmc_optix_host.d:103:/home/users/aidenlewis/OptiX-7.6.0/include/optix_types.h:
built/mmc_optix_host.d:105:/home/users/aidenlewis/OptiX-7.6.0/include/optix_stubs.h:
built/mmc_cuda_query_gpu.d:2:    /usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h \
built/mmc_cuda_query_gpu.d:3:    /usr/local/cuda/bin/../targets/x86_64-linux/include/crt/host_config.h \
built/mmc_cuda_query_gpu.d:4:    /usr/local/cuda/bin/../targets/x86_64-linux/include/builtin_types.h \
built/mmc_cuda_query_gpu.d:5:    /usr/local/cuda/bin/../targets/x86_64-linux/include/device_types.h \
built/mmc_cuda_query_gpu.d:6:    /usr/local/cuda/bin/../targets/x86_64-linux/include/crt/host_defines.h \
built/mmc_cuda_query_gpu.d:7:    /usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h \
built/mmc_cuda_query_gpu.d:8:    /usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h \
built/mmc_cuda_query_gpu.d:9:    /usr/local/cuda/bin/../targets/x86_64-linux/include/surface_types.h \
built/mmc_cuda_query_gpu.d:10:    /usr/local/cuda/bin/../targets/x86_64-linux/include/texture_types.h \
built/mmc_cuda_query_gpu.d:11:    /usr/local/cuda/bin/../targets/x86_64-linux/include/library_types.h \
built/mmc_cuda_query_gpu.d:12:    /usr/local/cuda/bin/../targets/x86_64-linux/include/channel_descriptor.h \
built/mmc_cuda_query_gpu.d:13:    /usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h \
built/mmc_cuda_query_gpu.d:14:    /usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_device_runtime_api.h \
built/mmc_cuda_query_gpu.d:15:    /usr/local/cuda/bin/../targets/x86_64-linux/include/driver_functions.h \
built/mmc_cuda_query_gpu.d:16:    /usr/local/cuda/bin/../targets/x86_64-linux/include/vector_functions.h \
built/mmc_cuda_query_gpu.d:17:    /usr/local/cuda/bin/../targets/x86_64-linux/include/vector_functions.hpp \
built/mmc_cuda_query_gpu.d:18:    /usr/local/cuda/bin/../targets/x86_64-linux/include/crt/common_functions.h \
built/mmc_cuda_query_gpu.d:19:    /usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h \
built/mmc_cuda_query_gpu.d:20:    /usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.hpp \
built/mmc_cuda_query_gpu.d:21:    /usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_surface_types.h \
built/mmc_cuda_query_gpu.d:22:    /usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_texture_types.h \
built/mmc_cuda_query_gpu.d:23:    /usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.h \
built/mmc_cuda_query_gpu.d:24:    /usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.hpp \
built/mmc_cuda_query_gpu.d:25:    /usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h \
built/mmc_cuda_query_gpu.d:26:    /usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.hpp \
built/mmc_cuda_query_gpu.d:27:    /usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_double_functions.h \
built/mmc_cuda_query_gpu.d:28:    /usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_double_functions.hpp \
built/mmc_cuda_query_gpu.d:29:    /usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_atomic_functions.h \
built/mmc_cuda_query_gpu.d:30:    /usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_atomic_functions.hpp \
built/mmc_cuda_query_gpu.d:31:    /usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_atomic_functions.h \
built/mmc_cuda_query_gpu.d:32:    /usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_atomic_functions.hpp \
built/mmc_cuda_query_gpu.d:33:    /usr/local/cuda/bin/../targets/x86_64-linux/include/sm_35_atomic_functions.h \
built/mmc_cuda_query_gpu.d:34:    /usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h \
built/mmc_cuda_query_gpu.d:35:    /usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.hpp \
built/mmc_cuda_query_gpu.d:36:    /usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_intrinsics.h \
built/mmc_cuda_query_gpu.d:37:    /usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_intrinsics.hpp \
built/mmc_cuda_query_gpu.d:38:    /usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h \
built/mmc_cuda_query_gpu.d:39:    /usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.hpp \
built/mmc_cuda_query_gpu.d:40:    /usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h \
built/mmc_cuda_query_gpu.d:41:    /usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.hpp \
built/mmc_cuda_query_gpu.d:42:    /usr/local/cuda/bin/../targets/x86_64-linux/include/sm_35_intrinsics.h \
built/mmc_cuda_query_gpu.d:43:    /usr/local/cuda/bin/../targets/x86_64-linux/include/sm_61_intrinsics.h \
built/mmc_cuda_query_gpu.d:44:    /usr/local/cuda/bin/../targets/x86_64-linux/include/sm_61_intrinsics.hpp \
built/mmc_cuda_query_gpu.d:45:    /usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.h \
built/mmc_cuda_query_gpu.d:46:    /usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.hpp \
built/mmc_cuda_query_gpu.d:47:    /usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_80_rt.h \
built/mmc_cuda_query_gpu.d:48:    /usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_80_rt.hpp \
built/mmc_cuda_query_gpu.d:49:    /usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h \
built/mmc_cuda_query_gpu.d:50:    /usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h \
built/mmc_cuda_query_gpu.d:51:    /usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h \
built/mmc_cuda_query_gpu.d:52:    /usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h \
built/mmc_cuda_query_gpu.d:53:    /usr/local/cuda/bin/../targets/x86_64-linux/include/device_launch_parameters.h \
built/mmc_cuda_query_gpu.d:58:    /usr/local/cuda/bin/../targets/x86_64-linux/include/cuda.h
built/mmc_cuda_query_gpu.d:60:/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h:
built/mmc_cuda_query_gpu.d:62:/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/host_config.h:
built/mmc_cuda_query_gpu.d:64:/usr/local/cuda/bin/../targets/x86_64-linux/include/builtin_types.h:
built/mmc_cuda_query_gpu.d:66:/usr/local/cuda/bin/../targets/x86_64-linux/include/device_types.h:
built/mmc_cuda_query_gpu.d:68:/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/host_defines.h:
built/mmc_cuda_query_gpu.d:70:/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h:
built/mmc_cuda_query_gpu.d:72:/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h:
built/mmc_cuda_query_gpu.d:74:/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_types.h:
built/mmc_cuda_query_gpu.d:76:/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_types.h:
built/mmc_cuda_query_gpu.d:78:/usr/local/cuda/bin/../targets/x86_64-linux/include/library_types.h:
built/mmc_cuda_query_gpu.d:80:/usr/local/cuda/bin/../targets/x86_64-linux/include/channel_descriptor.h:
built/mmc_cuda_query_gpu.d:82:/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h:
built/mmc_cuda_query_gpu.d:84:/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_device_runtime_api.h:
built/mmc_cuda_query_gpu.d:86:/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_functions.h:
built/mmc_cuda_query_gpu.d:88:/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_functions.h:
built/mmc_cuda_query_gpu.d:90:/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_functions.hpp:
built/mmc_cuda_query_gpu.d:92:/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/common_functions.h:
built/mmc_cuda_query_gpu.d:94:/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h:
built/mmc_cuda_query_gpu.d:96:/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.hpp:
built/mmc_cuda_query_gpu.d:98:/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_surface_types.h:
built/mmc_cuda_query_gpu.d:100:/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_texture_types.h:
built/mmc_cuda_query_gpu.d:102:/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.h:
built/mmc_cuda_query_gpu.d:104:/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.hpp:
built/mmc_cuda_query_gpu.d:106:/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h:
built/mmc_cuda_query_gpu.d:108:/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.hpp:
built/mmc_cuda_query_gpu.d:110:/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_double_functions.h:
built/mmc_cuda_query_gpu.d:112:/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_double_functions.hpp:
built/mmc_cuda_query_gpu.d:114:/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_atomic_functions.h:
built/mmc_cuda_query_gpu.d:116:/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_atomic_functions.hpp:
built/mmc_cuda_query_gpu.d:118:/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_atomic_functions.h:
built/mmc_cuda_query_gpu.d:120:/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_atomic_functions.hpp:
built/mmc_cuda_query_gpu.d:122:/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_35_atomic_functions.h:
built/mmc_cuda_query_gpu.d:124:/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h:
built/mmc_cuda_query_gpu.d:126:/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.hpp:
built/mmc_cuda_query_gpu.d:128:/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_intrinsics.h:
built/mmc_cuda_query_gpu.d:130:/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_intrinsics.hpp:
built/mmc_cuda_query_gpu.d:132:/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h:
built/mmc_cuda_query_gpu.d:134:/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.hpp:
built/mmc_cuda_query_gpu.d:136:/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h:
built/mmc_cuda_query_gpu.d:138:/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.hpp:
built/mmc_cuda_query_gpu.d:140:/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_35_intrinsics.h:
built/mmc_cuda_query_gpu.d:142:/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_61_intrinsics.h:
built/mmc_cuda_query_gpu.d:144:/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_61_intrinsics.hpp:
built/mmc_cuda_query_gpu.d:146:/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.h:
built/mmc_cuda_query_gpu.d:148:/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.hpp:
built/mmc_cuda_query_gpu.d:150:/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_80_rt.h:
built/mmc_cuda_query_gpu.d:152:/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_80_rt.hpp:
built/mmc_cuda_query_gpu.d:154:/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h:
built/mmc_cuda_query_gpu.d:156:/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h:
built/mmc_cuda_query_gpu.d:158:/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h:
built/mmc_cuda_query_gpu.d:160:/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h:
built/mmc_cuda_query_gpu.d:162:/usr/local/cuda/bin/../targets/x86_64-linux/include/device_launch_parameters.h:
built/mmc_cuda_query_gpu.d:172:/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda.h:
built/mmc_optix_core.ptx:4:// Compiler Build ID: CL-31057947
built/mmc_optix_core.ptx:437:	add.s32 	%r7, %r95, -1;
built/mmc_optix_core.ptx:758:	add.s32 	%r195, %r195, -2;
built/mmc_optix_core.ptx:1145:	mov.pred 	%p37, -1;
built/mmc_optix_core.ptx:1548:	add.s32 	%r7, %r85, -1;
built/mmc_optix_core.ptx:1857:	add.s32 	%r175, %r175, -2;
built/mmc_optix_core.ptx:2843:	.file	1 "/drives/mobi1/users/aidenlewis/optix_immc_projects/optix-shijiever/mmc/src/mmc_optix_core.cu"
built/mmc_optix_core.ptx:2844:	.file	2 "/home/users/aidenlewis/OptiX-7.6.0/include/internal/optix_7_device_impl.h"
built/mmc_optix_core.ptx:2845:	.file	3 "/drives/mobi1/users/aidenlewis/optix_immc_projects/optix-shijiever/mmc/src/random.cu"
built/mmc_optix_core.ptx:2846:	.file	4 "/drives/mobi1/users/aidenlewis/optix_immc_projects/optix-shijiever/mmc/src/mmc_optix_ray.h"
built/mmc_optix_core.ptx:2847:	.file	5 "/home/users/aidenlewis/OptiX-7.6.0/SDK/sutil/vec_math.h"
CUDABuffer.h:3:// Copyright 2018-2019 Ingo Wald                                            //
CUDABuffer.h:9://     http://www.apache.org/licenses/LICENSE-2.0                           //
CUDABuffer.h:25:/*! \namespace osc - Optix Siggraph Course */
CUDABuffer.h:28:/*! simple wrapper for creating, and managing a device-side CUDA
CUDABuffer.h:39:    //! re-size buffer to given number of bytes
CUDABuffer.h:51:        this->sizeInBytes = size;
mmc_rand_logistic.h:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_rand_logistic.h:5:**  \copyright Qianqian Fang, 2010-2021
mmc_rand_logistic.h:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_rand_logistic.h:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_rand_logistic.h:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_rand_logistic.h:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_rand_logistic.h:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_rand_logistic.h:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_rand_logistic.h:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_rand_logistic.h:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_rand_logistic.h:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_rand_logistic.h:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_rand_logistic.h:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_rand_logistic.h:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_rand_logistic.h:53:#define MCX_RNG_NAME       "Logistic-Lattice"
mmc_cl_utils.c:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_cl_utils.c:5:**  \copyright Qianqian Fang, 2010-2021
mmc_cl_utils.c:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_cl_utils.c:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_cl_utils.c:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_cl_utils.c:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_cl_utils.c:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_cl_utils.c:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_cl_utils.c:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_cl_utils.c:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_cl_utils.c:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_cl_utils.c:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_cl_utils.c:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_cl_utils.c:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_cl_utils.c:183:            return strdup("Invalid mip-map level");
mmc_cl_utils.c:196:        mcx_error(-(int)cuerr, print_cl_errstring(cuerr), file, linenum);
mmc_cl_utils.c:230: * their parameters. This is used when -L or -I is used.
mmc_cl_utils.c:270:                if (cfg->isgpuinfo) {
mmc_cl_utils.c:271:                    MMC_FPRINTF(cfg->flog, "Platform [%d] Name %s\n", i, pbuf);
mmc_cl_utils.c:304:                        cuinfo.maxgate = cfg->maxgate;
mmc_cl_utils.c:332:                        if (cfg->isgpuinfo) {
mmc_cl_utils.c:333:                            MMC_FPRINTF(cfg->flog, "============ %s device ID %d [%d of %d]: %s  ============\n", devname[j], cuid, k + 1, devnum, cuinfo.name);
mmc_cl_utils.c:334:                            MMC_FPRINTF(cfg->flog, " Device %d of %d:\t\t%s\n", cuid + 1, devnum, cuinfo.name);
mmc_cl_utils.c:335:                            MMC_FPRINTF(cfg->flog, " Compute units   :\t%d core(s)\n", (uint)cuinfo.sm);
mmc_cl_utils.c:336:                            MMC_FPRINTF(cfg->flog, " Global memory   :\t%ld B\n", (unsigned long)cuinfo.globalmem);
mmc_cl_utils.c:337:                            MMC_FPRINTF(cfg->flog, " Local memory    :\t%ld B\n", (unsigned long)cuinfo.sharedmem);
mmc_cl_utils.c:338:                            MMC_FPRINTF(cfg->flog, " Constant memory :\t%ld B\n", (unsigned long)cuinfo.constmem);
mmc_cl_utils.c:339:                            MMC_FPRINTF(cfg->flog, " Clock speed     :\t%d MHz\n", cuinfo.clock);
mmc_cl_utils.c:342:                                MMC_FPRINTF(cfg->flog, " Compute Capacity:\t%d.%d\n", cuinfo.major, cuinfo.minor);
mmc_cl_utils.c:343:                                MMC_FPRINTF(cfg->flog, " Stream Processor:\t%d\n", cuinfo.core);
mmc_cl_utils.c:345:                                MMC_FPRINTF(cfg->flog, " GFXIP version:   \t%d.%d\n", cuinfo.major, cuinfo.minor);
mmc_cl_utils.c:346:                                MMC_FPRINTF(cfg->flog, " Stream Processor:\t%d\n", cuinfo.core);
mmc_cl_utils.c:349:                            MMC_FPRINTF(cfg->flog, " Vendor name    :\t%s\n", VendorList[cuinfo.vendor]);
mmc_cl_utils.c:350:                            MMC_FPRINTF(cfg->flog, " Auto-thread    :\t%d\n", (uint)cuinfo.autothread);
mmc_cl_utils.c:351:                            MMC_FPRINTF(cfg->flog, " Auto-block     :\t%d\n", (uint)cuinfo.autoblock);
mmc_cl_utils.c:355:                            if (cfg->deviceid[cuid++] == '1') {
mmc_cl_utils.c:361:                                    fflush(cfg->flog);
mmc_cl_utils.c:362:                                    exit(-1);
mmc_cl_utils.c:391:    if (cfg->isgpuinfo == 2 && cfg->parentid == mpStandalone) {
mmc_raytrace.c:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_raytrace.c:5:**  \copyright Qianqian Fang, 2010-2021
mmc_raytrace.c:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_raytrace.c:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_raytrace.c:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_raytrace.c:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_raytrace.c:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_raytrace.c:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_raytrace.c:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_raytrace.c:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_raytrace.c:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_raytrace.c:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_raytrace.c:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_raytrace.c:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_raytrace.c:35:\brief   Core unit for mash-based photon transport using ray tracing algorithms
mmc_raytrace.c:43:/**<  Macro to enable SSE4 based ray-tracers */
mmc_raytrace.c:47:    __m128 int_coef;                            /**<  a global variable used for SSE4 ray-tracers */
mmc_raytrace.c:63: * triangular face made of 3 directed edges. The numbers [0-5] are the
mmc_raytrace.c:65: * 0:[0->1], 1:[0->2], 2: [0->3], 3:[1->2], 4:[1->3], 5:[2->3]
mmc_raytrace.c:73: * \brief Tetrahedron faces, in clock-wise orders, represented using local node indices
mmc_raytrace.c:75: * node-connectivity, i.e. nc[4] points to the 4 facets of a tetrahedron, with each
mmc_raytrace.c:76: * triangular face made of 3 nodes. The numbers [0-4] are the
mmc_raytrace.c:78: * are in clock-wise orders.
mmc_raytrace.c:84: * \brief Tetrahedron faces, in counter-clock-wise orders, represented using local node indices
mmc_raytrace.c:86: * out is like nc[] but with counter-clock-wise orientation. this makes
mmc_raytrace.c:90:extern const int out[4][3];     /**< defined in simpmesh.c, node orders for each face, in counter-clock-wise orders*/
mmc_raytrace.c:93: * \brief The local index of the node with an opposite face to the i-th face defined in nc[][]
mmc_raytrace.c:95: * nc[i] <-> node[facemap[i]]
mmc_raytrace.c:106: * nc[ifacemap[i]] <-> node[i]
mmc_raytrace.c:115: * \brief Index mapping from the i-th face-neighbors (facenb) to the face defined in nc[][]
mmc_raytrace.c:117: * facenb[i] <-> nc[faceorder[i]]
mmc_raytrace.c:126: * \brief Index mapping from the i-th face defined in nc[][] to the face-neighbor (facenb) face orders
mmc_raytrace.c:128: * nc[ifaceorder[i]] <-> facenb[i]
mmc_raytrace.c:154:    pout->x = w->x * p1->x + w->y * p2->x + w->z * p3->x;
mmc_raytrace.c:155:    pout->y = w->x * p1->y + w->y * p2->y + w->z * p3->y;
mmc_raytrace.c:156:    pout->z = w->x * p1->z + w->y * p2->z + w->z * p3->z;
mmc_raytrace.c:173:    pout->x = w1 * p1->x + w2 * p2->x + w3 * p3->x;
mmc_raytrace.c:174:    pout->y = w1 * p1->y + w2 * p2->y + w3 * p3->y;
mmc_raytrace.c:175:    pout->z = w1 * p1->z + w2 * p2->z + w3 * p3->z;
mmc_raytrace.c:179: * \brief Function to deal with ray-edge/ray-vertex intersections
mmc_raytrace.c:195:        vec_add(&c0, nodes + ee[i] - 1, &c0);
mmc_raytrace.c:198:    p->x += (c0.x * 0.25f - p->x) * FIX_PHOTON;
mmc_raytrace.c:199:    p->y += (c0.y * 0.25f - p->y) * FIX_PHOTON;
mmc_raytrace.c:200:    p->z += (c0.z * 0.25f - p->z) * FIX_PHOTON;
mmc_raytrace.c:204: * \brief Plucker-coordinate based ray-tracer to advance photon by one step
mmc_raytrace.c:206: * this function uses Plucker-coordinate based ray-triangle intersection
mmc_raytrace.c:210: * \param[in] tracer: the ray-tracer aux data structure
mmc_raytrace.c:220:    int i, tshift, eid, faceidx = -1;
mmc_raytrace.c:223:    float baryout[4] = {0.f, 0.f, 0.f, 0.f}, *baryp0 = &(r->bary0.x);
mmc_raytrace.c:226:    if (tracer->mesh == NULL || tracer->d == NULL || r->eid <= 0 || r->eid > tracer->mesh->ne) {
mmc_raytrace.c:227:        return -1;
mmc_raytrace.c:230:    eid = r->eid - 1;
mmc_raytrace.c:231:    r->faceid = -1;
mmc_raytrace.c:232:    r->isend = 0;
mmc_raytrace.c:233:    r->Lmove = 0.f;
mmc_raytrace.c:234:    vec_add(&(r->p0), &(r->vec), &p1);
mmc_raytrace.c:235:    vec_cross(&(r->p0), &p1, &pcrx);
mmc_raytrace.c:236:    ee = (int*)(tracer->mesh->elem + eid * tracer->mesh->elemlen);
mmc_raytrace.c:237:    prop = tracer->mesh->med + (tracer->mesh->type[eid]);
mmc_raytrace.c:238:    rc = prop->n * R_C0;
mmc_raytrace.c:239:    currweight = r->weight;
mmc_raytrace.c:240:    mus = (cfg->mcmethod == mmMCX) ? prop->mus : (prop->mua + prop->mus);
mmc_raytrace.c:244:        __m128 O = _mm_load_ps(&(r->vec.x));
mmc_raytrace.c:248:            D = _mm_load_ps(&(tracer->d[(eid) * 6 + i].x));
mmc_raytrace.c:249:            M = _mm_load_ps(&(tracer->m[(eid) * 6 + i].x));
mmc_raytrace.c:266:        w[i] = pinner(&(r->vec), &pcrx, tracer->d + (eid) * 6 + i, tracer->m + (eid) * 6 + i);
mmc_raytrace.c:272:    if (cfg->debuglevel & dlTracing) {
mmc_raytrace.c:273:        MMC_FPRINTF(cfg->flog, "%d \n", eid);
mmc_raytrace.c:276:    r->pout.x = MMC_UNDEFINED;
mmc_raytrace.c:279:        //if(cfg->debuglevel&dlTracing) MMC_FPRINTF(cfg->flog,"testing face [%d]\n",i);
mmc_raytrace.c:282:            w[fc[i][1]] = -w[fc[i][1]];    // can not go back
mmc_raytrace.c:287:            //if(cfg->debuglevel&dlTracingExit) MMC_FPRINTF(cfg->flog,"ray exits face %d[%d] of %d\n",i,faceorder[i],eid);
mmc_raytrace.c:289:            Rv = 1.f / (-w[fc[i][0]] - w[fc[i][1]] + w[fc[i][2]]);
mmc_raytrace.c:290:            baryout[nc[i][0]] = -w[fc[i][0]] * Rv;
mmc_raytrace.c:291:            baryout[nc[i][1]] = -w[fc[i][1]] * Rv;
mmc_raytrace.c:295:                      tracer->mesh->node + ee[nc[i][0]] - 1,
mmc_raytrace.c:296:                      tracer->mesh->node + ee[nc[i][1]] - 1,
mmc_raytrace.c:297:                      tracer->mesh->node + ee[nc[i][2]] - 1, &(r->pout));
mmc_raytrace.c:299:            //if(cfg->debuglevel&dlTracingExit) MMC_FPRINTF(cfg->flog,"exit point %f %f %f\n",r->pout.x,r->pout.y,r->pout.z);
mmc_raytrace.c:301:            Lp0 = dist(&(r->p0), &(r->pout));
mmc_raytrace.c:302:            dlen = (mus <= EPS) ? R_MIN_MUS : r->slen / mus;
mmc_raytrace.c:304:            r->faceid = faceorder[i];
mmc_raytrace.c:307:                int* enb = (int*)(tracer->mesh->facenb + eid * tracer->mesh->elemlen);
mmc_raytrace.c:308:                r->nexteid = enb[r->faceid];
mmc_raytrace.c:310:                int nexteid = (r->nexteid - 1) * 6;
mmc_raytrace.c:312:                if (r->nexteid > 0) {
mmc_raytrace.c:313:                    _mm_prefetch((char*) & ((tracer->m + nexteid)->x), _MM_HINT_T0);
mmc_raytrace.c:314:                    _mm_prefetch((char*) & ((tracer->m + (nexteid) * 6 + 4)->x), _MM_HINT_T0);
mmc_raytrace.c:315:                    _mm_prefetch((char*) & ((tracer->d + (nexteid) * 6)->x), _MM_HINT_T0);
mmc_raytrace.c:316:                    _mm_prefetch((char*) & ((tracer->d + (nexteid) * 6 + 4)->x), _MM_HINT_T0);
mmc_raytrace.c:321:            r->isend = (Lp0 > dlen);
mmc_raytrace.c:322:            r->Lmove = ((r->isend) ? dlen : Lp0);
mmc_raytrace.c:327:    visit->raytet++;
mmc_raytrace.c:329:    if (tracer->mesh->type[eid] == 0) {
mmc_raytrace.c:330:        visit->raytet0++;
mmc_raytrace.c:333:    if (r->pout.x != MMC_UNDEFINED) {
mmc_raytrace.c:334:        if ((int)((r->photontimer + r->Lmove * rc - cfg->tstart)*visit->rtstep) >= (int)((cfg->tend - cfg->tstart)*visit->rtstep)) { /*exit time window*/
mmc_raytrace.c:335:            r->faceid = -2;
mmc_raytrace.c:336:            r->pout.x = MMC_UNDEFINED;
mmc_raytrace.c:337:            r->Lmove = (cfg->tend - r->photontimer) / (prop->n * R_C0) - 1e-4f;
mmc_raytrace.c:340:        if (cfg->mcmethod == mmMCX) {
mmc_raytrace.c:341:            r->weight *= expf(-prop->mua * r->Lmove);
mmc_raytrace.c:344:        if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otJacobian) {
mmc_raytrace.c:345:            currweight = expf(-DELTA_MUA * r->Lmove);
mmc_raytrace.c:346:            currweight *= cfg->replayweight[r->photonid];
mmc_raytrace.c:347:            currweight += r->weight;
mmc_raytrace.c:348:        } else if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otWL) {
mmc_raytrace.c:349:            currweight = r->Lmove;
mmc_raytrace.c:350:            currweight *= cfg->replayweight[r->photonid];
mmc_raytrace.c:351:            currweight += r->weight;
mmc_raytrace.c:354:        r->slen -= r->Lmove * mus;
mmc_raytrace.c:356:        if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otWP) {
mmc_raytrace.c:357:            if (r->slen0 < EPS) {
mmc_raytrace.c:360:                currweight = r->Lmove * mus / r->slen0;
mmc_raytrace.c:363:            currweight *= cfg->replayweight[r->photonid];
mmc_raytrace.c:364:            currweight += r->weight;
mmc_raytrace.c:367:        r->p0.x += r->Lmove * r->vec.x;
mmc_raytrace.c:368:        r->p0.y += r->Lmove * r->vec.y;
mmc_raytrace.c:369:        r->p0.z += r->Lmove * r->vec.z;
mmc_raytrace.c:370:        //if(cfg->debuglevel&dlWeight) MMC_FPRINTF(cfg->flog,"update weight to %f and path end %d \n",r->weight,r->isend);
mmc_raytrace.c:372:        if (!cfg->basisorder) {
mmc_raytrace.c:373:            ww = currweight - r->weight;
mmc_raytrace.c:374:            r->Eabsorb += ww;
mmc_raytrace.c:375:            r->photontimer += r->Lmove * rc;
mmc_raytrace.c:377:            if (cfg->outputtype == otWL || cfg->outputtype == otWP) {
mmc_raytrace.c:378:                tshift = MIN( ((int)(cfg->replaytime[r->photonid] * visit->rtstep)), cfg->maxgate - 1 ) * tracer->mesh->ne;
mmc_raytrace.c:380:                tshift = MIN( ((int)((r->photontimer - cfg->tstart) * visit->rtstep)), cfg->maxgate - 1 ) * tracer->mesh->ne;
mmc_raytrace.c:383:            if (cfg->mcmethod == mmMCX) {
mmc_raytrace.c:384:                if (cfg->srctype != stPattern) {
mmc_raytrace.c:385:                    if (cfg->isatomic)
mmc_raytrace.c:387:                        tracer->mesh->weight[eid + tshift] += ww;
mmc_raytrace.c:389:                        tracer->mesh->weight[eid + tshift] += ww;
mmc_raytrace.c:392:                    int psize = (int)cfg->srcparam1.w * (int)cfg->srcparam2.w; // total number of pixels in each pattern
mmc_raytrace.c:395:                    for (pidx = 0; pidx < cfg->srcnum; pidx++) {
mmc_raytrace.c:396:                        if (cfg->isatomic)
mmc_raytrace.c:398:                            tracer->mesh->weight[(eid + tshift)*cfg->srcnum + pidx] += ww * cfg->srcpattern[pidx * psize + r->posidx];
mmc_raytrace.c:400:                            tracer->mesh->weight[(eid + tshift)*cfg->srcnum + pidx] += ww * cfg->srcpattern[pidx * psize + r->posidx];
mmc_raytrace.c:406:            if (cfg->debuglevel & dlBary) MMC_FPRINTF(cfg->flog, "Y [%f %f %f %f]\n",
mmc_raytrace.c:410:                r->photontimer += r->Lmove * rc;
mmc_raytrace.c:411:                ww = currweight - r->weight;
mmc_raytrace.c:413:                if (prop->mua > 0.f) {
mmc_raytrace.c:414:                    ratio = r->Lmove / Lp0;
mmc_raytrace.c:415:                    r->Eabsorb += ww;
mmc_raytrace.c:417:                    if (cfg->outputtype != otEnergy && cfg->outputtype != otWP) {
mmc_raytrace.c:418:                        ww /= prop->mua;
mmc_raytrace.c:421:                    if (cfg->outputtype == otWL || cfg->outputtype == otWP) {
mmc_raytrace.c:422:                        tshift = MIN( ((int)(cfg->replaytime[r->photonid] * visit->rtstep)), cfg->maxgate - 1 ) * tracer->mesh->nn;
mmc_raytrace.c:424:                        tshift = MIN( ((int)((r->photontimer - cfg->tstart) * visit->rtstep)), cfg->maxgate - 1 ) * tracer->mesh->nn;
mmc_raytrace.c:427:                    if (cfg->debuglevel & dlAccum) MMC_FPRINTF(cfg->flog, "A %f %f %f %e %d %e\n",
mmc_raytrace.c:428:                                r->p0.x - (r->Lmove * 0.5f)*r->vec.x, r->p0.y - (r->Lmove * 0.5f)*r->vec.y, r->p0.z - (r->Lmove * 0.5f)*r->vec.z, ww, eid + 1, dlen);
mmc_raytrace.c:432:                    if (r->isend)
mmc_raytrace.c:434:                            baryout[i] = (1.f - ratio) * baryp0[i] + ratio * baryout[i];
mmc_raytrace.c:437:                    if (cfg->mcmethod == mmMCX) {
mmc_raytrace.c:438:                        if (cfg->srctype != stPattern) {
mmc_raytrace.c:439:                            if (cfg->isatomic)
mmc_raytrace.c:442:                                    tracer->mesh->weight[ee[i] - 1 + tshift] += ww * (baryp0[i] + baryout[i]);
mmc_raytrace.c:445:                                    tracer->mesh->weight[ee[i] - 1 + tshift] += ww * (baryp0[i] + baryout[i]);
mmc_raytrace.c:448:                            int psize = (int)cfg->srcparam1.w * (int)cfg->srcparam2.w; // total number of pixels in each pattern
mmc_raytrace.c:451:                            for (pidx = 0; pidx < cfg->srcnum; pidx++) {
mmc_raytrace.c:452:                                if (cfg->isatomic)
mmc_raytrace.c:455:                                        tracer->mesh->weight[(ee[i] - 1 + tshift)*cfg->srcnum + pidx] += ww * cfg->srcpattern[pidx * psize + r->posidx] * (baryp0[i] + baryout[i]);
mmc_raytrace.c:458:                                        tracer->mesh->weight[(ee[i] - 1 + tshift)*cfg->srcnum + pidx] += ww * cfg->srcpattern[pidx * psize + r->posidx] * (baryp0[i] + baryout[i]);
mmc_raytrace.c:465:                if (r->isend) {
mmc_raytrace.c:468:                    if (r->nexteid && faceidx >= 0) {
mmc_raytrace.c:469:                        int j, k, *nextenb = (int*)(tracer->mesh->elem + (r->nexteid - 1) * tracer->mesh->elemlen);
mmc_raytrace.c:484:        if (r->faceid == -2) {
mmc_raytrace.c:489:    return r->slen;
mmc_raytrace.c:502: * \brief Havel-based SSE4 ray-triangle intersection test
mmc_raytrace.c:504: * this function uses Havel-based algorithm to test if a ray intersects
mmc_raytrace.c:514:    const __m128 n = _mm_load_ps(&vecN->x);
mmc_raytrace.c:522:    const __m128 oldt = _mm_load_ss(&bary->x);
mmc_raytrace.c:526:        const __m128 detu = _mm_dp_ps(detp, _mm_load_ps(&((vecN + 1)->x)), 0xf1);
mmc_raytrace.c:529:            const __m128 detv = _mm_dp_ps(detp, _mm_load_ps(&((vecN + 2)->x)), 0xf1);
mmc_raytrace.c:533:                _mm_store_ss(&bary->x, _mm_mul_ss(dett, inv_det));
mmc_raytrace.c:534:                _mm_store_ss(&bary->y, _mm_mul_ss(detu, inv_det));
mmc_raytrace.c:535:                _mm_store_ss(&bary->z, _mm_mul_ss(detv, inv_det));
mmc_raytrace.c:536:                //_mm_store_ps(&pout->x, _mm_mul_ps(detp,_mm_shuffle_ps(inv_det, inv_det, 0)));
mmc_raytrace.c:537:                return (bary->x == bary->x); // when a photon is outside, bary->x=NaN
mmc_raytrace.c:546: * \brief Havel-based SSE4 ray-tracer to advance photon by one step
mmc_raytrace.c:548: * this function uses Havel-based SSE4 ray-triangle intersection
mmc_raytrace.c:552: * \param[in] tracer: the ray-tracer aux data structure
mmc_raytrace.c:565:    if (tracer->mesh == NULL || tracer->m == NULL || r->eid <= 0 || r->eid > tracer->mesh->ne) {
mmc_raytrace.c:566:        return -1;
mmc_raytrace.c:569:    r->p0.w = 1.f;
mmc_raytrace.c:570:    r->vec.w = 0.f;
mmc_raytrace.c:571:    eid = r->eid - 1;
mmc_raytrace.c:573:    O = _mm_load_ps(&(r->p0.x));
mmc_raytrace.c:574:    T = _mm_load_ps(&(r->vec.x));
mmc_raytrace.c:577:    int* ee = (int*)(tracer->mesh->elem + eid * tracer->mesh->elemlen);
mmc_raytrace.c:578:    prop = tracer->mesh->med + (tracer->mesh->type[eid]);
mmc_raytrace.c:579:    rc = prop->n * R_C0;
mmc_raytrace.c:580:    currweight = r->weight;
mmc_raytrace.c:581:    mus = (cfg->mcmethod == mmMCX) ? prop->mus : (prop->mua + prop->mus);
mmc_raytrace.c:583:    r->pout.x = MMC_UNDEFINED;
mmc_raytrace.c:584:    r->faceid = -1;
mmc_raytrace.c:585:    r->isend = 0;
mmc_raytrace.c:586:    r->Lmove = 0.f;
mmc_raytrace.c:589:        if (havel_sse4(tracer->m + eid * 12 + i * 3, &bary, O, T)) {
mmc_raytrace.c:591:            r->faceid = faceorder[i];
mmc_raytrace.c:592:            dlen = (mus <= EPS) ? R_MIN_MUS : r->slen / mus;
mmc_raytrace.c:594:            r->isend = (Lp0 > dlen);
mmc_raytrace.c:595:            r->Lmove = ((r->isend) ? dlen : Lp0);
mmc_raytrace.c:597:            if (!r->isend) {
mmc_raytrace.c:598:                enb = (int*)(tracer->mesh->facenb + eid * tracer->mesh->elemlen);
mmc_raytrace.c:599:                r->nexteid = enb[r->faceid];
mmc_raytrace.c:601:                if (r->nexteid > 0) {
mmc_raytrace.c:602:                    nextenb = (int*)(tracer->m + (r->nexteid - 1) * 12);
mmc_raytrace.c:606:                    nextenb = (int*)(tracer->mesh->elem + (r->nexteid - 1) * tracer->mesh->elemlen);
mmc_raytrace.c:613:            _mm_store_ps(&(r->pout.x), S);
mmc_raytrace.c:615:            if ((int)((r->photontimer + r->Lmove * rc - cfg->tstart)*visit->rtstep) >= (int)((cfg->tend - cfg->tstart)*visit->rtstep)) { /*exit time window*/
mmc_raytrace.c:616:                r->faceid = -2;
mmc_raytrace.c:617:                r->pout.x = MMC_UNDEFINED;
mmc_raytrace.c:618:                r->Lmove = (cfg->tend - r->photontimer) / (prop->n * R_C0) - 1e-4f;
mmc_raytrace.c:621:            if (cfg->mcmethod == mmMCX) {
mmc_raytrace.c:622:                r->weight *= expf(-prop->mua * r->Lmove);
mmc_raytrace.c:625:            if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otJacobian) {
mmc_raytrace.c:626:                currweight = expf(-DELTA_MUA * r->Lmove);
mmc_raytrace.c:627:                currweight *= cfg->replayweight[r->photonid];
mmc_raytrace.c:628:                currweight += r->weight;
mmc_raytrace.c:629:            } else if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otWL) {
mmc_raytrace.c:630:                currweight = r->Lmove;
mmc_raytrace.c:631:                currweight *= cfg->replayweight[r->photonid];
mmc_raytrace.c:632:                currweight += r->weight;
mmc_raytrace.c:635:            r->slen -= r->Lmove * mus;
mmc_raytrace.c:637:            if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otWP) {
mmc_raytrace.c:638:                if (r->slen0 < EPS) {
mmc_raytrace.c:641:                    currweight = r->Lmove * mus / r->slen0;
mmc_raytrace.c:644:                currweight *= cfg->replayweight[r->photonid];
mmc_raytrace.c:645:                currweight += r->weight;
mmc_raytrace.c:652:            ww = currweight - r->weight;
mmc_raytrace.c:653:            r->photontimer += r->Lmove * rc;
mmc_raytrace.c:655:            if (prop->mua > 0.f) {
mmc_raytrace.c:656:                r->Eabsorb += ww;
mmc_raytrace.c:658:                if (cfg->outputtype != otEnergy && cfg->outputtype != otWP) {
mmc_raytrace.c:659:                    ww /= prop->mua;
mmc_raytrace.c:663:            if (cfg->outputtype == otWL || cfg->outputtype == otWP) {
mmc_raytrace.c:664:                tshift = MIN( ((int)(cfg->replaytime[r->photonid] * visit->rtstep)), cfg->maxgate - 1 ) * (cfg->basisorder ? tracer->mesh->nn : tracer->mesh->ne);
mmc_raytrace.c:666:                tshift = MIN( ((int)((r->photontimer - cfg->tstart) * visit->rtstep)), cfg->maxgate - 1 ) * (cfg->basisorder ? tracer->mesh->nn : tracer->mesh->ne);
mmc_raytrace.c:669:            if (cfg->debuglevel & dlAccum) MMC_FPRINTF(cfg->flog, "A %f %f %f %e %d %e\n",
mmc_raytrace.c:670:                        r->p0.x, r->p0.y, r->p0.z, bary.x, eid + 1, dlen);
mmc_raytrace.c:672:            T = _mm_mul_ps(T, _mm_set1_ps(r->Lmove));
mmc_raytrace.c:674:            _mm_store_ps(&(r->p0.x), S);
mmc_raytrace.c:676:            barypout[out[i][0]] = 1.f - bary.y - bary.z;
mmc_raytrace.c:681:            if (cfg->debuglevel & dlBary) MMC_FPRINTF(cfg->flog, "Y [%f %f %f %f]\n",
mmc_raytrace.c:685:            O = _mm_load_ps(&(r->bary0.x)); /* bary centric at p0 */
mmc_raytrace.c:687:            dlen = r->Lmove / bary.x;       /* normalized moving length */
mmc_raytrace.c:689:            if (cfg->debuglevel & dlAccum) MMC_FPRINTF(cfg->flog, "A %f %f %f %e %d %e\n",
mmc_raytrace.c:690:                        r->p0.x - (r->Lmove * 0.5f)*r->vec.x, r->p0.y - (r->Lmove * 0.5f)*r->vec.y, r->p0.z - (r->Lmove * 0.5f)*r->vec.z, ww, eid + 1, dlen);
mmc_raytrace.c:692:            if (r->isend) {                 /* S is the bary centric for the photon after move */
mmc_raytrace.c:693:                S = _mm_add_ps(_mm_mul_ps(T, _mm_set1_ps(dlen)), _mm_mul_ps(O, _mm_set1_ps(1.f - dlen)));
mmc_raytrace.c:698:            //if(cfg->debuglevel&dlBary)
mmc_raytrace.c:699:            //    MMC_FPRINTF(cfg->flog,"old bary0=[%f %f %f %f]\n",r->bary0.x,r->bary0.y,r->bary0.z,r->bary0.w);
mmc_raytrace.c:704:                float* barynext = &(r->bary0.x);
mmc_raytrace.c:715:                //if(cfg->debuglevel&dlBary) MMC_FPRINTF(cfg->flog,"[%d %d %d %d],[%d %d %d %d] - ",
mmc_raytrace.c:717:                //if(cfg->debuglevel&dlBary) MMC_FPRINTF(cfg->flog,"[%f %f %f %f],[%f %f %f %f]\n",barypout[0],barypout[1],barypout[2],barypout[3],
mmc_raytrace.c:720:                _mm_store_ps(&(r->bary0.x), S);
mmc_raytrace.c:723:            //if(cfg->debuglevel&dlBary)
mmc_raytrace.c:724:            //    MMC_FPRINTF(cfg->flog,"new bary0=[%f %f %f %f]\n",r->bary0.x,r->bary0.y,r->bary0.z,r->bary0.w);
mmc_raytrace.c:725:            if (cfg->mcmethod == mmMCX) {
mmc_raytrace.c:726:                if (!cfg->basisorder) {
mmc_raytrace.c:727:                    if (cfg->srctype != stPattern) {
mmc_raytrace.c:728:                        if (cfg->isatomic)
mmc_raytrace.c:730:                            tracer->mesh->weight[eid + tshift] += ww;
mmc_raytrace.c:732:                            tracer->mesh->weight[eid + tshift] += ww;
mmc_raytrace.c:735:                        int psize = (int)cfg->srcparam1.w * (int)cfg->srcparam2.w; // total number of pixels in each pattern
mmc_raytrace.c:738:                        for (pidx = 0; pidx < cfg->srcnum; pidx++) {
mmc_raytrace.c:739:                            if (cfg->isatomic)
mmc_raytrace.c:741:                                tracer->mesh->weight[(eid + tshift)*cfg->srcnum + pidx] += ww * cfg->srcpattern[pidx * psize + r->posidx];
mmc_raytrace.c:743:                                tracer->mesh->weight[(eid + tshift)*cfg->srcnum + pidx] += ww * cfg->srcpattern[pidx * psize + r->posidx];
mmc_raytrace.c:751:                    if (cfg->srctype != stPattern) {
mmc_raytrace.c:752:                        if (cfg->isatomic)
mmc_raytrace.c:755:                                tracer->mesh->weight[ee[j] - 1 + tshift] += barypout[j];
mmc_raytrace.c:758:                                tracer->mesh->weight[ee[j] - 1 + tshift] += barypout[j];
mmc_raytrace.c:761:                        int psize = (int)cfg->srcparam1.w * (int)cfg->srcparam2.w; // total number of pixels in each pattern
mmc_raytrace.c:764:                        for (pidx = 0; pidx < cfg->srcnum; pidx++) {
mmc_raytrace.c:765:                            if (cfg->isatomic)
mmc_raytrace.c:768:                                    tracer->mesh->weight[(ee[j] - 1 + tshift)*cfg->srcnum + pidx] += barypout[j] * cfg->srcpattern[pidx * psize + r->posidx];
mmc_raytrace.c:771:                                    tracer->mesh->weight[(ee[j] - 1 + tshift)*cfg->srcnum + pidx] += barypout[j] * cfg->srcpattern[pidx * psize + r->posidx];
mmc_raytrace.c:781:    visit->raytet++;
mmc_raytrace.c:783:    if (tracer->mesh->type[eid] == 0) {
mmc_raytrace.c:784:        visit->raytet0++;
mmc_raytrace.c:787:    r->p0.w = 0.f;
mmc_raytrace.c:789:    if (r->faceid == -2) {
mmc_raytrace.c:793:    return r->slen;
mmc_raytrace.c:797: * \brief Badouel-based SSE4 ray-tracer to advance photon by one step
mmc_raytrace.c:799: * this function uses Badouel-based SSE4 ray-triangle intersection
mmc_raytrace.c:801: * Branch-less Badouel algorithms do not calculate the Barycentric coordinates
mmc_raytrace.c:802: * and can only store energy loss using 0-th order basis function.
mmc_raytrace.c:805: * \param[in] tracer: the ray-tracer aux data structure
mmc_raytrace.c:814:    int i, tshift, faceidx = -1, eid;
mmc_raytrace.c:816:    if (tracer->mesh == NULL || tracer->m == NULL || r->eid <= 0 || r->eid > tracer->mesh->ne) {
mmc_raytrace.c:817:        return -1;
mmc_raytrace.c:820:    r->p0.w = 1.f;
mmc_raytrace.c:821:    r->vec.w = 0.f;
mmc_raytrace.c:822:    eid = r->eid - 1;
mmc_raytrace.c:824:    r->pout.x = MMC_UNDEFINED;
mmc_raytrace.c:825:    r->faceid = -1;
mmc_raytrace.c:826:    r->isend = 0;
mmc_raytrace.c:828:    const __m128 o = _mm_load_ps(&(r->p0.x));
mmc_raytrace.c:829:    const __m128 d = _mm_load_ps(&(r->vec.x));
mmc_raytrace.c:834:        n = _mm_load_ps(&(tracer->m[3 * ((eid << 2) + i)].x));
mmc_raytrace.c:848:            r->faceid = faceorder[i];
mmc_raytrace.c:852:    if (r->faceid >= 0) {
mmc_raytrace.c:854:        int* ee = (int*)(tracer->mesh->elem + eid * tracer->mesh->elemlen);
mmc_raytrace.c:856:        prop = tracer->mesh->med + (tracer->mesh->type[eid]);
mmc_raytrace.c:857:        rc = prop->n * R_C0;
mmc_raytrace.c:858:        currweight = r->weight;
mmc_raytrace.c:860:        mus = (cfg->mcmethod == mmMCX) ? prop->mus : (prop->mua + prop->mus);
mmc_raytrace.c:862:        dlen = (mus <= EPS) ? R_MIN_MUS : r->slen / mus;
mmc_raytrace.c:864:        r->isend = (Lp0 > dlen);
mmc_raytrace.c:865:        r->Lmove = ((r->isend) ? dlen : Lp0);
mmc_raytrace.c:867:        r->pout.x = r->p0.x + bary.x * r->vec.x;
mmc_raytrace.c:868:        r->pout.y = r->p0.y + bary.x * r->vec.y;
mmc_raytrace.c:869:        r->pout.z = r->p0.z + bary.x * r->vec.z;
mmc_raytrace.c:871:        if ((int)((r->photontimer + r->Lmove * rc - cfg->tstart)*visit->rtstep) >= (int)((cfg->tend - cfg->tstart)*visit->rtstep)) { /*exit time window*/
mmc_raytrace.c:872:            r->faceid = -2;
mmc_raytrace.c:873:            r->pout.x = MMC_UNDEFINED;
mmc_raytrace.c:874:            r->Lmove = (cfg->tend - r->photontimer) / (prop->n * R_C0) - 1e-4f;
mmc_raytrace.c:877:        if (cfg->mcmethod == mmMCX) {
mmc_raytrace.c:878:            r->weight *= expf(-prop->mua * r->Lmove);
mmc_raytrace.c:881:        if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otJacobian) {
mmc_raytrace.c:882:            currweight = expf(-DELTA_MUA * r->Lmove);
mmc_raytrace.c:883:            currweight *= cfg->replayweight[r->photonid];
mmc_raytrace.c:884:            currweight += r->weight;
mmc_raytrace.c:885:        } else if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otWL) {
mmc_raytrace.c:886:            currweight = r->Lmove;
mmc_raytrace.c:887:            currweight *= cfg->replayweight[r->photonid];
mmc_raytrace.c:888:            currweight += r->weight;
mmc_raytrace.c:891:        r->slen -= r->Lmove * mus;
mmc_raytrace.c:893:        if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otWP) {
mmc_raytrace.c:894:            if (r->slen0 < EPS) {
mmc_raytrace.c:897:                currweight = r->Lmove * mus / r->slen0;
mmc_raytrace.c:900:            currweight *= cfg->replayweight[r->photonid];
mmc_raytrace.c:901:            currweight += r->weight;
mmc_raytrace.c:905:            ww = currweight - r->weight;
mmc_raytrace.c:906:            r->Eabsorb += ww;
mmc_raytrace.c:907:            r->photontimer += r->Lmove * rc;
mmc_raytrace.c:909:            if (cfg->outputtype == otWL || cfg->outputtype == otWP) {
mmc_raytrace.c:910:                tshift = MIN( ((int)(cfg->replaytime[r->photonid] * visit->rtstep)), cfg->maxgate - 1 ) * (cfg->basisorder ? tracer->mesh->nn : tracer->mesh->ne);
mmc_raytrace.c:912:                tshift = MIN( ((int)((r->photontimer - cfg->tstart) * visit->rtstep)), cfg->maxgate - 1 ) * (cfg->basisorder ? tracer->mesh->nn : tracer->mesh->ne);
mmc_raytrace.c:915:            if (cfg->debuglevel & dlAccum) MMC_FPRINTF(cfg->flog, "A %f %f %f %e %d %e\n",
mmc_raytrace.c:916:                        r->p0.x, r->p0.y, r->p0.z, bary.x, eid + 1, dlen);
mmc_raytrace.c:918:            r->p0.x += r->Lmove * r->vec.x;
mmc_raytrace.c:919:            r->p0.y += r->Lmove * r->vec.y;
mmc_raytrace.c:920:            r->p0.z += r->Lmove * r->vec.z;
mmc_raytrace.c:922:            if (cfg->mcmethod == mmMCX) {
mmc_raytrace.c:923:                if (!cfg->basisorder) {
mmc_raytrace.c:924:                    if (cfg->isatomic)
mmc_raytrace.c:926:                        tracer->mesh->weight[eid + tshift] += ww;
mmc_raytrace.c:928:                        tracer->mesh->weight[eid + tshift] += ww;
mmc_raytrace.c:931:                    if (cfg->outputtype != otEnergy && cfg->outputtype != otWP) {
mmc_raytrace.c:932:                        ww /= prop->mua;
mmc_raytrace.c:937:                    if (cfg->isatomic)
mmc_raytrace.c:940:                            tracer->mesh->weight[ee[out[faceidx][i]] - 1 + tshift] += ww;
mmc_raytrace.c:943:                            tracer->mesh->weight[ee[out[faceidx][i]] - 1 + tshift] += ww;
mmc_raytrace.c:950:    visit->raytet++;
mmc_raytrace.c:952:    if (tracer->mesh->type[eid] == 0) {
mmc_raytrace.c:953:        visit->raytet0++;
mmc_raytrace.c:956:    r->p0.w = 0.f;
mmc_raytrace.c:958:    if (r->faceid == -2) {
mmc_raytrace.c:962:    return r->slen;
mmc_raytrace.c:967:    MMC_ERROR(-6, "wrong option, please recompile with SSE4 enabled");
mmc_raytrace.c:971:    MMC_ERROR(-6, "wrong option, please recompile with SSE4 enabled");
mmc_raytrace.c:988:    p2d[1] = tracer->mesh->node[ee[e2n[edgeid][0]] - 1];
mmc_raytrace.c:989:    p2d[0] = tracer->mesh->node[ee[e2n[edgeid][1]] - 1];
mmc_raytrace.c:996:    vec_diff(p2d + 1, &r->p0, &OP);
mmc_raytrace.c:1002:    vec_mult(&r->vec, r->Lmove, &OP);
mmc_raytrace.c:1003:    vec_add(&r->p0, &OP, &OP);      // P1
mmc_raytrace.c:1010:    r2 = r->roisize[edgeid] * r->roisize[edgeid];
mmc_raytrace.c:1013:    if (d2d[0] > r2 + EPS2 && d2d[1] < r2 - EPS2) {
mmc_raytrace.c:1015:    } else if (d2d[0] < r2 - EPS2 && d2d[1] > r2 + EPS2) {
mmc_raytrace.c:1019:    } else if (d2d[1] < r2 - EPS2) {
mmc_raytrace.c:1025: * \brief Compute the next step length for edge-based iMMC
mmc_raytrace.c:1032:    rt = r->roisize[index];
mmc_raytrace.c:1035:    if (hitstatus == htOutIn || hitstatus == htInOut) { // hit edgeroi out->in or in->out
mmc_raytrace.c:1045:        pt1[1] = d2d[1] * sqrtf(fabs(1 - theta * theta));
mmc_raytrace.c:1047:        dx = pt1[0] - pt0[0];
mmc_raytrace.c:1048:        dy = pt1[1] - pt0[1];
mmc_raytrace.c:1051:        delta = sqrtf(rt * rt * dr2 - Dp * Dp); // must be >0
mmc_raytrace.c:1053:        sgn = (dy >= 0) ? 1.0f : -1.0f;
mmc_raytrace.c:1055:        ph0[1] = (-Dp * dx + fabs(dy) * delta) * dr2;
mmc_raytrace.c:1056:        ph1[0] = (Dp * dy  - sgn * dx * delta) * dr2;
mmc_raytrace.c:1057:        ph1[1] = (-Dp * dx - fabs(dy) * delta) * dr2;
mmc_raytrace.c:1060:        if (d2d[0] > rt && d2d[1] < rt) { // out->in
mmc_raytrace.c:1069:        } else { // d2d[0]<rt && d2d[1]>rt, in->out
mmc_raytrace.c:1073:                Lratio = 1.f - sqrtf(Lratio / Dp);
mmc_raytrace.c:1076:                Lratio = 1.f - sqrtf(Lratio / Dp);
mmc_raytrace.c:1099:    *center = tracer->mesh->node + ee[index] - 1;
mmc_raytrace.c:1101:    npdist0 = dist2(&r->p0, *center);   // P0
mmc_raytrace.c:1102:    vec_mult(&r->vec, r->Lmove, &PP);
mmc_raytrace.c:1103:    vec_add(&r->p0, &PP, &PP);
mmc_raytrace.c:1106:    if (npdist0 > nr + EPS2 && npdist1 < nr - EPS2) {
mmc_raytrace.c:1108:    } else if (npdist0 < nr - EPS2 && npdist1 > nr + EPS2) {
mmc_raytrace.c:1112:    } else if (npdist1 < nr - EPS2) {
mmc_raytrace.c:1120: * \brief Compute the next step length for node-based iMMC
mmc_raytrace.c:1127:        vec_diff(center, &r->p0, &oc);
mmc_raytrace.c:1128:        temp1 = vec_dot(&r->vec, &oc);
mmc_raytrace.c:1129:        temp2 = oc.x * oc.x + oc.y * oc.y + oc.z * oc.z - (nr * nr);
mmc_raytrace.c:1130:        temp2 = sqrtf(fabs(temp1 * temp1 - temp2));
mmc_raytrace.c:1131:        d1 = -temp1 + temp2;
mmc_raytrace.c:1132:        d2 = -temp1 - temp2;
mmc_raytrace.c:1136:    return r->Lmove;
mmc_raytrace.c:1140: * \brief Compute the next step length for the face-based iMMC
mmc_raytrace.c:1146:    thick = r->roisize[faceid];
mmc_raytrace.c:1148:    vec_mult(&r->vec, r->Lmove, &ptemp);
mmc_raytrace.c:1149:    vec_add(&r->p0, &ptemp, &ptemp);    // P1: ptemp
mmc_raytrace.c:1151:    pf1 = tracer->mesh->node[ee[nc[ifaceorder[faceid]][0]] - 1]; // any point on face
mmc_raytrace.c:1152:    fnorm.x = (&(tracer->n[baseid].x))[ifaceorder[faceid]];     // normal vector of the face
mmc_raytrace.c:1153:    fnorm.y = (&(tracer->n[baseid].x))[ifaceorder[faceid] + 4];
mmc_raytrace.c:1154:    fnorm.z = (&(tracer->n[baseid].x))[ifaceorder[faceid] + 8];
mmc_raytrace.c:1156:    vec_diff(&r->p0, &pf1, &pv);
mmc_raytrace.c:1164:    if (distf0 > thick + EPS2 && distf1 < thick - EPS2) { // hit: out->in
mmc_raytrace.c:1165:        ratio = 1.f - (thick - distf1) / (distf0 - distf1);
mmc_raytrace.c:1167:    } else if (distf0 < thick - EPS2 && distf1 > thick + EPS2) { // hit: in->out
mmc_raytrace.c:1168:        ratio = (thick - distf0) / (distf1 - distf0);
mmc_raytrace.c:1180: * \brief Implicit MMC ray-tracing core function
mmc_raytrace.c:1182: * if doinit is set to 1, this function only initialize r->inroi for 3 roi types
mmc_raytrace.c:1183: * if doinit is set to 0, this function only updates r->{Lmove, roiidx, inroi}. r->roitype update is not necessary
mmc_raytrace.c:1184: * in the latter case, if reference element is found, it also updates r->refeid and r->roisize pointers
mmc_raytrace.c:1187:    int eid = r->eid - 1;
mmc_raytrace.c:1188:    int* ee = (int*)(tracer->mesh->elem + eid * tracer->mesh->elemlen);
mmc_raytrace.c:1190:    if (roitype == 1) { /** edge and node immc - edge also depends on node */
mmc_raytrace.c:1195:        if (tracer->mesh->edgeroi) { /** if edge roi is defined */
mmc_raytrace.c:1196:            // edge-based iMMC  - ray-cylinder intersection test
mmc_raytrace.c:1201:                if (r->roisize[i] > 0.f) {
mmc_raytrace.c:1214:                        r->inroi |= (hitstatus == htInOut || hitstatus == htNoHitIn);
mmc_raytrace.c:1223:                                r->roiidx = i;
mmc_raytrace.c:1233:                r->Lmove *= minratio;
mmc_raytrace.c:1237:                r->inroi = (firsthit != htNone ? (firsthit == htOutIn) : (firstinout != htNone ? (firstinout == htNoHitIn) : r->inroi ));
mmc_raytrace.c:1238:                r->inroi = (firsthit == htNone && firstinout == htNone) ? 0 : r->inroi;
mmc_raytrace.c:1241:            r->roitype = (firsthit == htInOut || firsthit == htOutIn) ? rtEdge : rtNone;
mmc_raytrace.c:1244:        if (firsthit == htNone && firstinout != htNoHitIn && tracer->mesh->noderoi) {
mmc_raytrace.c:1245:            // not hit any edgeroi in the current element, then go for node-based iMMC
mmc_raytrace.c:1249:            minratio = r->Lmove;
mmc_raytrace.c:1255:                nr = tracer->mesh->noderoi[ee[i] - 1];
mmc_raytrace.c:1261:                        r->inroi |= (hitstatus == htInOut || hitstatus == htNoHitIn);
mmc_raytrace.c:1269:                                r->roiidx = i;
mmc_raytrace.c:1278:            if (minratio < r->Lmove) {
mmc_raytrace.c:1279:                r->Lmove = minratio;
mmc_raytrace.c:1283:                r->inroi = (firsthit != htNone ? (firsthit == htOutIn) : (firstinout != htNone ? (firstinout == htNoHitIn) : r->inroi ));
mmc_raytrace.c:1284:                r->inroi = (firsthit == htNone && firstinout == htNone) ? 0 : r->inroi;
mmc_raytrace.c:1287:            r->roitype = (firsthit == htInOut || firsthit == htOutIn) ? rtNode : rtNone;
mmc_raytrace.c:1290:    } else if (tracer->mesh->faceroi) {
mmc_raytrace.c:1291:        int neweid = -1, newbaseid = 0;
mmc_raytrace.c:1297:        if (r->roisize[0] < -4.f) {
mmc_raytrace.c:1298:            neweid = (int)(-r->roisize[0]) - 4;
mmc_raytrace.c:1299:            r->refeid = neweid;
mmc_raytrace.c:1300:            newbaseid = (neweid - 1) << 2;
mmc_raytrace.c:1301:            newee = (int*)(tracer->mesh->elem + (neweid - 1) * tracer->mesh->elemlen);
mmc_raytrace.c:1302:            r->roisize = (float*)(tracer->mesh->faceroi + (neweid - 1) * 4);
mmc_raytrace.c:1307:            if (r->roisize[i] > 0.f) {
mmc_raytrace.c:1315:                    r->inroi |= (hitstatus == htInOut || hitstatus == htNoHitIn);
mmc_raytrace.c:1321:                            r->roiidx = i;
mmc_raytrace.c:1331:            r->Lmove *= minratio;
mmc_raytrace.c:1335:            r->inroi = (firsthit != htNone ? (firsthit == htOutIn) : (firstinout != htNone ? (firstinout == htNoHitIn) : r->inroi ));
mmc_raytrace.c:1336:            r->inroi = (firsthit == htNone && firstinout == htNone) ? 0 : r->inroi;
mmc_raytrace.c:1339:        r->roitype = (firsthit == htInOut || firsthit == htOutIn) ? rtFace : rtNone;
mmc_raytrace.c:1344: * \brief Branch-less Badouel-based SSE4 ray-tracer to advance photon by one step
mmc_raytrace.c:1346: * this function uses Branch-less Badouel-based SSE4 ray-triangle intersection
mmc_raytrace.c:1348: * Branch-less Badouel algorithms do not calculate the Barycentric coordinates
mmc_raytrace.c:1349: * and can only store energy loss using 0-th order basis function. This function
mmc_raytrace.c:1350: * is the fastest among the 4 ray-tracers.
mmc_raytrace.c:1353: * \param[in] tracer: the ray-tracer aux data structure
mmc_raytrace.c:1362:    int tshift, faceidx = -1, baseid, eid;
mmc_raytrace.c:1366:    if (tracer->mesh == NULL || tracer->n == NULL || r->eid <= 0 || r->eid > tracer->mesh->ne) {
mmc_raytrace.c:1367:        return -1;
mmc_raytrace.c:1370:    r->p0.w = 1.f;
mmc_raytrace.c:1371:    r->vec.w = 0.f;
mmc_raytrace.c:1372:    eid = r->eid - 1;
mmc_raytrace.c:1375:    r->pout.x = MMC_UNDEFINED;
mmc_raytrace.c:1376:    r->faceid = -1;
mmc_raytrace.c:1377:    r->isend = 0;
mmc_raytrace.c:1378:    r->roitype = rtNone;
mmc_raytrace.c:1379:    r->refeid = -1;
mmc_raytrace.c:1380:    r->roiidx = -1;
mmc_raytrace.c:1382:    const __m128 Nx = _mm_load_ps(&(tracer->n[baseid].x));
mmc_raytrace.c:1383:    const __m128 Ny = _mm_load_ps(&(tracer->n[baseid + 1].x));
mmc_raytrace.c:1384:    const __m128 Nz = _mm_load_ps(&(tracer->n[baseid + 2].x));
mmc_raytrace.c:1385:    const __m128 dd = _mm_load_ps(&(tracer->n[baseid + 3].x));
mmc_raytrace.c:1387:    O = _mm_set1_ps(r->p0.x);
mmc_raytrace.c:1389:    O = _mm_set1_ps(r->p0.y);
mmc_raytrace.c:1391:    O = _mm_set1_ps(r->p0.z);
mmc_raytrace.c:1395:    O = _mm_set1_ps(r->vec.x);
mmc_raytrace.c:1397:    O = _mm_set1_ps(r->vec.y);
mmc_raytrace.c:1399:    O = _mm_set1_ps(r->vec.z);
mmc_raytrace.c:1412:    r->faceid = faceorder[faceidx];
mmc_raytrace.c:1414:    if (r->faceid >= 0 && bary.x >= 0) {
mmc_raytrace.c:1416:        int* enb, *ee = (int*)(tracer->mesh->elem + eid * tracer->mesh->elemlen);
mmc_raytrace.c:1419:        if (cfg->implicit && r->inroi) {
mmc_raytrace.c:1420:            prop = tracer->mesh->med + tracer->mesh->prop;
mmc_raytrace.c:1422:            prop = tracer->mesh->med + (tracer->mesh->type[eid]);
mmc_raytrace.c:1425:        rc = prop->n * R_C0;
mmc_raytrace.c:1426:        currweight = r->weight;
mmc_raytrace.c:1427:        mus = (cfg->mcmethod == mmMCX) ? prop->mus : (prop->mua + prop->mus);
mmc_raytrace.c:1429:        enb = (int*)(tracer->mesh->facenb + eid * tracer->mesh->elemlen);
mmc_raytrace.c:1430:        r->nexteid = enb[r->faceid]; // if I use nexteid-1, the speed got slower, strange!
mmc_raytrace.c:1432:        if (r->nexteid > 0) {
mmc_raytrace.c:1433:            _mm_prefetch((char*) & (tracer->n[(r->nexteid - 1) << 2].x), _MM_HINT_T0);
mmc_raytrace.c:1436:        dlen = (mus <= EPS) ? R_MIN_MUS : r->slen / mus;
mmc_raytrace.c:1438:        r->isend = (Lp0 > dlen);
mmc_raytrace.c:1439:        r->Lmove = ((r->isend) ? dlen : Lp0);
mmc_raytrace.c:1441:        // implicit MMC - test if ray intersects with edge/face/node ROI boundaries
mmc_raytrace.c:1442:        if (cfg->implicit) {
mmc_raytrace.c:1443:            traceroi(r, tracer, cfg->implicit, 0);
mmc_raytrace.c:1446:        O = _mm_load_ps(&(r->vec.x));
mmc_raytrace.c:1447:        S = _mm_load_ps(&(r->p0.x));
mmc_raytrace.c:1451:        _mm_store_ps(&(r->pout.x), T);
mmc_raytrace.c:1453:        if ((int)((r->photontimer + r->Lmove * rc - cfg->tstart)*visit->rtstep) > cfg->maxgate - 1) { /*exit time window*/
mmc_raytrace.c:1454:            r->faceid = -2;
mmc_raytrace.c:1455:            r->pout.x = MMC_UNDEFINED;
mmc_raytrace.c:1456:            r->Lmove = (cfg->tend - r->photontimer) / (prop->n * R_C0) - 1e-4f;
mmc_raytrace.c:1459:        if (cfg->mcmethod == mmMCX) {
mmc_raytrace.c:1460:            totalloss = expf(-prop->mua * r->Lmove);
mmc_raytrace.c:1461:            r->weight *= totalloss;
mmc_raytrace.c:1464:        totalloss = 1.f - totalloss;
mmc_raytrace.c:1466:        if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otJacobian) {
mmc_raytrace.c:1467:            currweight = expf(-DELTA_MUA * r->Lmove);
mmc_raytrace.c:1468:            currweight *= cfg->replayweight[r->photonid];
mmc_raytrace.c:1469:            currweight += r->weight;
mmc_raytrace.c:1470:        } else if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otWL) {
mmc_raytrace.c:1471:            currweight = r->Lmove;
mmc_raytrace.c:1472:            currweight *= cfg->replayweight[r->photonid];
mmc_raytrace.c:1473:            currweight += r->weight;
mmc_raytrace.c:1476:        r->slen -= r->Lmove * mus;
mmc_raytrace.c:1478:        if (cfg->seed == SEED_FROM_FILE && cfg->outputtype == otWP) {
mmc_raytrace.c:1479:            if (r->slen0 < EPS) {
mmc_raytrace.c:1482:                currweight = r->Lmove * mus / r->slen0;
mmc_raytrace.c:1485:            currweight *= cfg->replayweight[r->photonid];
mmc_raytrace.c:1486:            currweight += r->weight;
mmc_raytrace.c:1490:            int framelen = (cfg->basisorder ? tracer->mesh->nn : tracer->mesh->ne);
mmc_raytrace.c:1492:            if (cfg->method == rtBLBadouelGrid) {
mmc_raytrace.c:1493:                framelen = cfg->crop0.z;
mmc_raytrace.c:1496:            ww = currweight - r->weight;
mmc_raytrace.c:1497:            r->photontimer += r->Lmove * rc;
mmc_raytrace.c:1499:            if (cfg->outputtype == otWL || cfg->outputtype == otWP) {
mmc_raytrace.c:1500:                tshift = MIN( ((int)(cfg->replaytime[r->photonid] * visit->rtstep)), cfg->maxgate - 1 ) * framelen;
mmc_raytrace.c:1502:                tshift = MIN( ((int)((r->photontimer - cfg->tstart) * visit->rtstep)), cfg->maxgate - 1 ) * framelen;
mmc_raytrace.c:1505:            if (cfg->debuglevel & dlAccum) MMC_FPRINTF(cfg->flog, "A %f %f %f %e %d %e\n",
mmc_raytrace.c:1506:                        r->p0.x, r->p0.y, r->p0.z, bary.x, eid + 1, dlen);
mmc_raytrace.c:1508:            if (prop->mua > 0.f) {
mmc_raytrace.c:1509:                r->Eabsorb += ww;
mmc_raytrace.c:1511:                if (cfg->outputtype != otEnergy && cfg->outputtype != otWP) {
mmc_raytrace.c:1512:                    ww /= prop->mua;
mmc_raytrace.c:1516:            T = _mm_set1_ps(r->Lmove);
mmc_raytrace.c:1518:            _mm_store_ps(&(r->p0.x), T);
mmc_raytrace.c:1520:            if (cfg->mcmethod == mmMCX) {
mmc_raytrace.c:1521:                if (!cfg->basisorder) {
mmc_raytrace.c:1522:                    if (cfg->method == rtBLBadouel) {
mmc_raytrace.c:1524:                        r->oldidx = (r->oldidx == 0xFFFFFFFF) ? newidx : r->oldidx;
mmc_raytrace.c:1526:                        if (newidx != r->oldidx) {
mmc_raytrace.c:1527:                            if (cfg->srctype != stPattern) {
mmc_raytrace.c:1528:                                if (cfg->isatomic)
mmc_raytrace.c:1530:                                    tracer->mesh->weight[r->oldidx] += r->oldweight;
mmc_raytrace.c:1532:                                    tracer->mesh->weight[r->oldidx] += r->oldweight;
mmc_raytrace.c:1535:                                int psize = (int)cfg->srcparam1.w * (int)cfg->srcparam2.w; // total number of pixels in each pattern
mmc_raytrace.c:1538:                                for (pidx = 0; pidx < cfg->srcnum; pidx++) {
mmc_raytrace.c:1539:                                    if (cfg->isatomic)
mmc_raytrace.c:1541:                                        tracer->mesh->weight[r->oldidx * cfg->srcnum + pidx] += r->oldweight * cfg->srcpattern[pidx * psize + r->posidx];
mmc_raytrace.c:1543:                                        tracer->mesh->weight[r->oldidx * cfg->srcnum + pidx] += r->oldweight * cfg->srcpattern[pidx * psize + r->posidx];
mmc_raytrace.c:1548:                            r->oldidx = newidx;
mmc_raytrace.c:1549:                            r->oldweight = ww;
mmc_raytrace.c:1551:                            r->oldweight += ww;
mmc_raytrace.c:1554:                        if (r->faceid == -2 || !r->isend) {
mmc_raytrace.c:1555:                            if (cfg->srctype != stPattern) {
mmc_raytrace.c:1556:                                if (cfg->isatomic)
mmc_raytrace.c:1558:                                    tracer->mesh->weight[newidx] += r->oldweight;
mmc_raytrace.c:1560:                                    tracer->mesh->weight[newidx] += r->oldweight;
mmc_raytrace.c:1563:                                int psize = (int)cfg->srcparam1.w * (int)cfg->srcparam2.w; // total number of pixels in each pattern
mmc_raytrace.c:1566:                                for (pidx = 0; pidx < cfg->srcnum; pidx++) {
mmc_raytrace.c:1567:                                    if (cfg->isatomic)
mmc_raytrace.c:1569:                                        tracer->mesh->weight[newidx * cfg->srcnum + pidx] += r->oldweight * cfg->srcpattern[pidx * psize + r->posidx];
mmc_raytrace.c:1571:                                        tracer->mesh->weight[newidx * cfg->srcnum + pidx] += r->oldweight * cfg->srcpattern[pidx * psize + r->posidx];
mmc_raytrace.c:1576:                            r->oldweight = 0.f;
mmc_raytrace.c:1581:                        int i, seg = (int)(r->Lmove / cfg->steps.x) + 1;
mmc_raytrace.c:1583:                        dstep = r->Lmove / seg;
mmc_raytrace.c:1584:                        segloss = expf(-prop->mua * dstep);
mmc_raytrace.c:1586:                        O =  _mm_sub_ps(S, _mm_load_ps(&(tracer->mesh->nmin.x)));
mmc_raytrace.c:1588:                        dstep = 1.f / cfg->steps.x;
mmc_raytrace.c:1589:                        totalloss = (totalloss == 0.f) ? 0.f : (1.f - segloss) / totalloss;
mmc_raytrace.c:1595:                            unsigned int newidx = idx.z * cfg->crop0.y + idx.y * cfg->crop0.x + idx.x + tshift;
mmc_raytrace.c:1596:                            r->oldidx = (r->oldidx == 0xFFFFFFFF) ? newidx : r->oldidx;
mmc_raytrace.c:1598:                            if (newidx != r->oldidx) {
mmc_raytrace.c:1599:                                if (cfg->isatomic)
mmc_raytrace.c:1601:                                    tracer->mesh->weight[r->oldidx] += r->oldweight;
mmc_raytrace.c:1603:                                    tracer->mesh->weight[r->oldidx] += r->oldweight;
mmc_raytrace.c:1606:                                r->oldidx = newidx;
mmc_raytrace.c:1607:                                r->oldweight = w0 * totalloss;
mmc_raytrace.c:1609:                                r->oldweight += w0 * totalloss;
mmc_raytrace.c:1612:                            if (r->faceid == -2 || !r->isend) {
mmc_raytrace.c:1613:                                if (cfg->isatomic)
mmc_raytrace.c:1615:                                    tracer->mesh->weight[newidx] += r->oldweight;
mmc_raytrace.c:1617:                                    tracer->mesh->weight[newidx] += r->oldweight;
mmc_raytrace.c:1620:                                r->oldweight = 0.f;
mmc_raytrace.c:1631:                    if (cfg->srctype != stPattern) {
mmc_raytrace.c:1632:                        if (cfg->isatomic)
mmc_raytrace.c:1635:                                tracer->mesh->weight[ee[out[faceidx][i]] - 1 + tshift] += ww;
mmc_raytrace.c:1638:                                tracer->mesh->weight[ee[out[faceidx][i]] - 1 + tshift] += ww;
mmc_raytrace.c:1641:                        int psize = (int)cfg->srcparam1.w * (int)cfg->srcparam2.w; // total number of pixels in each pattern
mmc_raytrace.c:1644:                        for (pidx = 0; pidx < cfg->srcnum; pidx++) {
mmc_raytrace.c:1645:                            if (cfg->isatomic)
mmc_raytrace.c:1648:                                    tracer->mesh->weight[(ee[out[faceidx][i]] - 1 + tshift)*cfg->srcnum + pidx] += ww * cfg->srcpattern[pidx * psize + r->posidx];
mmc_raytrace.c:1651:                                    tracer->mesh->weight[(ee[out[faceidx][i]] - 1 + tshift)*cfg->srcnum + pidx] += ww * cfg->srcpattern[pidx * psize + r->posidx];
mmc_raytrace.c:1660:    visit->raytet++;
mmc_raytrace.c:1662:    if (tracer->mesh->type[eid] == 0) {
mmc_raytrace.c:1663:        visit->raytet0++;
mmc_raytrace.c:1666:    r->p0.w = 0.f;
mmc_raytrace.c:1668:    if (r->faceid == -2) {
mmc_raytrace.c:1672:    return r->slen;
mmc_raytrace.c:1677: * Havel, Badouel and Branch-less Badouel-based SSE4 ray-tracer require to compile
mmc_raytrace.c:1683:    MMC_ERROR(-6, "wrong option, please recompile with SSE4 enabled");
mmc_raytrace.c:1687:    MMC_ERROR(-6, "wrong option, please recompile with SSE4 enabled");
mmc_raytrace.c:1691:    MMC_ERROR(-6, "wrong option, please recompile with SSE4 enabled");
mmc_raytrace.c:1699: * This is the core Monte Carlo simulation function. It simulates the life-time
mmc_raytrace.c:1703: * \param[in] tracer: the ray-tracer aux data structure
mmc_raytrace.c:1718:    ray r = {cfg->srcpos, {cfg->srcdir.x, cfg->srcdir.y, cfg->srcdir.z}, {MMC_UNDEFINED, 0.f, 0.f}, cfg->bary0, cfg->e0, cfg->dim.y - 1, 0, 0, 1.f, 0.f, 0.f, 0.f, 0.f, 0., 0, NULL, NULL, cfg->srcdir.w, 0, 0xFFFFFFFF, 0.0, NULL, 0, 0, 0, 0};
mmc_raytrace.c:1724:    r.partialpath = (float*)calloc(visit->reclen - 1, sizeof(float));
mmc_raytrace.c:1727:    if (cfg->issavedet && cfg->issaveseed) {
mmc_raytrace.c:1734:    if (cfg->method >= rtPlucker && cfg->method <= rtBLBadouelGrid) {
mmc_raytrace.c:1735:        tracercore = engines[(int)(cfg->method)];
mmc_raytrace.c:1737:        MMC_ERROR(-6, "specified ray-tracing algorithm is not defined");
mmc_raytrace.c:1742:    r.partialpath[visit->reclen - 2] = r.weight; /*last record in partialpath is the initial photon weight*/
mmc_raytrace.c:1745:    /*http://stackoverflow.com/questions/2148149/how-to-sum-a-large-number-of-float-number*/
mmc_raytrace.c:1748:    if (cfg->srctype != stPattern) {
mmc_raytrace.c:1749:        if (cfg->seed == SEED_FROM_FILE && (cfg->outputtype == otWL || cfg->outputtype == otWP)) {
mmc_raytrace.c:1750:            kahany = cfg->replayweight[r.photonid] - visit->kahanc0[0];    /* when replay mode, accumulate detected photon weight */
mmc_raytrace.c:1752:            kahany = r.weight - visit->kahanc0[0];
mmc_raytrace.c:1755:        kahant = visit->launchweight[0] + kahany;
mmc_raytrace.c:1756:        visit->kahanc0[0] = (kahant - visit->launchweight[0]) - kahany;
mmc_raytrace.c:1757:        visit->launchweight[0] = kahant;
mmc_raytrace.c:1759:        int psize = (int)cfg->srcparam1.w * (int)cfg->srcparam2.w;
mmc_raytrace.c:1762:            for (pidx = 0; pidx < cfg->srcnum; pidx++) {
mmc_raytrace.c:1763:                if (cfg->seed == SEED_FROM_FILE && (cfg->outputtype == otWL || cfg->outputtype == otWP)) {
mmc_raytrace.c:1764:                    kahany = cfg->replayweight[r.photonid] - visit->kahanc0[pidx];    /* when replay mode, accumulate detected photon weight */
mmc_raytrace.c:1766:                    kahany = r.weight * cfg->srcpattern[pidx * psize + r.posidx] - visit->kahanc0[pidx];
mmc_raytrace.c:1769:                kahant = visit->launchweight[pidx] + kahany;
mmc_raytrace.c:1770:                visit->kahanc0[pidx] = (kahant - visit->launchweight[pidx]) - kahany;
mmc_raytrace.c:1771:                visit->launchweight[pidx] = kahant;
mmc_raytrace.c:1777:    const float int_coef_arr[4] = { -1.f, -1.f, -1.f, 1.f };
mmc_raytrace.c:1780:    if (cfg->implicit) {
mmc_raytrace.c:1781:        updateroi(cfg->implicit, &r, tracer->mesh);
mmc_raytrace.c:1782:        traceroi(&r, tracer, cfg->implicit, 1);
mmc_raytrace.c:1788:        if (cfg->implicit) {
mmc_raytrace.c:1789:            updateroi(cfg->implicit, &r, tracer->mesh);
mmc_raytrace.c:1795:            if (r.faceid == -2) {
mmc_raytrace.c:1800:                fixphoton(&r.p0, mesh->node, (int*)(mesh->elem + (r.eid - 1)*mesh->elemlen));
mmc_raytrace.c:1805:            r.faceid = -1;
mmc_raytrace.c:1808:        if (cfg->issavedet && r.Lmove > 0.f && mesh->type[r.eid - 1] > 0 && r.faceid >= 0) {
mmc_raytrace.c:1809:            r.partialpath[mesh->prop - 1 + mesh->type[r.eid - 1]] += r.Lmove;    /*second medianum block is the partial path*/
mmc_raytrace.c:1812:        if (cfg->implicit && cfg->isreflect && r.roitype && r.roiidx >= 0 && (mesh->med[cfg->his.maxmedia].n != mesh->med[mesh->type[r.eid - 1]].n)) {
mmc_raytrace.c:1816:        } else if (cfg->implicit && r.roitype) {
mmc_raytrace.c:1824:            enb = (int*)(mesh->facenb + (r.eid - 1) * mesh->elemlen);
mmc_raytrace.c:1828:            if (cfg->implicit) {
mmc_raytrace.c:1829:                if (cfg->isreflect && (r.eid <= 0 || mesh->med[mesh->type[r.eid - 1]].n != mesh->med[mesh->type[oldeid - 1]].n )) {
mmc_raytrace.c:1830:                    if (! (!r.inroi && r.eid <= 0 && ((mesh->med[mesh->type[oldeid - 1]].n == cfg->nout && cfg->isreflect != (int)bcMirror) || cfg->isreflect == (int)bcAbsorbExterior) ) ) {
mmc_raytrace.c:1835:                if (cfg->isreflect && (r.eid <= 0 || mesh->med[mesh->type[r.eid - 1]].n != mesh->med[mesh->type[oldeid - 1]].n )) {
mmc_raytrace.c:1836:                    if (! (r.eid <= 0 && ((mesh->med[mesh->type[oldeid - 1]].n == cfg->nout && cfg->isreflect != (int)bcMirror) || cfg->isreflect == (int)bcAbsorbExterior) ) ) {
mmc_raytrace.c:1847:            if (mesh->type[oldeid - 1] == 0 && mesh->type[r.eid - 1]) {
mmc_raytrace.c:1848:                if (cfg->debuglevel & dlExit)
mmc_raytrace.c:1849:                    MMC_FPRINTF(cfg->flog, "e %f %f %f %f %f %f %f %d\n", r.p0.x, r.p0.y, r.p0.z,
mmc_raytrace.c:1852:                if (!cfg->voidtime) {
mmc_raytrace.c:1858:            if (mesh->type[oldeid - 1] && mesh->type[r.eid - 1] == 0) {
mmc_raytrace.c:1859:                if (cfg->debuglevel & dlExit)
mmc_raytrace.c:1860:                    MMC_FPRINTF(cfg->flog, "x %f %f %f %f %f %f %f %d\n", r.p0.x, r.p0.y, r.p0.z,
mmc_raytrace.c:1863:                if (!cfg->isextdet) {
mmc_raytrace.c:1869:            //          if(r.eid!=ID_UNDEFINED && mesh->med[mesh->type[oldeid-1]].n == cfg->nout ) break;
mmc_raytrace.c:1870:            if (r.pout.x != MMC_UNDEFINED && (cfg->debuglevel & dlMove)) {
mmc_raytrace.c:1871:                MMC_FPRINTF(cfg->flog, "P %f %f %f %d %zu %e\n", r.pout.x, r.pout.y, r.pout.z, r.eid, id, r.slen);
mmc_raytrace.c:1874:            if (cfg->implicit) {
mmc_raytrace.c:1875:                updateroi(cfg->implicit, &r, tracer->mesh);
mmc_raytrace.c:1880:            if (cfg->issavedet && r.Lmove > 0.f && mesh->type[r.eid - 1] > 0) {
mmc_raytrace.c:1881:                r.partialpath[mesh->prop - 1 + mesh->type[r.eid - 1]] += r.Lmove;
mmc_raytrace.c:1884:            if (r.faceid == -2) {
mmc_raytrace.c:1891:                fixphoton(&r.p0, mesh->node, (int*)(mesh->elem + (r.eid - 1)*mesh->elemlen));
mmc_raytrace.c:1894:                if (cfg->issavedet && r.Lmove > 0.f && mesh->type[r.eid - 1] > 0) {
mmc_raytrace.c:1895:                    r.partialpath[mesh->prop - 1 + mesh->type[r.eid - 1]] += r.Lmove;
mmc_raytrace.c:1907:            if (r.eid != ID_UNDEFINED && (cfg->debuglevel & dlMove)) {
mmc_raytrace.c:1908:                MMC_FPRINTF(cfg->flog, "B %f %f %f %d %zu %e\n", r.p0.x, r.p0.y, r.p0.z, r.eid, id, r.slen);
mmc_raytrace.c:1912:                if (cfg->debuglevel & dlExit)
mmc_raytrace.c:1913:                    MMC_FPRINTF(cfg->flog, "E %f %f %f %f %f %f %f %d\n", r.p0.x, r.p0.y, r.p0.z,
mmc_raytrace.c:1916:                if (cfg->issavedet && cfg->issaveexit) {                                   /*when issaveexit is set to 1*/
mmc_raytrace.c:1917:                    memcpy(r.partialpath + (visit->reclen - 2 - 6), &(r.p0.x), sizeof(float) * 3); /*columns 7-5 from the right store the exit positions*/
mmc_raytrace.c:1918:                    memcpy(r.partialpath + (visit->reclen - 2 - 3), &(r.vec.x), sizeof(float) * 3); /*columns 4-2 from the right store the exit dirs*/
mmc_raytrace.c:1921:                if (cfg->issaveref && r.eid < 0 && mesh->dref) {
mmc_raytrace.c:1922:                    int tshift = MIN( ((int)((r.photontimer - cfg->tstart) * visit->rtstep)), cfg->maxgate - 1 ) * mesh->nf;
mmc_raytrace.c:1923:                    mesh->dref[((-r.eid) - 1) + tshift] += r.weight;
mmc_raytrace.c:1925:            } else if (r.faceid == -2 && (cfg->debuglevel & dlMove)) {
mmc_raytrace.c:1926:                MMC_FPRINTF(cfg->flog, "T %f %f %f %d %zu %e\n", r.p0.x, r.p0.y, r.p0.z, r.eid, id, r.slen);
mmc_raytrace.c:1927:            } else if (r.eid && r.faceid != -2  && cfg->debuglevel & dlEdge) {
mmc_raytrace.c:1928:                MMC_FPRINTF(cfg->flog, "X %f %f %f %d %zu %e\n", r.p0.x, r.p0.y, r.p0.z, r.eid, id, r.slen);
mmc_raytrace.c:1931:            if (cfg->issavedet && r.eid <= 0) {
mmc_raytrace.c:1934:                if (cfg->detnum == 0 && cfg->isextdet && mesh->type[oldeid - 1] == mesh->prop + 1) {
mmc_raytrace.c:1937:                    for (i = 0; i < cfg->detnum; i++) {
mmc_raytrace.c:1938:                        if ((cfg->detpos[i].x - r.p0.x) * (cfg->detpos[i].x - r.p0.x) +
mmc_raytrace.c:1939:                                (cfg->detpos[i].y - r.p0.y) * (cfg->detpos[i].y - r.p0.y) +
mmc_raytrace.c:1940:                                (cfg->detpos[i].z - r.p0.z) * (cfg->detpos[i].z - r.p0.z) < cfg->detpos[i].w * cfg->detpos[i].w) {
mmc_raytrace.c:1950:        if (cfg->debuglevel & dlMove) {
mmc_raytrace.c:1951:            MMC_FPRINTF(cfg->flog, "M %f %f %f %d %zu %e\n", r.p0.x, r.p0.y, r.p0.z, r.eid, id, r.slen);
mmc_raytrace.c:1954:        if (cfg->minenergy > 0.f && r.weight < cfg->minenergy && (cfg->tend - cfg->tstart)*visit->rtstep <= 1.f) { /*Russian Roulette*/
mmc_raytrace.c:1955:            if (rand_do_roulette(ran)*cfg->roulettesize <= 1.f) {
mmc_raytrace.c:1956:                r.weight *= cfg->roulettesize;
mmc_raytrace.c:1958:                if (cfg->debuglevel & dlWeight) {
mmc_raytrace.c:1959:                    MMC_FPRINTF(cfg->flog, "Russian Roulette bumps r.weight to %f\n", r.weight);
mmc_raytrace.c:1966:        if (cfg->implicit && cfg->isreflect && r.roitype && r.roiidx >= 0 && (mesh->med[cfg->his.maxmedia].n != mesh->med[mesh->type[r.eid - 1]].n)) {
mmc_raytrace.c:1970:        } else if (cfg->implicit && r.roitype) {
mmc_raytrace.c:1975:        r.slen0 = mc_next_scatter(mesh->med[mesh->type[r.eid - 1]].g, &r.vec, ran, ran0, cfg, &mom);
mmc_raytrace.c:1978:        if (cfg->mcmethod != mmMCX) {
mmc_raytrace.c:1982:        if (cfg->ismomentum && mesh->type[r.eid - 1] > 0) {              /*when ismomentum is set to 1*/
mmc_raytrace.c:1983:            r.partialpath[(mesh->prop << 1) - 1 + mesh->type[r.eid - 1]] += mom;    /*the third medianum block stores the momentum transfer*/
mmc_raytrace.c:1986:        r.partialpath[mesh->type[r.eid - 1] - 1]++;                      /*the first medianum block stores the scattering event counts*/
mmc_raytrace.c:1989:    if (cfg->issavedet && exitdet > 0) {
mmc_raytrace.c:1990:        int offset = visit->bufpos * visit->reclen;
mmc_raytrace.c:1992:        if (visit->bufpos >= visit->detcount) {
mmc_raytrace.c:1993:            visit->detcount += DET_PHOTON_BUF;
mmc_raytrace.c:1994:            visit->partialpath = (float*)realloc(visit->partialpath,
mmc_raytrace.c:1995:                                                 visit->detcount * visit->reclen * sizeof(float));
mmc_raytrace.c:1997:            if (cfg->issaveseed) {
mmc_raytrace.c:1998:                visit->photonseed = realloc(visit->photonseed, visit->detcount * (sizeof(RandType) * RAND_BUF_LEN));
mmc_raytrace.c:2002:        visit->partialpath[offset] = exitdet;
mmc_raytrace.c:2003:        memcpy(visit->partialpath + offset + 1, r.partialpath, (visit->reclen - 1)*sizeof(float));
mmc_raytrace.c:2005:        if (cfg->issaveseed) {
mmc_raytrace.c:2006:            memcpy(visit->photonseed + visit->bufpos * (sizeof(RandType)*RAND_BUF_LEN), r.photonseed, (sizeof(RandType)*RAND_BUF_LEN));
mmc_raytrace.c:2009:        visit->bufpos++;
mmc_raytrace.c:2018:    if (cfg->srctype != stPattern) {
mmc_raytrace.c:2019:        kahany = r.Eabsorb - visit->kahanc1[0];
mmc_raytrace.c:2020:        kahant = visit->absorbweight[0] + kahany;
mmc_raytrace.c:2021:        visit->kahanc1[0] = (kahant - visit->absorbweight[0]) - kahany;
mmc_raytrace.c:2022:        visit->absorbweight[0] = kahant;
mmc_raytrace.c:2024:        int psize = (int)cfg->srcparam1.w * (int)cfg->srcparam2.w;
mmc_raytrace.c:2027:            for (pidx = 0; pidx < cfg->srcnum; pidx++) {
mmc_raytrace.c:2028:                kahany = r.Eabsorb * cfg->srcpattern[pidx * psize + r.posidx] - visit->kahanc1[pidx];
mmc_raytrace.c:2029:                kahant = visit->absorbweight[pidx] + kahany;
mmc_raytrace.c:2030:                visit->kahanc1[pidx] = (kahant - visit->absorbweight[pidx]) - kahany;
mmc_raytrace.c:2031:                visit->absorbweight[pidx] = kahant;
mmc_raytrace.c:2047: * \param[in] tracer: the ray-tracer aux data structure
mmc_raytrace.c:2060:        E0 = tracer->mesh->node[tracer->mesh->elem[((*eid - 1) << 2) + e2n[roiidx][0]] - 1];
mmc_raytrace.c:2061:        vec_diff(&E0, tracer->mesh->node + (tracer->mesh->elem[((*eid - 1) << 2) + e2n[roiidx][1]] - 1), &u);
mmc_raytrace.c:2069:        vec_diff(tracer->mesh->node + (tracer->mesh->elem[((*eid - 1) << 2) + roiidx] - 1), ph, pn);
mmc_raytrace.c:2076:            baseid = (*eid - 1) << 2;
mmc_raytrace.c:2078:            baseid = (refeid - 1) << 2;
mmc_raytrace.c:2081:        pn->x = (&(tracer->n[baseid].x))[roiidx];
mmc_raytrace.c:2082:        pn->y = (&(tracer->n[baseid].x))[roiidx + 4];
mmc_raytrace.c:2083:        pn->z = (&(tracer->n[baseid].x))[roiidx + 8];
mmc_raytrace.c:2091:    if (*inroi) { // out->in
mmc_raytrace.c:2092:        n1 = tracer->mesh->med[tracer->mesh->type[*eid - 1]].n;
mmc_raytrace.c:2093:        n2 = tracer->mesh->med[cfg->his.maxmedia].n;
mmc_raytrace.c:2096:            vec_mult(pn, -1.f, pn);
mmc_raytrace.c:2098:    } else {     // in->out
mmc_raytrace.c:2099:        n1 = tracer->mesh->med[cfg->his.maxmedia].n;
mmc_raytrace.c:2100:        n2 = tracer->mesh->med[tracer->mesh->type[*eid - 1]].n;
mmc_raytrace.c:2103:            vec_mult(pn, -1.f, pn);
mmc_raytrace.c:2109:    tmp2 = 1.f - tmp0 / tmp1 * (1.f - Icos * Icos); /*1-[n1/n2*sin(si)]^2 = cos(ti)^2*/
mmc_raytrace.c:2115:        Rtotal = (Re - Im) / (Re + Im); /*Rp*/
mmc_raytrace.c:2117:        Rtotal = (Rtotal + (Re - Im) / (Re + Im)) * 0.5f; /*(Rp+Rs)/2*/
mmc_raytrace.c:2121:            vec_mult_add(pn, c0, -2.f * Icos, 1.f, c0);
mmc_raytrace.c:2123:            //if(cfg->debuglevel&dlReflect) MMC_FPRINTF(cfg->flog,"R %f %f %f %d %d %f\n",c0->x,c0->y,c0->z,*eid,*oldeid,Rtotal);
mmc_raytrace.c:2124:        } else if (cfg->isspecular == 2 && *eid == 0) {
mmc_raytrace.c:2127:            vec_mult_add(pn, c0, -Icos, 1.f, c0);
mmc_raytrace.c:2131:        vec_mult_add(pn, c0, -2.f * Icos, 1.f, c0);
mmc_raytrace.c:2148: * \param[in] tracer: the ray-tracer aux data structure
mmc_raytrace.c:2159:    int offs = (*oldeid - 1) << 2;
mmc_raytrace.c:2164:    if (cfg->method == rtPlucker) { //Plucker ray-tracing
mmc_raytrace.c:2165:        pn = tracer->n + (offs) + faceid;
mmc_raytrace.c:2166:    } else if (cfg->method < rtBLBadouel) {
mmc_raytrace.c:2167:        pn = tracer->m + (offs + faceid) * 3;
mmc_raytrace.c:2168:    } else if (cfg->method == rtBLBadouel || cfg->method == rtBLBadouelGrid) {
mmc_raytrace.c:2169:        pnorm.x = (&(tracer->n[offs].x))[faceid];
mmc_raytrace.c:2170:        pnorm.y = (&(tracer->n[offs].x))[faceid + 4];
mmc_raytrace.c:2171:        pnorm.z = (&(tracer->n[offs].x))[faceid + 8];
mmc_raytrace.c:2179:    if (cfg->implicit && inroi != 0) {
mmc_raytrace.c:2180:        n1 = tracer->mesh->med[cfg->his.maxmedia].n;
mmc_raytrace.c:2183:        n1 = (*oldeid != *eid) ? tracer->mesh->med[tracer->mesh->type[*oldeid - 1]].n : cfg->nout;
mmc_raytrace.c:2184:        n2 = (*eid > 0) ? tracer->mesh->med[tracer->mesh->type[*eid - 1]].n : cfg->nout;
mmc_raytrace.c:2189:    tmp2 = 1.f - tmp0 / tmp1 * (1.f - Icos * Icos); /*1-[n1/n2*sin(si)]^2 = cos(ti)^2*/
mmc_raytrace.c:2191:    if (tmp2 > 0.f && !(*eid <= 0 && cfg->isreflect == bcMirror)) { /*if no total internal reflection*/
mmc_raytrace.c:2195:        Rtotal = (Re - Im) / (Re + Im); /*Rp*/
mmc_raytrace.c:2197:        Rtotal = (Rtotal + (Re - Im) / (Re + Im)) * 0.5f; /*(Rp+Rs)/2*/
mmc_raytrace.c:2204:            vec_mult_add(pn, c0, -2.f * Icos, 1.f, c0);
mmc_raytrace.c:2205:            //if(cfg->debuglevel&dlReflect) MMC_FPRINTF(cfg->flog,"R %f %f %f %d %d %f\n",c0->x,c0->y,c0->z,*eid,*oldeid,Rtotal);
mmc_raytrace.c:2207:        } else if (cfg->isspecular == 2 && *eid == 0) {
mmc_raytrace.c:2210:            vec_mult_add(pn, c0, -Icos, 1.f, c0);
mmc_raytrace.c:2212:            //if(cfg->debuglevel&dlReflect) MMC_FPRINTF(cfg->flog,"Z %f %f %f %d %d %f\n",c0->x,c0->y,c0->z,*eid,*oldeid,1.f-Rtotal);
mmc_raytrace.c:2215:        vec_mult_add(pn, c0, -2.f * Icos, 1.f, c0);
mmc_raytrace.c:2217:        //if(cfg->debuglevel&dlReflect) MMC_FPRINTF(cfg->flog,"V %f %f %f %d %d %f\n",c0->x,c0->y,c0->z,*eid,*oldeid,1.f);
mmc_raytrace.c:2239:    MMCfloat3 origin = {r->p0.x, r->p0.y, r->p0.z};
mmc_raytrace.c:2241:    r->slen = rand_next_scatlen(ran);
mmc_raytrace.c:2242:    r->inroi = 0;
mmc_raytrace.c:2244:    if (cfg->srctype == stPencil) { // pencil beam, use the old workflow, except when eid is not given
mmc_raytrace.c:2245:        if (r->eid > 0) {
mmc_raytrace.c:2248:    } else if (cfg->srctype == stPlanar || cfg->srctype == stPattern || cfg->srctype == stFourier) {
mmc_raytrace.c:2251:        r->p0.x = cfg->srcpos.x + rx * cfg->srcparam1.x + ry * cfg->srcparam2.x;
mmc_raytrace.c:2252:        r->p0.y = cfg->srcpos.y + rx * cfg->srcparam1.y + ry * cfg->srcparam2.y;
mmc_raytrace.c:2253:        r->p0.z = cfg->srcpos.z + rx * cfg->srcparam1.z + ry * cfg->srcparam2.z;
mmc_raytrace.c:2254:        r->weight = 1.f;
mmc_raytrace.c:2256:        if (cfg->srctype == stPattern) {
mmc_raytrace.c:2257:            int xsize = (int)cfg->srcparam1.w;
mmc_raytrace.c:2258:            int ysize = (int)cfg->srcparam2.w;
mmc_raytrace.c:2259:            r->posidx = MIN((int)(ry * ysize), ysize - 1) * xsize + MIN((int)(rx * xsize), xsize - 1);
mmc_raytrace.c:2261:            if (cfg->seed == SEED_FROM_FILE && (cfg->outputtype == otWL || cfg->outputtype == otWP)) { // replay mode currently doesn't support multiple source patterns
mmc_raytrace.c:2262:                r->weight = cfg->srcpattern[MIN( (int)(ry * cfg->srcparam2.w), (int)cfg->srcparam2.w - 1 ) * (int)(cfg->srcparam1.w) + MIN( (int)(rx * cfg->srcparam1.w), (int)cfg->srcparam1.w - 1 )];
mmc_raytrace.c:2263:                cfg->replayweight[r->photonid] *= r->weight;
mmc_raytrace.c:2265:        } else if (cfg->srctype == stFourier) {
mmc_raytrace.c:2266:            r->weight = (cosf((floorf(cfg->srcparam1.w) * rx + floorf(cfg->srcparam2.w) * ry + cfg->srcparam1.w - floorf(cfg->srcparam1.w)) * TWO_PI) * (1.f - cfg->srcparam2.w + floorf(cfg->srcparam2.w)) + 1.f) * 0.5f;
mmc_raytrace.c:2269:        origin.x += (cfg->srcparam1.x + cfg->srcparam2.x) * 0.5f;
mmc_raytrace.c:2270:        origin.y += (cfg->srcparam1.y + cfg->srcparam2.y) * 0.5f;
mmc_raytrace.c:2271:        origin.z += (cfg->srcparam1.z + cfg->srcparam2.z) * 0.5f;
mmc_raytrace.c:2272:    } else if (cfg->srctype == stFourierX || cfg->srctype == stFourier2D) {
mmc_raytrace.c:2275:        float4 v2 = cfg->srcparam1;
mmc_raytrace.c:2276:        v2.w *= 1.f / (sqrtf(cfg->srcparam1.x * cfg->srcparam1.x + cfg->srcparam1.y * cfg->srcparam1.y + cfg->srcparam1.z * cfg->srcparam1.z));
mmc_raytrace.c:2277:        v2.x = v2.w * (cfg->srcdir.y * cfg->srcparam1.z - cfg->srcdir.z * cfg->srcparam1.y);
mmc_raytrace.c:2278:        v2.y = v2.w * (cfg->srcdir.z * cfg->srcparam1.x - cfg->srcdir.x * cfg->srcparam1.z);
mmc_raytrace.c:2279:        v2.z = v2.w * (cfg->srcdir.x * cfg->srcparam1.y - cfg->srcdir.y * cfg->srcparam1.x);
mmc_raytrace.c:2280:        r->p0.x = cfg->srcpos.x + rx * cfg->srcparam1.x + ry * v2.x;
mmc_raytrace.c:2281:        r->p0.y = cfg->srcpos.y + rx * cfg->srcparam1.y + ry * v2.y;
mmc_raytrace.c:2282:        r->p0.z = cfg->srcpos.z + rx * cfg->srcparam1.z + ry * v2.z;
mmc_raytrace.c:2284:        if (cfg->srctype == stFourier2D) {
mmc_raytrace.c:2285:            r->weight = (sinf((cfg->srcparam2.x * rx + cfg->srcparam2.z) * TWO_PI) * sinf((cfg->srcparam2.y * ry + cfg->srcparam2.w) * TWO_PI) + 1.f) * 0.5f;    //between 0 and 1
mmc_raytrace.c:2287:            r->weight = (cosf((cfg->srcparam2.x * rx + cfg->srcparam2.y * ry + cfg->srcparam2.z) * TWO_PI) * (1.f - cfg->srcparam2.w) + 1.f) * 0.5f;    //between 0 and 1
mmc_raytrace.c:2290:        origin.x += (cfg->srcparam1.x + v2.x) * 0.5f;
mmc_raytrace.c:2291:        origin.y += (cfg->srcparam1.y + v2.y) * 0.5f;
mmc_raytrace.c:2292:        origin.z += (cfg->srcparam1.z + v2.z) * 0.5f;
mmc_raytrace.c:2293:    } else if (cfg->srctype == stDisk || cfg->srctype == stGaussian) { // uniform disk and Gaussian beam
mmc_raytrace.c:2300:        if (cfg->srctype == stDisk) {
mmc_raytrace.c:2301:            r0 = sqrtf(rand_uniform01(ran)) * cfg->srcparam1.x;
mmc_raytrace.c:2302:        } else if (fabs(r->focus) < 1e-5f || fabs(cfg->srcparam1.y) < 1e-5f) {
mmc_raytrace.c:2303:            r0 = sqrtf(-log(rand_uniform01(ran))) * cfg->srcparam1.x;
mmc_raytrace.c:2305:            float z0 = cfg->srcparam1.x * cfg->srcparam1.x * M_PI / cfg->srcparam1.y; //Rayleigh range
mmc_raytrace.c:2306:            r0 = sqrtf(-log(rand_uniform01(ran)) * (1.f + (r->focus * r->focus / (z0 * z0)))) * cfg->srcparam1.x;
mmc_raytrace.c:2309:        if (cfg->srcdir.z > -1.f + EPS && cfg->srcdir.z < 1.f - EPS) {
mmc_raytrace.c:2310:            float tmp0 = 1.f - cfg->srcdir.z * cfg->srcdir.z;
mmc_raytrace.c:2312:            r->p0.x = cfg->srcpos.x + tmp1 * (cfg->srcdir.x * cfg->srcdir.z * cphi - cfg->srcdir.y * sphi);
mmc_raytrace.c:2313:            r->p0.y = cfg->srcpos.y + tmp1 * (cfg->srcdir.y * cfg->srcdir.z * cphi + cfg->srcdir.x * sphi);
mmc_raytrace.c:2314:            r->p0.z = cfg->srcpos.z - tmp1 * tmp0 * cphi;
mmc_raytrace.c:2316:            r->p0.x += r0 * cphi;
mmc_raytrace.c:2317:            r->p0.y += r0 * sphi;
mmc_raytrace.c:2319:    } else if (cfg->srctype == stCone || cfg->srctype == stIsotropic || cfg->srctype == stArcSin) {
mmc_raytrace.c:2325:        if (cfg->srctype == stCone) { // a solid-angle section of a uniform sphere
mmc_raytrace.c:2327:                ang = (cfg->srcparam1.y > 0) ? TWO_PI * rand_uniform01(ran) : acosf(2.f * rand_uniform01(ran) - 1.f); //sine distribution
mmc_raytrace.c:2328:            } while (ang > cfg->srcparam1.x);
mmc_raytrace.c:2330:            if (cfg->srctype == stIsotropic) { // uniform sphere
mmc_raytrace.c:2331:                ang = acosf(2.f * rand_uniform01(ran) - 1.f);    //sine distribution
mmc_raytrace.c:2339:        r->vec.x = stheta * cphi;
mmc_raytrace.c:2340:        r->vec.y = stheta * sphi;
mmc_raytrace.c:2341:        r->vec.z = ctheta;
mmc_raytrace.c:2344:        if (r->eid > 0) {
mmc_raytrace.c:2347:    } else if (cfg->srctype == stZGaussian) {
mmc_raytrace.c:2352:        ang = sqrtf(-2.f * log(rand_uniform01(ran))) * (1.f - 2.f * rand_uniform01(ran0)) * cfg->srcparam1.x;
mmc_raytrace.c:2355:        r->vec.x = stheta * cphi;
mmc_raytrace.c:2356:        r->vec.y = stheta * sphi;
mmc_raytrace.c:2357:        r->vec.z = ctheta;
mmc_raytrace.c:2359:    } else if (cfg->srctype == stLine || cfg->srctype == stSlit) {
mmc_raytrace.c:2361:        r->p0.x += t * cfg->srcparam1.x;
mmc_raytrace.c:2362:        r->p0.y += t * cfg->srcparam1.y;
mmc_raytrace.c:2363:        r->p0.z += t * cfg->srcparam1.z;
mmc_raytrace.c:2365:        if (cfg->srctype == stLine) {
mmc_raytrace.c:2367:            t = 1.f - 2.f * rand_uniform01(ran);
mmc_raytrace.c:2368:            s = 1.f - 2.f * rand_uniform01(ran);
mmc_raytrace.c:2369:            p = sqrtf(1.f - r->vec.x * r->vec.x - r->vec.y * r->vec.y) * (rand_uniform01(ran) > 0.5f ? 1.f : -1.f);
mmc_raytrace.c:2371:            vv.x = r->vec.y * p - r->vec.z * s;
mmc_raytrace.c:2372:            vv.y = r->vec.z * t - r->vec.x * p;
mmc_raytrace.c:2373:            vv.z = r->vec.x * s - r->vec.y * t;
mmc_raytrace.c:2374:            r->vec = vv;
mmc_raytrace.c:2375:            //*((MMCfloat3*)&(r->vec))=(MMCfloat3)(r->vec.y*p-r->vec.z*s,r->vec.z*t-r->vec.x*p,r->vec.x*s-r->vec.y*t);
mmc_raytrace.c:2378:        origin.x += (cfg->srcparam1.x) * 0.5f;
mmc_raytrace.c:2379:        origin.y += (cfg->srcparam1.y) * 0.5f;
mmc_raytrace.c:2380:        origin.z += (cfg->srcparam1.z) * 0.5f;
mmc_raytrace.c:2381:        canfocus = (cfg->srctype == stSlit);
mmc_raytrace.c:2384:    if (canfocus && r->focus != 0.f) { // if beam focus is set, determine the incident angle
mmc_raytrace.c:2386:        origin.x += r->focus * r->vec.x;
mmc_raytrace.c:2387:        origin.y += r->focus * r->vec.y;
mmc_raytrace.c:2388:        origin.z += r->focus * r->vec.z;
mmc_raytrace.c:2390:        if (r->focus < 0.f) { // diverging beam
mmc_raytrace.c:2391:            r->vec.x = r->p0.x - origin.x;
mmc_raytrace.c:2392:            r->vec.y = r->p0.y - origin.y;
mmc_raytrace.c:2393:            r->vec.z = r->p0.z - origin.z;
mmc_raytrace.c:2395:            r->vec.x = origin.x - r->p0.x;
mmc_raytrace.c:2396:            r->vec.y = origin.y - r->p0.y;
mmc_raytrace.c:2397:            r->vec.z = origin.z - r->p0.z;
mmc_raytrace.c:2400:        Rn2 = 1.f / sqrtf(vec_dot(&r->vec, &r->vec)); // normalize
mmc_raytrace.c:2401:        vec_mult(&r->vec, Rn2, &r->vec);
mmc_raytrace.c:2404:    vec_mult_add(&(r->p0), &(r->vec), 1.f, EPS, &(r->p0));
mmc_raytrace.c:2406:    /*Caluclate intial element id and bary-centric coordinates for area sources - position changes everytime*/
mmc_raytrace.c:2407:    MMCfloat3 vecS = {0.f}, *nodes = mesh->node, vecAB, vecAC, vecN;
mmc_raytrace.c:2411:    for (is = 0; is < mesh->srcelemlen; is++) {
mmc_raytrace.c:2413:        int* elems = (int*)(mesh->elem + (mesh->srcelem[is] - 1) * mesh->elemlen);
mmc_raytrace.c:2416:            ea = elems[out[i][0]] - 1;
mmc_raytrace.c:2417:            eb = elems[out[i][1]] - 1;
mmc_raytrace.c:2418:            ec = elems[out[i][2]] - 1;
mmc_raytrace.c:2421:            vec_diff(&nodes[ea], &(r->p0), &vecS);
mmc_raytrace.c:2423:            bary[facemap[i]] = -vec_dot(&vecS, &vecN);
mmc_raytrace.c:2427:            if (bary[i] < -1e-4f) {
mmc_raytrace.c:2433:            r->eid = mesh->srcelem[is];
mmc_raytrace.c:2440:            r->bary0.x = bary[0] / s;
mmc_raytrace.c:2441:            r->bary0.y = bary[1] / s;
mmc_raytrace.c:2442:            r->bary0.z = bary[2] / s;
mmc_raytrace.c:2443:            r->bary0.w = bary[3] / s;
mmc_raytrace.c:2446:                if ((bary[i] / s) < 1e-4f) {
mmc_raytrace.c:2447:                    r->faceid = ifacemap[i] + 1;
mmc_raytrace.c:2455:    if (is == mesh->srcelemlen) {
mmc_raytrace.c:2458:            MMC_FPRINTF(cfg->flog, "all tetrahedra (%d) labeled with -1 do not enclose the source!\n", mesh->srcelemlen);
mmc_raytrace.c:2460:            if (mesh->srcelemlen) {
mmc_raytrace.c:2461:                int* elems = (int*)(mesh->elem + (mesh->srcelem[0] - 1) * mesh->elemlen);
mmc_raytrace.c:2462:                MMC_FPRINTF(cfg->flog, "elem %d %d [%f %f %f] \n", mesh->srcelem[0], elems[0], mesh->node[elems[0] - 1].x, mesh->node[elems[0] - 1].y, mesh->node[elems[0] - 1].z);
mmc_raytrace.c:2463:                MMC_FPRINTF(cfg->flog, "elem %d %d [%f %f %f] \n", mesh->srcelem[0], elems[1], mesh->node[elems[1] - 1].x, mesh->node[elems[1] - 1].y, mesh->node[elems[1] - 1].z);
mmc_raytrace.c:2464:                MMC_FPRINTF(cfg->flog, "elem %d %d [%f %f %f] \n", mesh->srcelem[0], elems[2], mesh->node[elems[2] - 1].x, mesh->node[elems[2] - 1].y, mesh->node[elems[2] - 1].z);
mmc_raytrace.c:2465:                MMC_FPRINTF(cfg->flog, "elem %d %d [%f %f %f] \n", mesh->srcelem[0], elems[3], mesh->node[elems[3] - 1].x, mesh->node[elems[3] - 1].y, mesh->node[elems[3] - 1].z);
mmc_raytrace.c:2466:                MMC_FPRINTF(cfg->flog, "source position [%e %e %e] \n", r->p0.x, r->p0.y, r->p0.z);
mmc_raytrace.c:2467:                MMC_FPRINTF(cfg->flog, "bary centric volume [%e %e %e %e] \n", bary[0], bary[1], bary[2], bary[3]);
mmc_raytrace.c:2477: * @brief Deal with absorption using MCML-like algorithm (albedo-weight MC)
mmc_raytrace.c:2479: * This function performs MCML-like absorption calculations
mmc_raytrace.c:2488:    float* baryp0 = &(r->bary0.x);
mmc_raytrace.c:2489:    int eid = r->eid - 1;
mmc_raytrace.c:2490:    int* ee = (int*)(mesh->elem + eid * mesh->elemlen);
mmc_raytrace.c:2491:    int i, tshift, datalen = (cfg->method == rtBLBadouelGrid) ? cfg->crop0.z : ( (cfg->basisorder) ? mesh->nn : mesh->ne);;
mmc_raytrace.c:2493:    medium* prop = mesh->med + (mesh->type[eid]);
mmc_raytrace.c:2494:    float ww = r->weight;
mmc_raytrace.c:2496:    r->weight *= prop->mus / (prop->mua + prop->mus);
mmc_raytrace.c:2498:    ww -= r->weight;
mmc_raytrace.c:2499:    r->Eabsorb += ww;
mmc_raytrace.c:2501:    tshift = MIN( ((int)((r->photontimer - cfg->tstart) * visit->rtstep)), cfg->maxgate - 1 ) * datalen;
mmc_raytrace.c:2503:    if (cfg->method == rtBLBadouelGrid) {
mmc_raytrace.c:2506:        if (!cfg->basisorder) {
mmc_raytrace.c:2507:            if (cfg->isatomic)
mmc_raytrace.c:2509:                mesh->weight[eid + tshift] += ww;
mmc_raytrace.c:2511:                mesh->weight[eid + tshift] += ww;
mmc_raytrace.c:2514:            if (cfg->isatomic)
mmc_raytrace.c:2517:                    mesh->weight[ee[i] - 1 + tshift] += ww * baryp0[i];
mmc_raytrace.c:2520:                    mesh->weight[ee[i] - 1 + tshift] += ww * baryp0[i];
mmc_raytrace.c:2527:    visit->launchweight = (double*)calloc(cfg->srcnum, sizeof(double));
mmc_raytrace.c:2528:    visit->absorbweight = (double*)calloc(cfg->srcnum, sizeof(double));
mmc_raytrace.c:2529:    visit->kahanc0 = (double*)calloc(cfg->srcnum, sizeof(double));
mmc_raytrace.c:2530:    visit->kahanc1 = (double*)calloc(cfg->srcnum, sizeof(double));
mmc_raytrace.c:2534:    free(visit->launchweight);
mmc_raytrace.c:2535:    visit->launchweight = NULL;
mmc_raytrace.c:2536:    free(visit->absorbweight);
mmc_raytrace.c:2537:    visit->absorbweight = NULL;
mmc_raytrace.c:2538:    free(visit->kahanc0);
mmc_raytrace.c:2539:    visit->kahanc0 = NULL;
mmc_raytrace.c:2540:    free(visit->kahanc1);
mmc_raytrace.c:2541:    visit->kahanc1 = NULL;
mmc_raytrace.c:2545:    if (immctype == 1 && mesh->edgeroi) {
mmc_raytrace.c:2546:        r->roisize = (float*)(mesh->edgeroi + (r->eid - 1) * 6);
mmc_raytrace.c:2547:    } else if (mesh->faceroi) {
mmc_raytrace.c:2548:        r->roisize = (float*)(mesh->faceroi + (r->eid - 1) * 4);
mmc_utils.c:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_utils.c:5:**  \copyright Qianqian Fang, 2010-2021
mmc_utils.c:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_utils.c:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_utils.c:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_utils.c:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_utils.c:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_utils.c:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_utils.c:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_utils.c:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_utils.c:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_utils.c:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_utils.c:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_utils.c:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_utils.c:64:     ((tmp=cJSON_GetObjectItem(root,idfull))==0 ? fallback : tmp->val) \
mmc_utils.c:65:     : tmp->val)
mmc_utils.c:97: * If a short command line option is '-' that means it only has long/verbose option.
mmc_utils.c:102:                         'd', 'r', 'S', 'e', 'U', 'R', 'l', 'L', 'I', '-', 'u', 'C', 'M',
mmc_utils.c:103:                         'i', 'V', 'O', '-', 'F', 'q', 'x', 'P', 'k', 'v', 'm', '-', '-',
mmc_utils.c:104:                         'J', 'o', 'H', '-', 'W', 'X', '-', 'c', '-', '-', 'Z', '\0'
mmc_utils.c:112:const char* fullopt[] = {"--help", "--seed", "--input", "--photon", "--autopilot",
mmc_utils.c:113:                         "--thread", "--blocksize", "--session", "--array",
mmc_utils.c:114:                         "--gategroup", "--reflect", "--debug", "--gpu", "--savedet",
mmc_utils.c:115:                         "--repeat", "--save2pt", "--minenergy",
mmc_utils.c:116:                         "--normalize", "--skipradius", "--log", "--listgpu",
mmc_utils.c:117:                         "--printgpu", "--root", "--unitinmm", "--basisorder",
mmc_utils.c:118:                         "--method", "--interactive", "--specular", "--outputtype",
mmc_utils.c:119:                         "--momentum", "--outputformat", "--saveseed", "--saveexit",
mmc_utils.c:120:                         "--replaydet", "--voidtime", "--version", "--mc", "--atomic",
mmc_utils.c:121:                         "--debugphoton", "--compileropt", "--optlevel", "--maxdetphoton",
mmc_utils.c:122:                         "--buffer", "--workload", "--saveref", "--gridsize", "--compute",
mmc_utils.c:123:                         "--bench", "--dumpjson", "--zip", ""
mmc_utils.c:138: * Selecting mesh-based ray-tracing algorithm:
mmc_utils.c:139: * p: Plucker-based ray-tracer, see Fang2010
mmc_utils.c:140: * h: Havel-based SSE4 ray-tracer, see Fang2012
mmc_utils.c:141: * b: Badouel ray-tracing algorithm, see Fang2011
mmc_utils.c:142: * s: branch-less Badouel SSE4 ray-tracer, see Fang2011
mmc_utils.c:143: * g: grid-output using dual-mesh MMC
mmc_utils.c:204:    cfg->medianum = 0;
mmc_utils.c:205:    cfg->srcnum = 1;
mmc_utils.c:206:    cfg->detnum = 0;
mmc_utils.c:207:    cfg->e0 = 0;
mmc_utils.c:208:    cfg->dim.x = 0;
mmc_utils.c:209:    cfg->dim.y = 0;
mmc_utils.c:210:    cfg->dim.z = 0;
mmc_utils.c:211:    cfg->steps.x = 1.f;
mmc_utils.c:212:    cfg->steps.y = 1.f;
mmc_utils.c:213:    cfg->steps.z = 1.f;
mmc_utils.c:214:    cfg->nblocksize = 64;
mmc_utils.c:215:    cfg->nphoton = 0;
mmc_utils.c:216:    cfg->nthread = 1024 * 8;
mmc_utils.c:217:    cfg->seed = 0x623F9A9E;
mmc_utils.c:218:    cfg->isrowmajor = 0;    /* not needed */
mmc_utils.c:219:    cfg->maxgate = 1;
mmc_utils.c:220:    cfg->implicit = 0;
mmc_utils.c:221:    cfg->isreflect = 1;
mmc_utils.c:222:    cfg->isref3 = 1;
mmc_utils.c:223:    cfg->isnormalized = 1;
mmc_utils.c:224:    cfg->issavedet = 0;
mmc_utils.c:225:    cfg->respin = 1;
mmc_utils.c:226:    cfg->issave2pt = 1;
mmc_utils.c:227:    cfg->isgpuinfo = 0;
mmc_utils.c:228:    cfg->basisorder = 1;
mmc_utils.c:229:    cfg->compute = cbOpenCL;
mmc_utils.c:231:    cfg->isdumpjson = 0;
mmc_utils.c:232:    cfg->zipid = zmZlib;
mmc_utils.c:233:    memset(cfg->jsonfile, 0, MAX_PATH_LENGTH);
mmc_utils.c:234:    cfg->shapedata = NULL;
mmc_utils.c:237:    cfg->method = rtBLBadouelGrid;
mmc_utils.c:240:    cfg->method = rtPlucker;
mmc_utils.c:242:    cfg->method = rtHavel;
mmc_utils.c:245:    cfg->prop = NULL;
mmc_utils.c:246:    cfg->detpos = NULL;
mmc_utils.c:247:    cfg->vol = NULL;
mmc_utils.c:248:    cfg->session[0] = '\0';
mmc_utils.c:249:    cfg->meshtag[0] = '\0';
mmc_utils.c:250:    cfg->minenergy = 1e-6f;
mmc_utils.c:251:    cfg->flog = stdout;
mmc_utils.c:252:    cfg->sradius = 0.f;
mmc_utils.c:253:    cfg->rootpath[0] = '\0';
mmc_utils.c:254:    cfg->seedfile[0] = '\0';
mmc_utils.c:255:    cfg->debuglevel = 0;
mmc_utils.c:256:    cfg->minstep = 1.f;
mmc_utils.c:257:    cfg->roulettesize = 10.f;
mmc_utils.c:258:    cfg->nout = 1.f;
mmc_utils.c:259:    cfg->unitinmm = 1.f;
mmc_utils.c:260:    cfg->srctype = 0;
mmc_utils.c:261:    cfg->isspecular = 0;
mmc_utils.c:262:    cfg->issaveref = 0;
mmc_utils.c:263:    cfg->outputtype = otFlux;
mmc_utils.c:264:    cfg->outputformat = ofASCII;
mmc_utils.c:265:    cfg->ismomentum = 0;
mmc_utils.c:266:    cfg->issaveseed = 0;
mmc_utils.c:267:    cfg->issaveexit = 0;
mmc_utils.c:268:    cfg->photonseed = NULL;
mmc_utils.c:269:    cfg->replaydet = 0;
mmc_utils.c:270:    cfg->replayweight = NULL;
mmc_utils.c:271:    cfg->replaytime = NULL;
mmc_utils.c:272:    cfg->isextdet = 0;
mmc_utils.c:273:    cfg->srcdir.w = 0.f;
mmc_utils.c:274:    cfg->isatomic = 1;
mmc_utils.c:275:    cfg->debugphoton = -1;
mmc_utils.c:276:    cfg->savedetflag = 0x47;
mmc_utils.c:277:    cfg->mediabyte = 1;
mmc_utils.c:279:    cfg->tstart = 0.f;
mmc_utils.c:280:    cfg->tstep = 0.f;
mmc_utils.c:281:    cfg->tend = 0.f;
mmc_utils.c:283:    cfg->mcmethod = mmMCX;
mmc_utils.c:285:    memset(&(cfg->his), 0, sizeof(history));
mmc_utils.c:286:    cfg->his.version = 1;
mmc_utils.c:287:    cfg->his.unitinmm = 1.f;
mmc_utils.c:288:    cfg->his.normalizer = 1.f;
mmc_utils.c:289:    cfg->his.respin = 1;
mmc_utils.c:290:    cfg->his.srcnum = cfg->srcnum;
mmc_utils.c:291:    cfg->his.savedetflag = 0;
mmc_utils.c:293:    memcpy(cfg->his.magic, "MCXH", 4);
mmc_utils.c:295:    memset(&(cfg->srcpos), 0, sizeof(float3));
mmc_utils.c:296:    memset(&(cfg->srcdir), 0, sizeof(float3));
mmc_utils.c:297:    memset(&(cfg->bary0), 0, sizeof(float4));
mmc_utils.c:298:    memset(&(cfg->srcparam1), 0, sizeof(float4));
mmc_utils.c:299:    memset(&(cfg->srcparam2), 0, sizeof(float4));
mmc_utils.c:300:    cfg->srcpattern = NULL;
mmc_utils.c:301:    cfg->voidtime = 1;
mmc_utils.c:302:    memset(cfg->checkpt, 0, sizeof(unsigned int)*MAX_CHECKPOINT);
mmc_utils.c:304:    memset(&(cfg->detparam1), 0, sizeof(float4));
mmc_utils.c:305:    memset(&(cfg->detparam2), 0, sizeof(float4));
mmc_utils.c:306:    cfg->detpattern = NULL;
mmc_utils.c:308:    cfg->optlevel = 3;
mmc_utils.c:310:    memset(cfg->deviceid, 0, MAX_DEVICE);
mmc_utils.c:311:    memset(cfg->workload, 0, MAX_DEVICE * sizeof(float));
mmc_utils.c:312:    cfg->deviceid[0] = '1'; /*use the first GPU device by default*/
mmc_utils.c:313:    memset(cfg->compileropt, 0, MAX_PATH_LENGTH);
mmc_utils.c:314:    memset(cfg->kernelfile, 0, MAX_SESSION_LENGTH);
mmc_utils.c:315:    cfg->maxdetphoton = 1000000;
mmc_utils.c:316:    cfg->exportfield = NULL;
mmc_utils.c:317:    cfg->exportdetected = NULL;
mmc_utils.c:318:    cfg->exportseed = NULL;
mmc_utils.c:319:    cfg->detectedcount = 0;
mmc_utils.c:320:    cfg->energytot = 0.f;
mmc_utils.c:321:    cfg->energyabs = 0.f;
mmc_utils.c:322:    cfg->energyesc = 0.f;
mmc_utils.c:323:    cfg->runtime = 0;
mmc_utils.c:324:    cfg->autopilot = 1;
mmc_utils.c:325:    cfg->nbuffer = 0;
mmc_utils.c:326:    cfg->gpuid = 0;
mmc_utils.c:329:    cfg->clsource = (char*)mmc_core_cl;
mmc_utils.c:331:    cfg->clsource = NULL;
mmc_utils.c:334:    cfg->parentid = mpMATLAB;
mmc_utils.c:336:    cfg->parentid = mpStandalone;
mmc_utils.c:347:    if (cfg->medianum) {
mmc_utils.c:348:        free(cfg->prop);
mmc_utils.c:351:    if (cfg->detnum) {
mmc_utils.c:352:        free(cfg->detpos);
mmc_utils.c:355:    if (cfg->vol) {
mmc_utils.c:356:        free(cfg->vol);
mmc_utils.c:359:    if (cfg->srcpattern) {
mmc_utils.c:360:        free(cfg->srcpattern);
mmc_utils.c:363:    if (cfg->detpattern) {
mmc_utils.c:364:        free(cfg->detpattern);
mmc_utils.c:367:    if (cfg->photonseed) {
mmc_utils.c:368:        free(cfg->photonseed);
mmc_utils.c:371:    if (cfg->replayweight) {
mmc_utils.c:372:        free(cfg->replayweight);
mmc_utils.c:375:    if (cfg->replaytime) {
mmc_utils.c:376:        free(cfg->replaytime);
mmc_utils.c:379:    if (cfg->exportseed) {
mmc_utils.c:380:        free(cfg->exportseed);
mmc_utils.c:383:    if (cfg->exportdetected) {
mmc_utils.c:384:        free(cfg->exportdetected);
mmc_utils.c:387:    if (cfg->flog && cfg->flog != stdout && cfg->flog != stderr) {
mmc_utils.c:388:        fclose(cfg->flog);
mmc_utils.c:391:    if (cfg->shapedata) {
mmc_utils.c:392:        free(cfg->shapedata);
mmc_utils.c:397:    if (cfg->clsource && cfg->clsource != (char*)mmc_core_cl) {
mmc_utils.c:398:        free(cfg->clsource);
mmc_utils.c:440:    hdr.dim[1] = cfg->dim.x;
mmc_utils.c:441:    hdr.dim[2] = cfg->dim.y;
mmc_utils.c:442:    hdr.dim[3] = cfg->dim.z;
mmc_utils.c:443:    hdr.dim[4] = len / (cfg->dim.x * cfg->dim.y * cfg->dim.z);
mmc_utils.c:446:    hdr.pixdim[1] = cfg->steps.x;
mmc_utils.c:447:    hdr.pixdim[2] = cfg->steps.y;
mmc_utils.c:448:    hdr.pixdim[3] = cfg->steps.z;
mmc_utils.c:452:        hdr.pixdim[4] = cfg->tstep * 1e6f;
mmc_utils.c:464:        hdr.dim[2] = cfg->dim.x;
mmc_utils.c:465:        hdr.dim[3] = cfg->dim.y;
mmc_utils.c:466:        hdr.dim[4] = cfg->dim.z;
mmc_utils.c:467:        hdr.pixdim[4] = cfg->unitinmm;
mmc_utils.c:485:        mcx_error(-9, "Error opening header file for write", __FILE__, __LINE__);
mmc_utils.c:489:        mcx_error(-9, "Error writing header file", __FILE__, __LINE__);
mmc_utils.c:494:            mcx_error(-9, "Error writing header file extension pad", __FILE__, __LINE__);
mmc_utils.c:499:            mcx_error(-9, "Error writing data to file", __FILE__, __LINE__);
mmc_utils.c:511:            mcx_error(-9, "Error opening img file for write", __FILE__, __LINE__);
mmc_utils.c:516:            mcx_error(-9, "Error writing img file", __FILE__, __LINE__);
mmc_utils.c:521:        mcx_error(-9, "Output format is not supported", __FILE__, __LINE__);
mmc_utils.c:577:    UBJ_WRITE_KEY(root, "LastSliceID", uint32, cfg->maxgate);
mmc_utils.c:589:    if (cfg->outputtype >= 0) {
mmc_utils.c:594:        UBJ_WRITE_KEY(root, "Description", string, typestr[(int)cfg->outputtype]);
mmc_utils.c:620:    UBJ_WRITE_KEY(root, "Name", string, cfg->session);
mmc_utils.c:629:    if (mcx_jdataencode(vol, ndim, dims, (isfloat ? "single" : "uint32"), 4, cfg->zipid, root, 1, cfg)) {
mmc_utils.c:630:        MMC_ERROR(-1, "error when converting to JSON");
mmc_utils.c:640:        MMC_ERROR(-1, "error when converting to JSON");
mmc_utils.c:648:        MMC_ERROR(-1, "error opening file to write");
mmc_utils.c:698:    cJSON_AddNumberToObject(hdr, "LastSliceID", cfg->maxgate);
mmc_utils.c:708:    if (cfg->outputtype >= 0) {
mmc_utils.c:713:        cJSON_AddStringToObject(hdr, "Description", typestr[(int)cfg->outputtype]);
mmc_utils.c:733:    cJSON_AddStringToObject(hdr, "Name", cfg->session);
mmc_utils.c:739:    if (mcx_jdataencode(vol, ndim, dims, (isfloat ? "single" : "uint32"), 4, cfg->zipid, dat, 0, cfg)) {
mmc_utils.c:740:        MMC_ERROR(-1, "error when converting to JSON");
mmc_utils.c:747:        MMC_ERROR(-1, "error when converting to JSON");
mmc_utils.c:755:        MMC_ERROR(-1, "error opening file to write");
mmc_utils.c:784:    if (cfg->rootpath[0])
mmc_utils.c:786:        sprintf(name, "%s\\%s", cfg->rootpath, cfg->session);
mmc_utils.c:789:        sprintf(name, "%s/%s", cfg->rootpath, cfg->session);
mmc_utils.c:793:        sprintf(name, "%s", cfg->session);
mmc_utils.c:796:    if (!isref && (cfg->outputformat == ofNifti || cfg->outputformat == ofAnalyze)) {
mmc_utils.c:797:        mcx_savenii(dat, len, name, NIFTI_TYPE_FLOAT64, cfg->outputformat, cfg);
mmc_utils.c:799:    } else if (cfg->outputformat == ofJNifti || cfg->outputformat == ofBJNifti) {
mmc_utils.c:800:        int d1 = (cfg->maxgate == 1);
mmc_utils.c:802:        if (cfg->seed == SEED_FROM_FILE && cfg->replaydet == -1 && (cfg->detnum > 1 || cfg->srcnum > 1)) {
mmc_utils.c:803:            uint dims[5] = {cfg->detnum* cfg->srcnum, cfg->maxgate, cfg->dim.z, cfg->dim.y, cfg->dim.x};
mmc_utils.c:804:            float voxelsize[] = {1, cfg->tstep, cfg->steps.z, cfg->steps.y, cfg->steps.x};
mmc_utils.c:806:            if (cfg->outputformat == ofJNifti) {
mmc_utils.c:812:            uint dims[] = {cfg->dim.x, cfg->dim.y, cfg->dim.z, cfg->maxgate};
mmc_utils.c:813:            float voxelsize[] = {cfg->steps.x, cfg->steps.y, cfg->steps.z, cfg->tstep};
mmc_utils.c:814:            size_t datalen = cfg->dim.x * cfg->dim.y * cfg->dim.z * cfg->maxgate;
mmc_utils.c:824:            if (cfg->outputformat == ofJNifti) {
mmc_utils.c:825:                mcx_savejnii((OutputType*)buf, 4 - d1, dims, voxelsize, name, 1, cfg);
mmc_utils.c:827:                mcx_savebnii((OutputType*)buf, 4 - d1, dims, voxelsize, name, 1, cfg);
mmc_utils.c:836:    sprintf(fname, "%s%s.%s", name, (isref ? "_dref" : ""), (isref ? "bin" : outputformat[(int)cfg->outputformat]));
mmc_utils.c:840:        mcx_error(-2, "can not save data to disk", __FILE__, __LINE__);
mmc_utils.c:843:    if (!isref && cfg->outputformat == ofTX3) {
mmc_utils.c:845:        fwrite(&(cfg->dim.x), sizeof(int), 3, fp);
mmc_utils.c:874:    cJSON_AddNumberToObject(hdr, "Version", cfg->his.version);
mmc_utils.c:875:    cJSON_AddNumberToObject(hdr, "MediaNum", cfg->his.maxmedia);
mmc_utils.c:876:    cJSON_AddNumberToObject(hdr, "DetNum", cfg->his.detnum);
mmc_utils.c:877:    cJSON_AddNumberToObject(hdr, "ColumnNum", cfg->his.colcount);
mmc_utils.c:878:    cJSON_AddNumberToObject(hdr, "TotalPhoton", cfg->his.totalphoton);
mmc_utils.c:880:    cJSON_AddNumberToObject(hdr, "SavedPhoton", cfg->his.savedphoton);
mmc_utils.c:881:    cJSON_AddNumberToObject(hdr, "LengthUnit", cfg->his.unitinmm);
mmc_utils.c:882:    cJSON_AddNumberToObject(hdr, "SeedByte", cfg->his.seedbyte);
mmc_utils.c:883:    cJSON_AddNumberToObject(hdr, "Normalizer", cfg->his.normalizer);
mmc_utils.c:884:    cJSON_AddNumberToObject(hdr, "Repeat", cfg->his.respin);
mmc_utils.c:885:    cJSON_AddNumberToObject(hdr, "SrcNum", cfg->his.srcnum);
mmc_utils.c:886:    cJSON_AddNumberToObject(hdr, "SaveDetFlag", cfg->his.savedetflag);
mmc_utils.c:889:    for (i = 0; i < cfg->medianum; i++) {
mmc_utils.c:891:        cJSON_AddNumberToObject(dat, "mua", cfg->prop[i].mua / cfg->unitinmm);
mmc_utils.c:892:        cJSON_AddNumberToObject(dat, "mus", cfg->prop[i].mus / cfg->unitinmm);
mmc_utils.c:893:        cJSON_AddNumberToObject(dat, "g",   cfg->prop[i].g);
mmc_utils.c:894:        cJSON_AddNumberToObject(dat, "n",   cfg->prop[i].n);
mmc_utils.c:897:    if (cfg->his.detected == 0  && cfg->his.savedphoton) {
mmc_utils.c:909:                    buf[i * dims[1] + j] = ppath[i * cfg->his.colcount + col + j];
mmc_utils.c:914:            if (mcx_jdataencode(buf, 2, dims, dtype[id], 4, cfg->zipid, sub, 0, cfg)) {
mmc_utils.c:915:                MMC_ERROR(-1, "error when converting to JSON");
mmc_utils.c:922:        char colnum[] = {1, cfg->his.maxmedia, cfg->his.maxmedia, cfg->his.maxmedia, 3, 3, 1};
mmc_utils.c:929:            if ((cfg->savedetflag >> id) & 0x1) {
mmc_utils.c:940:                            ibuf[i * dims[1] + j] = ppath[i * cfg->his.colcount + col + j];
mmc_utils.c:949:                            fbuf[i * dims[1] + j] = ppath[i * cfg->his.colcount + col + j];
mmc_utils.c:957:                if (mcx_jdataencode(val, 2, dims, dtype[id], 4, cfg->zipid, sub, 0, cfg)) {
mmc_utils.c:958:                    MMC_ERROR(-1, "error when converting to JSON");
mmc_utils.c:967:    if (cfg->issaveseed && seeds != NULL) {
mmc_utils.c:968:        uint dims[2] = {count, cfg->his.seedbyte};
mmc_utils.c:971:        if (mcx_jdataencode(seeds, 2, dims, "uint8", 1, cfg->zipid, sub, 0, cfg)) {
mmc_utils.c:972:            MMC_ERROR(-1, "error when converting to JSON");
mmc_utils.c:980:        MMC_ERROR(-1, "error when converting to JSON");
mmc_utils.c:983:    filetag = ((cfg->his.detected == 0  && cfg->his.savedphoton) ? 't' : 'h');
mmc_utils.c:985:    if (cfg->rootpath[0]) {
mmc_utils.c:986:        sprintf(fhistory, "%s%c%s_%s.jdat", cfg->rootpath, pathsep, cfg->session, (filetag == 't' ? "traj" : "detp"));
mmc_utils.c:988:        sprintf(fhistory, "%s_%s.jdat", cfg->session, (filetag == 't' ? "traj" : "detp"));
mmc_utils.c:998:        MMC_ERROR(-2, "can not save data to disk");
mmc_utils.c:1021:    if (cfg->flog > 0) { /*stdout is 1*/
mmc_utils.c:1022:        MMC_FPRINTF(cfg->flog, "%s\n", str);
mmc_utils.c:1072: * @param[in] ret: function return value, non-zero means an error
mmc_utils.c:1094:        if (cfg->session[0] == '\0') {
mmc_utils.c:1095:            strcpy(cfg->session, "default");
mmc_utils.c:1101:            MMC_ERROR(-2, "can not load the specified config file");
mmc_utils.c:1115:            if (fread(jbuf, len - 1, 1, fp) != 1) {
mmc_utils.c:1116:                MMC_ERROR(-2, "reading input file is terminated");
mmc_utils.c:1119:            jbuf[len - 1] = '\0';
mmc_utils.c:1124:                MMC_ERROR(-9, "invalid JSON input file");
mmc_utils.c:1134:        if (cfg->session[0] == '\0') {
mmc_utils.c:1135:            strncpy(cfg->session, fname, MAX_SESSION_LENGTH - 1);
mmc_utils.c:1164:            char* offs = (ptrold - jbuf >= 50) ? ptrold - 50 : jbuf;
mmc_utils.c:1204:        strncpy(cfg->meshtag, FIND_JSON_KEY("MeshID", "Mesh.MeshID", Mesh, (MMC_ERROR(-1, "You must specify mesh files"), ""), valuestring), MAX_SESSION_LENGTH - 1);
mmc_utils.c:1205:        cfg->e0 = FIND_JSON_KEY("InitElem", "Mesh.InitElem", Mesh, (MMC_ERROR(-1, "InitElem must be given"), 0.0), valueint);
mmc_utils.c:1208:            cfg->unitinmm = FIND_JSON_KEY("LengthUnit", "Mesh.LengthUnit", Mesh, 1.0, valuedouble);
mmc_utils.c:1219:                cfg->srcpos.x = subitem->child->valuedouble;
mmc_utils.c:1220:                cfg->srcpos.y = subitem->child->next->valuedouble;
mmc_utils.c:1221:                cfg->srcpos.z = subitem->child->next->next->valuedouble;
mmc_utils.c:1227:                cfg->srcdir.x = subitem->child->valuedouble;
mmc_utils.c:1228:                cfg->srcdir.y = subitem->child->next->valuedouble;
mmc_utils.c:1229:                cfg->srcdir.z = subitem->child->next->next->valuedouble;
mmc_utils.c:1231:                if (subitem->child->next->next->next) {
mmc_utils.c:1232:                    cfg->srcdir.w = subitem->child->next->next->next->valuedouble;
mmc_utils.c:1239:                cfg->srctype = mcx_keylookup(subitem->valuestring, srctypeid);
mmc_utils.c:1245:                cfg->srcparam1.x = subitem->child->valuedouble;
mmc_utils.c:1247:                if (subitem->child->next) {
mmc_utils.c:1248:                    cfg->srcparam1.y = subitem->child->next->valuedouble;
mmc_utils.c:1250:                    if (subitem->child->next->next) {
mmc_utils.c:1251:                        cfg->srcparam1.z = subitem->child->next->next->valuedouble;
mmc_utils.c:1253:                        if (subitem->child->next->next->next) {
mmc_utils.c:1254:                            cfg->srcparam1.w = subitem->child->next->next->next->valuedouble;
mmc_utils.c:1263:                cfg->srcparam2.x = subitem->child->valuedouble;
mmc_utils.c:1265:                if (subitem->child->next) {
mmc_utils.c:1266:                    cfg->srcparam2.y = subitem->child->next->valuedouble;
mmc_utils.c:1268:                    if (subitem->child->next->next) {
mmc_utils.c:1269:                        cfg->srcparam2.z = subitem->child->next->next->valuedouble;
mmc_utils.c:1271:                        if (subitem->child->next->next->next) {
mmc_utils.c:1272:                            cfg->srcparam2.w = subitem->child->next->next->next->valuedouble;
mmc_utils.c:1285:                det = dets->child;
mmc_utils.c:1289:                cfg->detnum = cJSON_GetArraySize(dets);
mmc_utils.c:1290:                cfg->detpos = (float4*)malloc(sizeof(float4) * cfg->detnum);
mmc_utils.c:1292:                for (i = 0; i < cfg->detnum; i++) {
mmc_utils.c:1301:                        cfg->detpos[i].x = pos->child->valuedouble;
mmc_utils.c:1302:                        cfg->detpos[i].y = pos->child->next->valuedouble;
mmc_utils.c:1303:                        cfg->detpos[i].z = pos->child->next->next->valuedouble;
mmc_utils.c:1307:                        cfg->detpos[i].w = rad->valuedouble;
mmc_utils.c:1310:                    det = det->next;
mmc_utils.c:1325:            cfg->seed = FIND_JSON_KEY("RNGSeed", "Session.RNGSeed", Session, -1, valueint);
mmc_utils.c:1329:            cfg->nphoton = FIND_JSON_KEY("Photons", "Session.Photons", Session, 0, valueint);
mmc_utils.c:1332:        if (cfg->session[0] == '\0') {
mmc_utils.c:1333:            strncpy(cfg->session, FIND_JSON_KEY("ID", "Session.ID", Session, "default", valuestring), MAX_SESSION_LENGTH);
mmc_utils.c:1337:            cfg->isreflect = FIND_JSON_KEY("DoMismatch", "Session.DoMismatch", Session, cfg->isreflect, valueint);
mmc_utils.c:1341:            cfg->issave2pt = FIND_JSON_KEY("DoSaveVolume", "Session.DoSaveVolume", Session, cfg->issave2pt, valueint);
mmc_utils.c:1345:            cfg->isnormalized = FIND_JSON_KEY("DoNormalize", "Session.DoNormalize", Session, cfg->isnormalized, valueint);
mmc_utils.c:1349:            cfg->issavedet = FIND_JSON_KEY("DoPartialPath", "Session.DoPartialPath", Session, cfg->issavedet, valueint);
mmc_utils.c:1353:            cfg->isspecular = FIND_JSON_KEY("DoSpecular", "Session.DoSpecular", Session, cfg->isspecular, valueint);
mmc_utils.c:1357:            cfg->ismomentum = FIND_JSON_KEY("DoDCS", "Session.DoDCS", Session, cfg->ismomentum, valueint);
mmc_utils.c:1361:            cfg->issaveexit = FIND_JSON_KEY("DoSaveExit", "Session.DoSaveExit", Session, cfg->issaveexit, valueint);
mmc_utils.c:1365:            cfg->issaveseed = FIND_JSON_KEY("DoSaveSeed", "Session.DoSaveSeed", Session, cfg->issaveseed, valueint);
mmc_utils.c:1369:            cfg->basisorder = FIND_JSON_KEY("BasisOrder", "Session.BasisOrder", Session, cfg->basisorder, valueint);
mmc_utils.c:1372:        if (!cfg->outputformat) {
mmc_utils.c:1373:            cfg->outputformat = mcx_keylookup((char*)FIND_JSON_KEY("OutputFormat", "Session.OutputFormat", Session, "ascii", valuestring), outputformat);
mmc_utils.c:1376:        if (cfg->outputformat < 0) {
mmc_utils.c:1377:            MMC_ERROR(-2, "the specified output format is not recognized");
mmc_utils.c:1380:        if (cfg->debuglevel == 0) {
mmc_utils.c:1381:            cfg->debuglevel = mcx_parsedebugopt((char*)FIND_JSON_KEY("DebugFlag", "Session.DebugFlag", Session, "", valuestring));
mmc_utils.c:1385:            strncpy(val, FIND_JSON_KEY("RayTracer", "Session.RayTracer", Session, raytracing + cfg->method, valuestring), 1);
mmc_utils.c:1388:                MMC_ERROR(-2, "the specified ray-tracing method is not recognized");
mmc_utils.c:1391:            cfg->method = val[0];
mmc_utils.c:1395:            strncpy(val, FIND_JSON_KEY("OutputType", "Session.OutputType", Session, outputtype + cfg->outputtype, valuestring), 1);
mmc_utils.c:1398:                MMC_ERROR(-2, "the specified output data type is not recognized");
mmc_utils.c:1401:            cfg->outputtype = val[0];
mmc_utils.c:1408:            ck = ck->child;
mmc_utils.c:1411:                cfg->checkpt[i] = ck->valueint;
mmc_utils.c:1412:                ck = ck->next;
mmc_utils.c:1422:        cfg->tstart = FIND_JSON_KEY("T0", "Forward.T0", Forward, 0.0, valuedouble);
mmc_utils.c:1423:        cfg->tend  = FIND_JSON_KEY("T1", "Forward.T1", Forward, 0.0, valuedouble);
mmc_utils.c:1424:        cfg->tstep = FIND_JSON_KEY("Dt", "Forward.Dt", Forward, 0.0, valuedouble);
mmc_utils.c:1425:        cfg->nout = FIND_JSON_KEY("N0", "Forward.N0", Forward, cfg->nout, valuedouble);
mmc_utils.c:1427:        cfg->maxgate = (int)((cfg->tend - cfg->tstart) / cfg->tstep + 0.5);
mmc_utils.c:1430:    if (cfg->meshtag[0] == '\0') {
mmc_utils.c:1431:        MMC_ERROR(-1, "You must specify mesh files");
mmc_utils.c:1434:    if (cfg->e0 == 0) {
mmc_utils.c:1435:        MMC_ERROR(-1, "InitElem must be given");
mmc_utils.c:1455:            MMC_ERROR(-2, "can not write to the specified config file");
mmc_utils.c:1484:    if (cfg->nphoton == 0) {
mmc_utils.c:1485:        cfg->nphoton = nphoton;
mmc_utils.c:1491:        MMC_FPRINTF(stdout, ">> %zu\nPlease specify the random number generator seed: [123456789]\n\t", cfg->nphoton);
mmc_utils.c:1494:    if (cfg->seed == 0x623F9A9E) {
mmc_utils.c:1495:        MMC_ASSERT(fscanf(in, "%d", &(cfg->seed) ) == 1);
mmc_utils.c:1503:        MMC_FPRINTF(stdout, ">> %d\nPlease specify the position of the source: [10 10 5]\n\t", cfg->seed);
mmc_utils.c:1506:    MMC_ASSERT(fscanf(in, "%f %f %f", &(cfg->srcpos.x), &(cfg->srcpos.y), &(cfg->srcpos.z) ) == 3);
mmc_utils.c:1511:                    cfg->srcpos.x, cfg->srcpos.y, cfg->srcpos.z);
mmc_utils.c:1513:    MMC_ASSERT(fscanf(in, "%f %f %f", &(cfg->srcdir.x), &(cfg->srcdir.y), &(cfg->srcdir.z)));
mmc_utils.c:1517:        cfg->srcdir.w = dtmp;
mmc_utils.c:1521:        MMC_FPRINTF(stdout, ">> %f %f %f %f\nPlease specify the time gates in seconds (start end step) [0.0 1e-9 1e-10]\n\t",
mmc_utils.c:1522:                    cfg->srcdir.x, cfg->srcdir.y, cfg->srcdir.z, cfg->srcdir.w);
mmc_utils.c:1524:    MMC_ASSERT(fscanf(in, "%f %f %f", &(cfg->tstart), &(cfg->tend), &(cfg->tstep) ) == 3);
mmc_utils.c:1529:                    cfg->tstart, cfg->tend, cfg->tstep);
mmc_utils.c:1531:    if (cfg->tstart > cfg->tend || cfg->tstep == 0.f) {
mmc_utils.c:1532:        MMC_ERROR(-9, "incorrect time gate settings");
mmc_utils.c:1535:    if (cfg->tstep > cfg->tend - cfg->tstart) {
mmc_utils.c:1536:        cfg->tstep = cfg->tend - cfg->tstart;
mmc_utils.c:1539:    gates = (int)((cfg->tend - cfg->tstart) / cfg->tstep + 0.5);
mmc_utils.c:1540:    /*if(cfg->maxgate>gates)*/
mmc_utils.c:1541:    cfg->maxgate = gates;
mmc_utils.c:1543:    MMC_ASSERT(fscanf(in, "%s", cfg->meshtag) == 1);
mmc_utils.c:1545:    if (cfg->rootpath[0]) {
mmc_utils.c:1547:        sprintf(comment, "%s\\%s", cfg->rootpath, cfg->meshtag);
mmc_utils.c:1549:        sprintf(comment, "%s/%s", cfg->rootpath, cfg->meshtag);
mmc_utils.c:1551:        memcpy(cfg->meshtag, comment, MAX_SESSION_LENGTH);
mmc_utils.c:1557:        MMC_FPRINTF(stdout, ">> %s\nPlease specify the index to the tetrahedral element enclosing the source [start from 1]:\n\t", cfg->meshtag);
mmc_utils.c:1560:    MMC_ASSERT(fscanf(in, "%d", &(cfg->e0)) == 1);
mmc_utils.c:1564:        MMC_FPRINTF(stdout, ">> %d\nPlease specify the total number of detectors and detector diameter (in mm):\n\t", cfg->e0);
mmc_utils.c:1567:    MMC_ASSERT(fscanf(in, "%d %f", &(cfg->detnum), &(cfg->detradius)) == 2);
mmc_utils.c:1571:        MMC_FPRINTF(stdout, ">> %d %f\n", cfg->detnum, cfg->detradius);
mmc_utils.c:1574:    cfg->detpos = (float4*)malloc(sizeof(float4) * cfg->detnum);
mmc_utils.c:1576:    if (cfg->issavedet) {
mmc_utils.c:1577:        cfg->issavedet = (cfg->detpos > 0);
mmc_utils.c:1580:    for (i = 0; i < cfg->detnum; i++) {
mmc_utils.c:1585:        MMC_ASSERT(fscanf(in, "%f %f %f", &(cfg->detpos[i].x), &(cfg->detpos[i].y), &(cfg->detpos[i].z)) == 3);
mmc_utils.c:1589:            cfg->detpos[i].w = dtmp;
mmc_utils.c:1591:            cfg->detpos[i].w = cfg->detradius;
mmc_utils.c:1595:            MMC_FPRINTF(stdout, ">> %f %f %f\n", cfg->detpos[i].x, cfg->detpos[i].y, cfg->detpos[i].z);
mmc_utils.c:1606:        if (srctype == -1) {
mmc_utils.c:1607:            MMC_ERROR(-6, "the specified source type is not supported");
mmc_utils.c:1612:            cfg->srctype = srctype;
mmc_utils.c:1615:                MMC_FPRINTF(stdout, ">> %d\nPlease specify the source parameters set 1 (4 floating-points):\n\t", cfg->srctype);
mmc_utils.c:1618:            MMC_ASSERT(fscanf(in, "%f %f %f %f", &(cfg->srcparam1.x), &(cfg->srcparam1.y), &(cfg->srcparam1.z), &(cfg->srcparam1.w)) == 4);
mmc_utils.c:1622:                MMC_FPRINTF(stdout, ">> %f %f %f %f\nPlease specify the source parameters set 2 (4 floating-points):\n\t",
mmc_utils.c:1623:                            cfg->srcparam1.x, cfg->srcparam1.y, cfg->srcparam1.z, cfg->srcparam1.w);
mmc_utils.c:1625:            if (fscanf(in, "%f %f %f %f", &(cfg->srcparam2.x), &(cfg->srcparam2.y), &(cfg->srcparam2.z), &(cfg->srcparam2.w)) == 4) {
mmc_utils.c:1629:                    MMC_FPRINTF(stdout, ">> %f %f %f %f\n", cfg->srcparam2.x, cfg->srcparam2.y, cfg->srcparam2.z, cfg->srcparam2.w);
mmc_utils.c:1632:                if (cfg->srctype == stPattern && cfg->srcparam1.w * cfg->srcparam2.w > 0) {
mmc_utils.c:1640:                    if (cfg->srcpattern) {
mmc_utils.c:1641:                        free(cfg->srcpattern);
mmc_utils.c:1645:                    MMC_ASSERT(fscanf(in, "%s %d", srcpatternfile, &(cfg->srcnum)) >= 1);
mmc_utils.c:1647:                    if (cfg->srcnum < 1) {
mmc_utils.c:1648:                        MMC_ERROR(-6, "the number of patterns cannot be smaller than 1");
mmc_utils.c:1651:                    cfg->srcpattern = (float*)calloc((cfg->srcparam1.w * cfg->srcparam2.w * cfg->srcnum), sizeof(float));
mmc_utils.c:1656:                        MMC_ERROR(-6, "source pattern file can not be opened");
mmc_utils.c:1659:                    MMC_ASSERT(fread(cfg->srcpattern, cfg->srcparam1.w * cfg->srcparam2.w * cfg->srcnum, sizeof(float), fp) == sizeof(float));
mmc_utils.c:1664:            if (cfg->detnum == 1 && cfg->detpos[0].w == 0.0) {
mmc_utils.c:1665:                // only one detector and its radius is 0, indicates that we are using a wide-field detector
mmc_utils.c:1667:                    MMC_FPRINTF(stdout, ">> \nPlease specify the detector parameters set 1 (4 floating-points):\n\t");
mmc_utils.c:1670:                MMC_ASSERT(fscanf(in, "%f %f %f %f", &(cfg->detparam1.x), &(cfg->detparam1.y), &(cfg->detparam1.z), &(cfg->detparam1.w)) == 4);
mmc_utils.c:1674:                    MMC_FPRINTF(stdout, ">> %f %f %f %f\nPlease specify the detector parameters set 2 (4 floating-points):\n\t",
mmc_utils.c:1675:                                cfg->detparam1.x, cfg->detparam1.y, cfg->detparam1.z, cfg->detparam1.w);
mmc_utils.c:1677:                MMC_ASSERT(fscanf(in, "%f %f %f %f", &(cfg->detparam2.x), &(cfg->detparam2.y), &(cfg->detparam2.z), &(cfg->detparam2.w)) == 4);
mmc_utils.c:1681:                    MMC_FPRINTF(stdout, ">> %f %f %f %f\n", cfg->detparam2.x, cfg->detparam2.y, cfg->detparam2.z, cfg->detparam2.w);
mmc_utils.c:1685:                if (cfg->seed == SEED_FROM_FILE && (cfg->outputtype == otWL || cfg->outputtype == otWP) && cfg->detparam1.w * cfg->detparam2.w > 0) {
mmc_utils.c:1693:                    if (cfg->detpattern) {
mmc_utils.c:1694:                        free(cfg->detpattern);
mmc_utils.c:1697:                    cfg->detpattern = (float*)calloc((cfg->detparam1.w * cfg->detparam2.w), sizeof(float));
mmc_utils.c:1703:                        MMC_ERROR(-6, "detector pattern file can not be opened");
mmc_utils.c:1706:                    MMC_ASSERT(fread(cfg->detpattern, cfg->detparam1.w * cfg->detparam2.w, sizeof(float), fp) == sizeof(float));
mmc_utils.c:1728:    MMC_FPRINTF(out, "%zu\n", (cfg->nphoton) );
mmc_utils.c:1729:    MMC_FPRINTF(out, "%d\n", (cfg->seed) );
mmc_utils.c:1730:    MMC_FPRINTF(out, "%f %f %f\n", (cfg->srcpos.x), (cfg->srcpos.y), (cfg->srcpos.z) );
mmc_utils.c:1731:    MMC_FPRINTF(out, "%f %f %f\n", (cfg->srcdir.x), (cfg->srcdir.y), (cfg->srcdir.z) );
mmc_utils.c:1732:    MMC_FPRINTF(out, "%f %f %f\n", (cfg->tstart), (cfg->tend), (cfg->tstep) );
mmc_utils.c:1733:    MMC_FPRINTF(out, "%f %d %d %d\n", (cfg->steps.x), (cfg->dim.x), (cfg->crop0.x), (cfg->crop1.x));
mmc_utils.c:1734:    MMC_FPRINTF(out, "%f %d %d %d\n", (cfg->steps.y), (cfg->dim.y), (cfg->crop0.y), (cfg->crop1.y));
mmc_utils.c:1735:    MMC_FPRINTF(out, "%f %d %d %d\n", (cfg->steps.z), (cfg->dim.z), (cfg->crop0.z), (cfg->crop1.z));
mmc_utils.c:1736:    MMC_FPRINTF(out, "%d", (cfg->medianum));
mmc_utils.c:1738:    for (i = 0; i < cfg->medianum; i++) {
mmc_utils.c:1739:        MMC_FPRINTF(out, "%f %f %f %f\n", (cfg->prop[i].mus), (cfg->prop[i].g), (cfg->prop[i].mua), (cfg->prop[i].n));
mmc_utils.c:1742:    MMC_FPRINTF(out, "%d", (cfg->detnum));
mmc_utils.c:1744:    for (i = 0; i < cfg->detnum; i++) {
mmc_utils.c:1745:        MMC_FPRINTF(out, "%f %f %f %f\n", (cfg->detpos[i].x), (cfg->detpos[i].y), (cfg->detpos[i].z), (cfg->detpos[i].w));
mmc_utils.c:1765:    cJSON_AddStringToObject(obj, "ID", cfg->session);
mmc_utils.c:1766:    cJSON_AddNumberToObject(obj, "Photons", cfg->nphoton);
mmc_utils.c:1767:    cJSON_AddNumberToObject(obj, "RNGSeed", (uint)cfg->seed);
mmc_utils.c:1769:    if (cfg->isreflect > 1) {
mmc_utils.c:1770:        cJSON_AddNumberToObject(obj, "DoMismatch", cfg->isreflect);
mmc_utils.c:1772:        cJSON_AddBoolToObject(obj, "DoMismatch", cfg->isreflect);
mmc_utils.c:1775:    cJSON_AddBoolToObject(obj, "DoSaveVolume", cfg->issave2pt);
mmc_utils.c:1777:    if (cfg->isreflect > 1) {
mmc_utils.c:1778:        cJSON_AddNumberToObject(obj, "DoNormalize", cfg->isnormalized);
mmc_utils.c:1780:        cJSON_AddBoolToObject(obj, "DoNormalize", cfg->isnormalized);
mmc_utils.c:1783:    cJSON_AddBoolToObject(obj, "DoPartialPath", cfg->issavedet);
mmc_utils.c:1785:    if (cfg->issaveref) {
mmc_utils.c:1786:        cJSON_AddNumberToObject(obj, "DoSaveRef", cfg->issaveref);
mmc_utils.c:1788:        cJSON_AddBoolToObject(obj, "DoSaveRef", cfg->issaveref);
mmc_utils.c:1791:    cJSON_AddBoolToObject(obj, "DoSaveExit", cfg->issaveexit);
mmc_utils.c:1792:    cJSON_AddBoolToObject(obj, "DoSaveSeed", cfg->issaveseed);
mmc_utils.c:1793:    cJSON_AddBoolToObject(obj, "DoAutoThread", cfg->autopilot);
mmc_utils.c:1794:    cJSON_AddBoolToObject(obj, "DoDCS", cfg->ismomentum);
mmc_utils.c:1795:    cJSON_AddBoolToObject(obj, "DoSpecular", cfg->isspecular);
mmc_utils.c:1797:    if (cfg->rootpath[0] != '\0') {
mmc_utils.c:1798:        cJSON_AddStringToObject(obj, "RootPath", cfg->rootpath);
mmc_utils.c:1801:    cJSON_AddNumberToObject(obj, "DebugFlag", cfg->debuglevel);
mmc_utils.c:1802:    cJSON_AddNumberToObject(obj, "SaveDataMask", cfg->savedetflag);
mmc_utils.c:1804:    if (cfg->outputformat >= 0) {
mmc_utils.c:1805:        cJSON_AddStringToObject(obj, "OutputFormat", outputformat[(int)cfg->outputformat]);
mmc_utils.c:1808:    if (cfg->outputtype >= 0) {
mmc_utils.c:1810:        outputtypestr[0] = outputtype[(int)cfg->outputtype];
mmc_utils.c:1816:    cJSON_AddNumberToObject(obj, "T0", cfg->tstart);
mmc_utils.c:1817:    cJSON_AddNumberToObject(obj, "T1", cfg->tend);
mmc_utils.c:1818:    cJSON_AddNumberToObject(obj, "Dt", cfg->tstep);
mmc_utils.c:1822:    cJSON_AddNumberToObject(obj, "LengthUnit", cfg->unitinmm);
mmc_utils.c:1825:    for (i = 0; i < cfg->medianum; i++) {
mmc_utils.c:1827:        cJSON_AddNumberToObject(tmp, "mua", cfg->prop[i].mua / cfg->unitinmm);
mmc_utils.c:1828:        cJSON_AddNumberToObject(tmp, "mus", cfg->prop[i].mus / cfg->unitinmm);
mmc_utils.c:1829:        cJSON_AddNumberToObject(tmp, "g",   cfg->prop[i].g);
mmc_utils.c:1830:        cJSON_AddNumberToObject(tmp, "n",   cfg->prop[i].n);
mmc_utils.c:1833:    cJSON_AddItemToObject(obj, "Dim", cJSON_CreateIntArray((int*) & (cfg->dim.x), 3));
mmc_utils.c:1840:    if (cfg->srctype >= 0) {
mmc_utils.c:1841:        cJSON_AddStringToObject(sub, "Type", srctypeid[(int)cfg->srctype]);
mmc_utils.c:1844:    cJSON_AddItemToObject(sub, "Pos", cJSON_CreateFloatArray(&(cfg->srcpos.x), 3));
mmc_utils.c:1845:    cJSON_AddItemToObject(sub, "Dir", cJSON_CreateFloatArray(&(cfg->srcdir.x), 4));
mmc_utils.c:1846:    cJSON_AddItemToObject(sub, "Param1", cJSON_CreateFloatArray(&(cfg->srcparam1.x), 4));
mmc_utils.c:1847:    cJSON_AddItemToObject(sub, "Param2", cJSON_CreateFloatArray(&(cfg->srcparam2.x), 4));
mmc_utils.c:1848:    cJSON_AddNumberToObject(sub, "SrcNum", cfg->srcnum);
mmc_utils.c:1852:    for (i = 0; i < cfg->detnum; i++) {
mmc_utils.c:1854:        cJSON_AddItemToObject(tmp, "Pos", cJSON_CreateFloatArray(&(cfg->detpos[i].x), 3));
mmc_utils.c:1855:        cJSON_AddNumberToObject(tmp, "R", cfg->detpos[i].w);
mmc_utils.c:1859:    if (cfg->shapedata) {
mmc_utils.c:1860:        cJSON* shape = cJSON_Parse(cfg->shapedata), *sp;
mmc_utils.c:1863:            MMC_ERROR(-1, "the input shape construct is not a valid JSON object");
mmc_utils.c:1879:        MMC_ERROR(-1, "error when converting to JSON");
mmc_utils.c:1882:    if (!strcmp(filename, "-")) {
mmc_utils.c:1883:        fprintf(cfg->flog, "%s\n", jsonstr);
mmc_utils.c:1888:            MMC_ERROR(-1, "error opening file to write");
mmc_utils.c:1906: * @brief Convert a column-major (MATLAB/FORTRAN) array to a row-major (C/C++) array
mmc_utils.c:1917:    if (*vol == NULL || dim->x == 0 || dim->y == 0 || dim->z == 0) {
mmc_utils.c:1921:    newvol = (unsigned int*)malloc(sizeof(unsigned int) * dim->x * dim->y * dim->z);
mmc_utils.c:1922:    dimxy = dim->x * dim->y;
mmc_utils.c:1923:    dimyz = dim->y * dim->z;
mmc_utils.c:1925:    for (z = 0; z < dim->z; z++)
mmc_utils.c:1926:        for (y = 0; y < dim->y; y++)
mmc_utils.c:1927:            for (x = 0; x < dim->x; x++) {
mmc_utils.c:1928:                newvol[x * dimyz + y * dim->z + z] = (*vol)[z * dimxy + y * dim->x + x];
mmc_utils.c:1936: * @brief Convert a column-major (MATLAB/FORTRAN) array to a row-major (C/C++) array
mmc_utils.c:1947:    if (*vol == NULL || dim->x == 0 || dim->y == 0 || dim->z == 0 || dim->w == 0) {
mmc_utils.c:1951:    newvol = (unsigned int*)malloc(sizeof(unsigned int) * dim->x * dim->y * dim->z * dim->w);
mmc_utils.c:1952:    dimxyz = dim->x * dim->y * dim->z;
mmc_utils.c:1953:    dimyzw = dim->y * dim->z * dim->w;
mmc_utils.c:1954:    dimxy = dim->x * dim->y;
mmc_utils.c:1955:    dimzw = dim->z * dim->w;
mmc_utils.c:1957:    for (w = 0; w < dim->w; w++)
mmc_utils.c:1958:        for (z = 0; z < dim->z; z++)
mmc_utils.c:1959:            for (y = 0; y < dim->y; y++)
mmc_utils.c:1960:                for (x = 0; x < dim->x; x++) {
mmc_utils.c:1961:                    newvol[x * dimyzw + y * dimzw + z * dim->w + w] = (*vol)[w * dimxyz + z * dimxy + y * dim->x + x];
mmc_utils.c:1984: * @param[in] obj: a pre-created cJSON object to store the output JData fields
mmc_utils.c:2000:        *type = vtype->valuestring;
mmc_utils.c:2001:        cfg->mediabyte = 4;
mmc_utils.c:2004:            cfg->mediabyte = 1;
mmc_utils.c:2006:            cfg->mediabyte = 2;
mmc_utils.c:2008:            MMC_ERROR(-1, "8-byte volume array is not supported");
mmc_utils.c:2014:            cJSON* tmp = vsize->child;
mmc_utils.c:2018:                dims[i] = tmp->valueint;
mmc_utils.c:2019:                tmp = tmp->next;
mmc_utils.c:2027:            int zipid = mcx_keylookup((char*)(ztype->valuestring), zipformat);
mmc_utils.c:2028:            ret = zmat_decode(strlen(vdata->valuestring), (uchar*)vdata->valuestring, &len, (uchar**)&buf, zmBase64, &status);
mmc_utils.c:2042:            cfg->isrowmajor = 1;
mmc_utils.c:2044:            MMC_ERROR(-1, "Only compressed JData array constructs are supported");
mmc_utils.c:2047:        MMC_ERROR(-1, "No _ArrayZipData_ field is found");
mmc_utils.c:2067: * @param[in] obj: a pre-created cJSON object to store the output JData fields
mmc_utils.c:2082:    if (!cfg->isdumpjson) {
mmc_utils.c:2090:        if (!cfg->isdumpjson) {
mmc_utils.c:2108:            if (!cfg->isdumpjson) {
mmc_utils.c:2137: * The debug flag following the -D can be either a string format, or numerical format.
mmc_utils.c:2140: * @param[in] debugopt: string following the -D parameter
mmc_utils.c:2149:        p = strchr((char*)debugflag, ((*c <= 'z' && *c >= 'a') ? *c - 'a' + 'A' : *c) );
mmc_utils.c:2152:            debuglevel |= (1 << (p - debugflag));
mmc_utils.c:2164: * When -D P is specified, this function prints and update a progress bar.
mmc_utils.c:2191:    percentage = percent * (colwidth - 18);
mmc_utils.c:2194:        if (percent != -0.f)
mmc_utils.c:2206:        MMC_FPRINTF(stdout, (percentage < colwidth - 18) ? ">" : "=");
mmc_utils.c:2208:        for (j = percentage; j < colwidth - 18; j++) {
mmc_utils.c:2238:    if (strcmp(type, "bool") == 0 && (id >= argc - 1 || (argv[id + 1][0] < '0' || argv[id + 1][0] > '9'))) {
mmc_utils.c:2243:    if (id < argc - 1) {
mmc_utils.c:2262:                for (i = 0; i < len - 1; i++) /* remove duplicaetd ids */
mmc_utils.c:2263:                    if (numlist[i] == numlist[len - 1]) {
mmc_utils.c:2264:                        numlist[--len] = '\0';
mmc_utils.c:2283:        MMC_ERROR(-1, "incomplete input");
mmc_utils.c:2305:            if (shortopt[i] != '-') {
mmc_utils.c:2346: * @return if found, return the index of the string in the dictionary, otherwise -1.
mmc_utils.c:2354:            key[i] += ('a' - 'A');
mmc_utils.c:2370:    return -1;
mmc_utils.c:2392: * Perform self-checking and raise exceptions or warnings when input error is detected
mmc_utils.c:2400:    if (cfg->nphoton <= 0) {
mmc_utils.c:2401:        MMC_ERROR(-2, "cfg.nphoton must be a positive number");
mmc_utils.c:2404:    if (cfg->tstart > cfg->tend || cfg->tstep == 0.f) {
mmc_utils.c:2405:        MMC_ERROR(-2, "incorrect time gate settings or missing tstart/tend/tstep fields");
mmc_utils.c:2408:    if (cfg->tstep > cfg->tend - cfg->tstart) {
mmc_utils.c:2409:        cfg->tstep = cfg->tend - cfg->tstart;
mmc_utils.c:2412:    if (cfg->steps.x != cfg->steps.y || cfg->steps.y != cfg->steps.z) {
mmc_utils.c:2413:        MMC_ERROR(-2, "MMC dual-grid algorithm currently does not support anisotropic voxels");
mmc_utils.c:2416:    if (fabs(cfg->srcdir.x * cfg->srcdir.x + cfg->srcdir.y * cfg->srcdir.y + cfg->srcdir.z * cfg->srcdir.z - 1.f) > 1e-4) {
mmc_utils.c:2417:        MMC_ERROR(-2, "field 'srcdir' must be a unitary vector (tolerance is 1e-4)");
mmc_utils.c:2420:    if (cfg->tend <= cfg->tstart) {
mmc_utils.c:2421:        MMC_ERROR(-2, "field 'tend' must be greater than field 'tstart'");
mmc_utils.c:2424:    cfg->maxgate = (int)((cfg->tend - cfg->tstart) / cfg->tstep + 0.5);
mmc_utils.c:2425:    cfg->tend = cfg->tstart + cfg->tstep * cfg->maxgate;
mmc_utils.c:2427:    if (cfg->srctype == stPattern && cfg->srcpattern == NULL) {
mmc_utils.c:2428:        MMC_ERROR(-2, "the 'srcpattern' field can not be empty when your 'srctype' is 'pattern'");
mmc_utils.c:2431:    if (cfg->srcnum > 1 && cfg->seed == SEED_FROM_FILE) {
mmc_utils.c:2432:        MMC_ERROR(-2, "multiple source simulation is currently not supported under replay mode");
mmc_utils.c:2435:    if (cfg->seed < 0 && cfg->seed != SEED_FROM_FILE) {
mmc_utils.c:2436:        cfg->seed = time(NULL);
mmc_utils.c:2439:    if (cfg->compute != cbSSE && (cfg->method != rtBLBadouelGrid && cfg->method != rtBLBadouel)) {
mmc_utils.c:2440:        cfg->method = rtBLBadouel;
mmc_utils.c:2443:    if (cfg->method == rtBLBadouelGrid) {
mmc_utils.c:2444:        cfg->basisorder = 0;
mmc_utils.c:2448:        if (cfg->deviceid[i] == '0') {
mmc_utils.c:2449:            cfg->deviceid[i] = '\0';
mmc_utils.c:2462:    if (cfg->issavedet && cfg->detnum == 0 && cfg->isextdet == 0) {
mmc_utils.c:2463:        cfg->issavedet = 0;
mmc_utils.c:2466:    if (cfg->issavedet == 0) {
mmc_utils.c:2467:        cfg->ismomentum = 0;
mmc_utils.c:2468:        cfg->issaveexit = 0;
mmc_utils.c:2471:    cfg->savedetflag = 0x47;
mmc_utils.c:2473:    if (cfg->ismomentum) {
mmc_utils.c:2474:        cfg->savedetflag = SET_SAVE_MOM(cfg->savedetflag);
mmc_utils.c:2477:    if (cfg->issaveexit) {
mmc_utils.c:2478:        cfg->savedetflag = SET_SAVE_PEXIT(cfg->savedetflag);
mmc_utils.c:2479:        cfg->savedetflag = SET_SAVE_VEXIT(cfg->savedetflag);
mmc_utils.c:2505:        if (argv[i][0] == '-') {
mmc_utils.c:2506:            if (argv[i][1] == '-') {
mmc_utils.c:2508:                    MMC_FPRINTF(cfg->flog, "option: %s\n", argv[i]);
mmc_utils.c:2509:                    MMC_ERROR(-2, "unsupported verbose option");
mmc_utils.c:2524:                        MMC_ERROR(-2, "you can not specify both interactive mode and config file");
mmc_utils.c:2533:                    if (i < argc - 1 && argv[i + 1][0] == '{') {
mmc_utils.c:2544:                    cfg->nphoton = (size_t)np;
mmc_utils.c:2548:                    i = mcx_readarg(argc, argv, i, &(cfg->nthread), "int");
mmc_utils.c:2552:                    i = mcx_readarg(argc, argv, i, &(cfg->nblocksize), "int");
mmc_utils.c:2556:                    i = mcx_readarg(argc, argv, i, cfg->session, "string");
mmc_utils.c:2560:                    i = mcx_readarg(argc, argv, i, &(cfg->issaveseed), "bool");
mmc_utils.c:2564:                    i = mcx_readarg(argc, argv, i, &(cfg->maxgate), "int");
mmc_utils.c:2568:                    i = mcx_readarg(argc, argv, i, &(cfg->isreflect), "bool");
mmc_utils.c:2572:                    i = mcx_readarg(argc, argv, i, &(cfg->issavedet), "bool");
mmc_utils.c:2576:                    i = mcx_readarg(argc, argv, i, &(cfg->mcmethod), "int");
mmc_utils.c:2580:                    i = mcx_readarg(argc, argv, i, &(cfg->issaveexit), "bool");
mmc_utils.c:2582:                    if (cfg->issaveexit) {
mmc_utils.c:2583:                        cfg->issavedet = 1;
mmc_utils.c:2589:                    i = mcx_readarg(argc, argv, i, &(cfg->issaveref), "char");
mmc_utils.c:2591:                    if (cfg->issaveref) {
mmc_utils.c:2592:                        cfg->issaveref = 1;
mmc_utils.c:2599:                        cfg->zipid = mcx_keylookup(argv[++i], zipformat);
mmc_utils.c:2601:                        i = mcx_readarg(argc, argv, i, &(cfg->zipid), "int");
mmc_utils.c:2607:                    i = mcx_readarg(argc, argv, i, &(cfg->basisorder), "bool");
mmc_utils.c:2611:                    i = mcx_readarg(argc, argv, i, &(cfg->isspecular), "bool");
mmc_utils.c:2619:                    i = mcx_readarg(argc, argv, i, &(cfg->respin), "int");
mmc_utils.c:2623:                    i = mcx_readarg(argc, argv, i, &(cfg->issave2pt), "bool");
mmc_utils.c:2627:                    i = mcx_readarg(argc, argv, i, &(cfg->minenergy), "float");
mmc_utils.c:2631:                    i = mcx_readarg(argc, argv, i, &(cfg->isnormalized), "bool");
mmc_utils.c:2637:                        MMC_ERROR(-1, "seeding file is not supported in this binary");
mmc_utils.c:2639:                        i = mcx_readarg(argc, argv, i, cfg->seedfile, "string");
mmc_utils.c:2640:                        cfg->seed = SEED_FROM_FILE;
mmc_utils.c:2643:                        i = mcx_readarg(argc, argv, i, &(cfg->seed), "int");
mmc_utils.c:2650:                        MMC_ERROR(-1, "incomplete input");
mmc_utils.c:2653:                    if ((cfg->outputformat = mcx_keylookup(argv[++i], outputformat)) < 0) {
mmc_utils.c:2654:                        MMC_ERROR(-2, "the specified output data type is not recognized");
mmc_utils.c:2660:                    i = mcx_readarg(argc, argv, i, &(cfg->outputtype), "char");
mmc_utils.c:2662:                    if (mcx_lookupindex(&(cfg->outputtype), outputtype)) {
mmc_utils.c:2663:                        MMC_ERROR(-2, "the specified output data type is not recognized");
mmc_utils.c:2669:                    i = mcx_readarg(argc, argv, i, &(cfg->method), "char");
mmc_utils.c:2671:                    if (mcx_lookupindex(&(cfg->method), raytracing)) {
mmc_utils.c:2672:                        MMC_ERROR(-2, "the specified ray-tracing method is not recognized");
mmc_utils.c:2678:                    i = mcx_readarg(argc, argv, i, &(cfg->sradius), "float");
mmc_utils.c:2682:                    i = mcx_readarg(argc, argv, i, &(cfg->replaydet), "int");
mmc_utils.c:2686:                    i = mcx_readarg(argc, argv, i, &(cfg->unitinmm), "float");
mmc_utils.c:2694:                    cfg->isgpuinfo = 2;
mmc_utils.c:2698:                    cfg->isgpuinfo = 1;
mmc_utils.c:2702:                    cfg->compileropt[strlen(cfg->compileropt)] = ' ';
mmc_utils.c:2703:                    i = mcx_readarg(argc, argv, i, cfg->compileropt + strlen(cfg->compileropt), "string");
mmc_utils.c:2707:                    i = mcx_readarg(argc, argv, i, &(cfg->optlevel), "int");
mmc_utils.c:2712:                        cfg->debuglevel = mcx_parsedebugopt(argv[++i]);
mmc_utils.c:2714:                        i = mcx_readarg(argc, argv, i, &(cfg->debuglevel), "int");
mmc_utils.c:2720:                    i = mcx_readarg(argc, argv, i, &(cfg->voidtime), "int");
mmc_utils.c:2724:                    i = mcx_readarg(argc, argv, i, &(cfg->maxdetphoton), "int");
mmc_utils.c:2727:                    i = mcx_readarg(argc, argv, i, &(cfg->autopilot), "int");
mmc_utils.c:2732:                        cfg->compute = mcx_keylookup(argv[++i], computebackend);
mmc_utils.c:2734:                        i = mcx_readarg(argc, argv, i, &(cfg->compute), "int");
mmc_utils.c:2741:                        i = mcx_readarg(argc, argv, i, cfg->deviceid, "string");
mmc_utils.c:2744:                        i = mcx_readarg(argc, argv, i, &(cfg->gpuid), "int");
mmc_utils.c:2745:                        memset(cfg->deviceid, '0', MAX_DEVICE);
mmc_utils.c:2747:                        if (cfg->gpuid > 0 && cfg->gpuid < MAX_DEVICE) {
mmc_utils.c:2748:                            cfg->deviceid[cfg->gpuid - 1] = '1';
mmc_utils.c:2755:                    i = mcx_readarg(argc, argv, i, cfg->workload, "floatlist");
mmc_utils.c:2758:                case '-':  /*additional verbose parameters*/
mmc_utils.c:2760:                        i = mcx_readarg(argc, argv, i, &(cfg->ismomentum), "bool");
mmc_utils.c:2762:                        if (cfg->ismomentum) {
mmc_utils.c:2763:                            cfg->issavedet = 1;
mmc_utils.c:2766:                        i = mcx_readarg(argc, argv, i, &(cfg->isatomic), "bool");
mmc_utils.c:2768:                        i = mcx_readarg(argc, argv, i, cfg->rootpath, "string");
mmc_utils.c:2770:                        cfg->jsonfile[0] = '-';
mmc_utils.c:2773:                            cfg->isdumpjson = 1;
mmc_utils.c:2775:                        } else if (i + 1 < argc && (isalpha((int)(argv[i + 1][0])) || argv[i + 1][0] == '-')) {
mmc_utils.c:2776:                            cfg->isdumpjson = 1;
mmc_utils.c:2777:                            memcpy(cfg->jsonfile, argv[i + 1], MIN(strlen(argv[i + 1]), MAX_PATH_LENGTH));
mmc_utils.c:2780:                            i = mcx_readarg(argc, argv, i, &(cfg->isdumpjson), "int");
mmc_utils.c:2786:                            if (idx == -1) {
mmc_utils.c:2787:                                MMC_ERROR(-1, "Unsupported bechmark.");
mmc_utils.c:2793:                            MMC_FPRINTF(cfg->flog, "Built-in benchmarks:\n");
mmc_utils.c:2795:                            for (i = 0; i < sizeof(benchname) / sizeof(char*) -1; i++) {
mmc_utils.c:2796:                                MMC_FPRINTF(cfg->flog, "\t%s\n", benchname[i]);
mmc_utils.c:2802:                        i = mcx_readarg(argc, argv, i, &(cfg->debugphoton), "int");
mmc_utils.c:2804:                        i = mcx_readarg(argc, argv, i, &(cfg->nbuffer), "int");
mmc_utils.c:2806:                        i = mcx_readarg(argc, argv, i, &(cfg->steps.x), "int");
mmc_utils.c:2807:                        cfg->steps.y = cfg->steps.x;
mmc_utils.c:2808:                        cfg->steps.z = cfg->steps.x;
mmc_utils.c:2810:                        MMC_FPRINTF(cfg->flog, "unknown verbose option: --%s\n", argv[i] + 2);
mmc_utils.c:2816:                    MMC_FPRINTF(cfg->flog, "option: %s\n", argv[i]);
mmc_utils.c:2817:                    MMC_ERROR(-1, "unsupported command line option");
mmc_utils.c:2825:    if (issavelog && cfg->session[0]) {
mmc_utils.c:2826:        sprintf(logfile, "%s.log", cfg->session);
mmc_utils.c:2827:        cfg->flog = fopen(logfile, "wt");
mmc_utils.c:2829:        if (cfg->flog == NULL) {
mmc_utils.c:2830:            cfg->flog = stdout;
mmc_utils.c:2831:            MMC_FPRINTF(cfg->flog, "unable to save to log file, will print from stdout\n");
mmc_utils.c:2835:    if (cfg->kernelfile[0] != '\0' && cfg->isgpuinfo != 2) {
mmc_utils.c:2836:        FILE* fp = fopen(cfg->kernelfile, "rb");
mmc_utils.c:2840:            mcx_error(-10, "the specified OpenCL kernel file does not exist!", __FILE__, __LINE__);
mmc_utils.c:2846:        if (cfg->clsource != (char*)mmc_core_cl) {
mmc_utils.c:2847:            free(cfg->clsource);
mmc_utils.c:2850:        cfg->clsource = (char*)malloc(srclen + 1);
mmc_utils.c:2852:        MMC_ASSERT((fread(cfg->clsource, srclen, 1, fp) == 1));
mmc_utils.c:2853:        cfg->clsource[srclen] = '\0';
mmc_utils.c:2857:    if ((cfg->outputtype == otJacobian || cfg->outputtype == otWL || cfg->outputtype == otWP) && cfg->seed != SEED_FROM_FILE) {
mmc_utils.c:2858:        MMC_ERROR(-1, "Jacobian output is only valid in the reply mode. Please give an mch file after '-E'.");
mmc_utils.c:2861:    if (cfg->isgpuinfo != 2) { /*print gpu info only*/
mmc_utils.c:2871:    if (cfg->isgpuinfo == 0) {
mmc_utils.c:2880:    if (cfg->outputformat == ofJNifti || cfg->outputformat == ofBJNifti) {
mmc_utils.c:2885:    if (cfg->rootpath[0]) {
mmc_utils.c:2886:        sprintf(fhistory, "%s%c%s.mch", cfg->rootpath, pathsep, cfg->session);
mmc_utils.c:2888:        sprintf(fhistory, "%s.mch", cfg->session);
mmc_utils.c:2898:        mcx_error(-2, "can not save data to disk", __FILE__, __LINE__);
mmc_utils.c:2901:    fwrite(&(cfg->his), sizeof(history), 1, fp);
mmc_utils.c:2902:    fwrite(ppath, sizeof(float), count * cfg->his.colcount, fp);
mmc_utils.c:2922:    MMC_FPRINTF(cfg->flog, S_YELLOW"\
mmc_utils.c:2924:#                     Mesh-based Monte Carlo (MMC) - OpenCL                   #\n\
mmc_utils.c:2925:#          Copyright (c) 2010-2020 Qianqian Fang <q.fang at neu.edu>          #\n\
mmc_utils.c:2931:#                Research funded by NIH/NIGMS grant R01-GM114365              #\n\
mmc_utils.c:2950: -f config     (--input)       read an input file in .inp or .json format\n\
mmc_utils.c:2953: -n [0.|float] (--photon)      total photon number, max allowed value is 2^32-1\n\
mmc_utils.c:2954: -b [0|1]      (--reflect)     1 do reflection at int&ext boundaries, 0 no ref.\n\
mmc_utils.c:2955: -U [1|0]      (--normalize)   1 to normalize the fluence to unitary,0 save raw\n\
mmc_utils.c:2956: -m [0|1]      (--mc)          0 use MCX-styled MC method, 1 use MCML style MC\n\
mmc_utils.c:2957: -C [1|0]      (--basisorder)  1 piece-wise-linear basis for fluence,0 constant\n\
mmc_utils.c:2958: -u [1.|float] (--unitinmm)    define the mesh data length unit in mm\n\
mmc_utils.c:2959: -E [1648335518|int|mch](--seed) set random-number-generator seed;\n\
mmc_utils.c:2963: -P [0|int]    (--replaydet)   replay only the detected photons from a given \n\
mmc_utils.c:2964:                               detector (det ID starts from 1), use with -E \n\
mmc_utils.c:2965: -M [%c|SG] (--method)      choose ray-tracing algorithm (only use 1 letter)\n\
mmc_utils.c:2966:                               P - Plucker-coordinate ray-tracing algorithm\n\
mmc_utils.c:2967:			       H - Havel's SSE4 ray-tracing algorithm\n\
mmc_utils.c:2968:			       B - partial Badouel's method (used by TIM-OS)\n\
mmc_utils.c:2969:			       S - branch-less Badouel's method with SSE\n\
mmc_utils.c:2970:			       G - dual-grid MMC (DMMC) with voxel data output\n\
mmc_utils.c:2971: -e [1e-6|float](--minenergy)  minimum energy level to trigger Russian roulette\n\
mmc_utils.c:2972: -V [0|1]      (--specular)    1 source located in the background,0 inside mesh\n\
mmc_utils.c:2973: -k [1|0]      (--voidtime)    when src is outside, 1 enables timer inside void\n\
mmc_utils.c:2976: -A [0|int]    (--autopilot)   auto thread config:1 enable;0 disable\n\
mmc_utils.c:2977: -c [opencl,sse,cuda](--compute) select compute backend (default to opencl)\n\
mmc_utils.c:2979: -G [0|int]    (--gpu)         specify which GPU to use, list GPU by -L; 0 auto\n\
mmc_utils.c:2981: -G '1101'     (--gpu)         using multiple devices (1 enable, 0 disable)\n\
mmc_utils.c:2982: -W '50,30,20' (--workload)    workload for active devices; normalized by sum\n\
mmc_utils.c:2983: --atomic [1|0]                1 use atomic operations, 0 use non-atomic ones\n\
mmc_utils.c:2986: -s sessionid  (--session)     a string used to tag all output file names\n\
mmc_utils.c:2987: -O [X|XFEJLP] (--outputtype)  X - output flux, F - fluence, E - energy density\n\
mmc_utils.c:2988:                               J - Jacobian, L - weighted path length, P -\n\
mmc_utils.c:2990: -d [0|1]      (--savedet)     1 to save photon info at detectors,0 not to save\n\
mmc_utils.c:2991: -H [1000000] (--maxdetphoton) max number of detected photons\n\
mmc_utils.c:2992: -S [1|0]      (--save2pt)     1 to save the fluence field, 0 do not save\n\
mmc_utils.c:2993: -x [0|1]      (--saveexit)    1 to save photon exit positions and directions\n\
mmc_utils.c:2994:                               setting -x to 1 also implies setting '-d' to 1\n\
mmc_utils.c:2995: -X [0|1]      (--saveref)     save diffuse reflectance/transmittance on the \n\
mmc_utils.c:3005: -q [0|1]      (--saveseed)    1 save RNG seeds of detected photons for replay\n\
mmc_utils.c:3006: -F format     (--outputformat)'ascii', 'bin' (in 'double'), 'mc2' (double) \n\
mmc_utils.c:3008:                               mc2 - MCX mc2 format (binary 32bit float)\n\
mmc_utils.c:3009:                               jnii - JNIfTI format (http://openjdata.org)\n\
mmc_utils.c:3010:                               bnii - Binary JNIfTI (http://openjdata.org)\n\
mmc_utils.c:3011:                               nii - NIfTI format\n\
mmc_utils.c:3012:                               hdr - Analyze 7.5 hdr/img format\n\
mmc_utils.c:3013:	the bnii/jnii formats support compression (-Z) and generate small files\n\
mmc_utils.c:3019: -Z [zlib|...] (--zip)         set compression method if -F jnii or --dumpjson\n\
mmc_utils.c:3028: --dumpjson [-,2,'file.json']  export all settings, including volume data using\n\
mmc_utils.c:3030:			       easy sharing; can be reused using -f\n\
mmc_utils.c:3031:			       if followed by nothing or '-', mcx will print\n\
mmc_utils.c:3034:			       after pre-processing; '--dumpjson 2' prints \n\
mmc_utils.c:3035:			       raw inputs before pre-processing\n\
mmc_utils.c:3038: -h            (--help)        print this message\n\
mmc_utils.c:3039: -v            (--version)     print MMC version information\n\
mmc_utils.c:3040: -l            (--log)         print messages to a log file instead\n\
mmc_utils.c:3041: -i 	       (--interactive) interactive mode\n\
mmc_utils.c:3044: -D [0|int]    (--debug)       print debug information (you can use an integer\n\
mmc_utils.c:3046: -D [''|MCBWDIOXATRPE]         1 M  photon movement info\n\
mmc_utils.c:3047:                               2 C  print ray-polygon testing details\n\
mmc_utils.c:3048:                               4 B  print Bary-centric coordinates\n\
mmc_utils.c:3060: --debugphoton [-1|int]        to print the debug info specified by -D only for\n\
mmc_utils.c:3064: --momentum     [0|1]          1 to save photon momentum transfer,0 not to save\n\
mmc_utils.c:3065: --gridsize     [1|float]      if -M G is used, this sets the grid size in mm\n\
mmc_utils.c:3068:       %s -n 1000000 -f input.json -s test -b 0 -D TP -G -1\n", exename,
mmc_rand_xorshift128p.c:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_rand_xorshift128p.c:5:**  \copyright Qianqian Fang, 2010-2021
mmc_rand_xorshift128p.c:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_rand_xorshift128p.c:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_rand_xorshift128p.c:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_rand_xorshift128p.c:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_rand_xorshift128p.c:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_rand_xorshift128p.c:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_rand_xorshift128p.c:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_rand_xorshift128p.c:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_rand_xorshift128p.c:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_rand_xorshift128p.c:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_rand_xorshift128p.c:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_rand_xorshift128p.c:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_rand_xorshift128p.c:35:\brief   A POSIX Random Number Generator for multi-threaded applications
mmc_rand_xorshift128p.c:68:    return s1.f[0] - 1.0f;
mmc_bench.h:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_bench.h:5:**  \copyright Qianqian Fang, 2010-2021
mmc_bench.h:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_bench.h:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing 
mmc_bench.h:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_bench.h:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_bench.h:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a> 
mmc_bench.h:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_bench.h:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_bench.h:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection 
mmc_bench.h:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_bench.h:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport 
mmc_bench.h:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_bench.h:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_bench.h:43:const char *benchname[]={"d-cube60","d-cube60b",""};
mmc_bench.h:48:	"ID":       "d-cube60",
mmc_bench.h:69:	"T1": 5.0e-09,
mmc_bench.h:70:	"Dt": 5.0e-09
mmc_bench.h:103:	"ID":       "d-cube60b",
mmc_bench.h:124:	"T1": 5.0e-09,
mmc_bench.h:125:	"Dt": 5.0e-09
mmc_rand_common.h:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_rand_common.h:5:**  \copyright Qianqian Fang, 2010-2021
mmc_rand_common.h:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_rand_common.h:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_rand_common.h:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_rand_common.h:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_rand_common.h:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_rand_common.h:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_rand_common.h:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_rand_common.h:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_rand_common.h:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_rand_common.h:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_rand_common.h:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_rand_common.h:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_rand_common.h:42:#define EPS        1e-6f
mmc_rand_common.h:47:    return -logf(rand_uniform01(t) + EPS);
mmc_rand_common.h:116:    res = ((logval[0].f[pos] != logval[0].f[pos]) ? LOG_RNG_MAX : (-logval[0].f[pos]));
mingw64/include/ieee754.h:17:   02111-1307 USA.  */
mingw64/include/ieee754.h:32:    /* This is the IEEE 754 single-precision format.  */
mingw64/include/ieee754.h:72:    /* This is the IEEE 754 double-precision format.  */
mingw64/include/ieee754.h:134:    /* This is the IEEE 854 double-extended-precision format.  */
mingw64/include/ieee754.h:161:    /* This is for NaNs in the IEEE 854 double-extended-precision format.  */
mingw64/include/CL/cl_d3d11.h:2: * Copyright (c) 2008-2015 The Khronos Group Inc.
mingw64/include/CL/cl_d3d11.h:52:#define CL_INVALID_D3D11_DEVICE_KHR                  -1006
mingw64/include/CL/cl_d3d11.h:53:#define CL_INVALID_D3D11_RESOURCE_KHR                -1007
mingw64/include/CL/cl_d3d11.h:54:#define CL_D3D11_RESOURCE_ALREADY_ACQUIRED_KHR       -1008
mingw64/include/CL/cl_d3d11.h:55:#define CL_D3D11_RESOURCE_NOT_ACQUIRED_KHR           -1009
mingw64/include/CL/cl_ext.h:2: * Copyright (c) 2008-2015 The Khronos Group Inc.
mingw64/include/CL/cl_ext.h:48:/* cl_khr_fp16 extension - no extension #define since it has no functions  */
mingw64/include/CL/cl_ext.h:110:#define CL_PLATFORM_NOT_FOUND_KHR                   -1001
mingw64/include/CL/cl_ext.h:127: * Both the sampler and sampler-less read_image built-in functions are supported for 2D images
mingw64/include/CL/cl_ext.h:128: * and 2D images created from a buffer.  Similarly, the write_image built-ins are also supported
mingw64/include/CL/cl_ext.h:172:/* cl_nv_device_attribute_query extension - no extension #define since it has no functions */
mingw64/include/CL/cl_ext.h:239:    #define CL_DEVICE_PARTITION_FAILED_EXT              -1057
mingw64/include/CL/cl_ext.h:240:    #define CL_INVALID_PARTITION_COUNT_EXT              -1058
mingw64/include/CL/cl_ext.h:241:    #define CL_INVALID_PARTITION_NAME_EXT               -1059
mingw64/include/CL/cl_ext.h:254:    #define CL_PARTITION_BY_NAMES_LIST_END_EXT          ((cl_device_partition_property_ext) 0 - 1)
mingw64/include/CL/cl_dx9_media_sharing_intel.h:2: * Copyright (c) 2008-2016 The Khronos Group Inc.
mingw64/include/CL/cl_dx9_media_sharing_intel.h:30:Copyright (c) 2013-2016 Intel Corporation All Rights Reserved.
mingw64/include/CL/cl_dx9_media_sharing_intel.h:76:#define CL_INVALID_DX9_DEVICE_INTEL                   -1010
mingw64/include/CL/cl_dx9_media_sharing_intel.h:77:#define CL_INVALID_DX9_RESOURCE_INTEL                 -1011
mingw64/include/CL/cl_dx9_media_sharing_intel.h:78:#define CL_DX9_RESOURCE_ALREADY_ACQUIRED_INTEL        -1012
mingw64/include/CL/cl_dx9_media_sharing_intel.h:79:#define CL_DX9_RESOURCE_NOT_ACQUIRED_INTEL            -1013
mingw64/include/CL/cl_egl.h:2: * Copyright (c) 2008-2015 The Khronos Group Inc.
mingw64/include/CL/cl_egl.h:49:#define CL_INVALID_EGL_OBJECT_KHR             -1093
mingw64/include/CL/cl_egl.h:50:#define CL_EGL_RESOURCE_NOT_ACQUIRED_KHR      -1092
mingw64/include/CL/cl_dx9_media_sharing.h:2: * Copyright (c) 2008-2015 The Khronos Group Inc.
mingw64/include/CL/cl_dx9_media_sharing.h:61:#define CL_INVALID_DX9_MEDIA_ADAPTER_KHR                -1010
mingw64/include/CL/cl_dx9_media_sharing.h:62:#define CL_INVALID_DX9_MEDIA_SURFACE_KHR                -1011
mingw64/include/CL/cl_dx9_media_sharing.h:63:#define CL_DX9_MEDIA_SURFACE_ALREADY_ACQUIRED_KHR       -1012
mingw64/include/CL/cl_dx9_media_sharing.h:64:#define CL_DX9_MEDIA_SURFACE_NOT_ACQUIRED_KHR           -1013
mingw64/include/CL/cl_platform.h:2: * Copyright (c) 2008-2015 The Khronos Group Inc.
mingw64/include/CL/cl_platform.h:173:#define CL_SCHAR_MIN        (-127-1)
mingw64/include/CL/cl_platform.h:178:#define CL_SHRT_MIN         (-32767-1)
mingw64/include/CL/cl_platform.h:181:#define CL_INT_MIN          (-2147483647-1)
mingw64/include/CL/cl_platform.h:184:#define CL_LONG_MIN         ((cl_long) -0x7FFFFFFFFFFFFFFFLL - 1LL)
mingw64/include/CL/cl_platform.h:191:#define CL_FLT_MIN_10_EXP   -37
mingw64/include/CL/cl_platform.h:192:#define CL_FLT_MIN_EXP      -125
mingw64/include/CL/cl_platform.h:195:#define CL_FLT_MIN          1.175494350822287507969e-38f
mingw64/include/CL/cl_platform.h:196:#define CL_FLT_EPSILON      1.1920928955078125e-7f
mingw64/include/CL/cl_platform.h:202:#define CL_HALF_MIN_10_EXP   -4
mingw64/include/CL/cl_platform.h:203:#define CL_HALF_MIN_EXP      -13
mingw64/include/CL/cl_platform.h:206:#define CL_HALF_MIN          6.103515625e-05f
mingw64/include/CL/cl_platform.h:207:#define CL_HALF_EPSILON      9.765625e-04f
mingw64/include/CL/cl_platform.h:213:#define CL_DBL_MIN_10_EXP   -307
mingw64/include/CL/cl_platform.h:214:#define CL_DBL_MIN_EXP      -1021
mingw64/include/CL/cl_platform.h:217:#define CL_DBL_MIN          2.225073858507201383090e-308
mingw64/include/CL/cl_platform.h:218:#define CL_DBL_EPSILON      2.220446049250313080847e-16
mingw64/include/CL/cl_platform.h:248:#define CL_NAN              (CL_INFINITY - CL_INFINITY)
mingw64/include/CL/cl_platform.h:275:#define CL_SCHAR_MIN        (-127-1)
mingw64/include/CL/cl_platform.h:280:#define CL_SHRT_MIN         (-32767-1)
mingw64/include/CL/cl_platform.h:283:#define CL_INT_MIN          (-2147483647-1)
mingw64/include/CL/cl_platform.h:286:#define CL_LONG_MIN         ((cl_long) -0x7FFFFFFFFFFFFFFFLL - 1LL)
mingw64/include/CL/cl_platform.h:293:#define CL_FLT_MIN_10_EXP   -37
mingw64/include/CL/cl_platform.h:294:#define CL_FLT_MIN_EXP      -125
mingw64/include/CL/cl_platform.h:297:#define CL_FLT_MIN          1.175494350822287507969e-38f
mingw64/include/CL/cl_platform.h:298:#define CL_FLT_EPSILON      1.1920928955078125e-7f
mingw64/include/CL/cl_platform.h:304:#define CL_HALF_MIN_10_EXP   -4
mingw64/include/CL/cl_platform.h:305:#define CL_HALF_MIN_EXP      -13
mingw64/include/CL/cl_platform.h:308:#define CL_HALF_MIN          6.103515625e-05f
mingw64/include/CL/cl_platform.h:309:#define CL_HALF_EPSILON      9.765625e-04f
mingw64/include/CL/cl_platform.h:315:#define CL_DBL_MIN_10_EXP   -307
mingw64/include/CL/cl_platform.h:316:#define CL_DBL_MIN_EXP      -1021
mingw64/include/CL/cl_platform.h:319:#define CL_DBL_MIN          2.225073858507201383090e-308
mingw64/include/CL/cl_platform.h:320:#define CL_DBL_EPSILON      2.220446049250313080847e-16
mingw64/include/CL/cl_platform.h:378: *          a 16 byte boundary (calculated as 4 * the natural 4-byte 
mingw64/include/CL/cl_platform.h:383: *          the start of the struct must itself be 16-byte aligned. 
mingw64/include/CL/cl_platform.h:538:    /* http://msdn.microsoft.com/en-us/library/373ak2y1%28VS.71%29.aspx                                                 */
mingw64/include/CL/cl_platform.h:557:/* ---- cl_charn ---- */
mingw64/include/CL/cl_platform.h:632:/* ---- cl_ucharn ---- */
mingw64/include/CL/cl_platform.h:707:/* ---- cl_shortn ---- */
mingw64/include/CL/cl_platform.h:782:/* ---- cl_ushortn ---- */
mingw64/include/CL/cl_platform.h:857:/* ---- cl_halfn ---- */
mingw64/include/CL/cl_platform.h:931:/* ---- cl_intn ---- */
mingw64/include/CL/cl_platform.h:1006:/* ---- cl_uintn ---- */
mingw64/include/CL/cl_platform.h:1080:/* ---- cl_longn ---- */
mingw64/include/CL/cl_platform.h:1155:/* ---- cl_ulongn ---- */
mingw64/include/CL/cl_platform.h:1230:/* --- cl_floatn ---- */
mingw64/include/CL/cl_platform.h:1305:/* --- cl_doublen ---- */
mingw64/include/CL/cl_va_api_media_sharing_intel.h:2: * Copyright (c) 2008-2016 The Khronos Group Inc.
mingw64/include/CL/cl_va_api_media_sharing_intel.h:30:Copyright (c) 2013-2016 Intel Corporation All Rights Reserved.
mingw64/include/CL/cl_va_api_media_sharing_intel.h:71:#define CL_INVALID_VA_API_MEDIA_ADAPTER_INTEL               -1098
mingw64/include/CL/cl_va_api_media_sharing_intel.h:72:#define CL_INVALID_VA_API_MEDIA_SURFACE_INTEL               -1099
mingw64/include/CL/cl_va_api_media_sharing_intel.h:73:#define CL_VA_API_MEDIA_SURFACE_ALREADY_ACQUIRED_INTEL      -1100
mingw64/include/CL/cl_va_api_media_sharing_intel.h:74:#define CL_VA_API_MEDIA_SURFACE_NOT_ACQUIRED_INTEL          -1101
mingw64/include/CL/cl_gl_ext.h:2: * Copyright (c) 2008-2015 The Khronos Group Inc.
mingw64/include/CL/cl_gl_ext.h:31:/* cl_gl_ext.h contains vendor (non-KHR) OpenCL extensions which have           */
mingw64/include/CL/cl_d3d10.h:2: * Copyright (c) 2008-2015 The Khronos Group Inc.
mingw64/include/CL/cl_d3d10.h:52:#define CL_INVALID_D3D10_DEVICE_KHR                  -1002
mingw64/include/CL/cl_d3d10.h:53:#define CL_INVALID_D3D10_RESOURCE_KHR                -1003
mingw64/include/CL/cl_d3d10.h:54:#define CL_D3D10_RESOURCE_ALREADY_ACQUIRED_KHR       -1004
mingw64/include/CL/cl_d3d10.h:55:#define CL_D3D10_RESOURCE_NOT_ACQUIRED_KHR           -1005
mingw64/include/CL/cl.h:2: * Copyright (c) 2008-2015 The Khronos Group Inc.
mingw64/include/CL/cl.h:119:    __extension__   /* Prevents warnings about anonymous union in -pedantic builds */
mingw64/include/CL/cl.h:137:#define CL_DEVICE_NOT_FOUND                         -1
mingw64/include/CL/cl.h:138:#define CL_DEVICE_NOT_AVAILABLE                     -2
mingw64/include/CL/cl.h:139:#define CL_COMPILER_NOT_AVAILABLE                   -3
mingw64/include/CL/cl.h:140:#define CL_MEM_OBJECT_ALLOCATION_FAILURE            -4
mingw64/include/CL/cl.h:141:#define CL_OUT_OF_RESOURCES                         -5
mingw64/include/CL/cl.h:142:#define CL_OUT_OF_HOST_MEMORY                       -6
mingw64/include/CL/cl.h:143:#define CL_PROFILING_INFO_NOT_AVAILABLE             -7
mingw64/include/CL/cl.h:144:#define CL_MEM_COPY_OVERLAP                         -8
mingw64/include/CL/cl.h:145:#define CL_IMAGE_FORMAT_MISMATCH                    -9
mingw64/include/CL/cl.h:146:#define CL_IMAGE_FORMAT_NOT_SUPPORTED               -10
mingw64/include/CL/cl.h:147:#define CL_BUILD_PROGRAM_FAILURE                    -11
mingw64/include/CL/cl.h:148:#define CL_MAP_FAILURE                              -12
mingw64/include/CL/cl.h:149:#define CL_MISALIGNED_SUB_BUFFER_OFFSET             -13
mingw64/include/CL/cl.h:150:#define CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST -14
mingw64/include/CL/cl.h:151:#define CL_COMPILE_PROGRAM_FAILURE                  -15
mingw64/include/CL/cl.h:152:#define CL_LINKER_NOT_AVAILABLE                     -16
mingw64/include/CL/cl.h:153:#define CL_LINK_PROGRAM_FAILURE                     -17
mingw64/include/CL/cl.h:154:#define CL_DEVICE_PARTITION_FAILED                  -18
mingw64/include/CL/cl.h:155:#define CL_KERNEL_ARG_INFO_NOT_AVAILABLE            -19
mingw64/include/CL/cl.h:157:#define CL_INVALID_VALUE                            -30
mingw64/include/CL/cl.h:158:#define CL_INVALID_DEVICE_TYPE                      -31
mingw64/include/CL/cl.h:159:#define CL_INVALID_PLATFORM                         -32
mingw64/include/CL/cl.h:160:#define CL_INVALID_DEVICE                           -33
mingw64/include/CL/cl.h:161:#define CL_INVALID_CONTEXT                          -34
mingw64/include/CL/cl.h:162:#define CL_INVALID_QUEUE_PROPERTIES                 -35
mingw64/include/CL/cl.h:163:#define CL_INVALID_COMMAND_QUEUE                    -36
mingw64/include/CL/cl.h:164:#define CL_INVALID_HOST_PTR                         -37
mingw64/include/CL/cl.h:165:#define CL_INVALID_MEM_OBJECT                       -38
mingw64/include/CL/cl.h:166:#define CL_INVALID_IMAGE_FORMAT_DESCRIPTOR          -39
mingw64/include/CL/cl.h:167:#define CL_INVALID_IMAGE_SIZE                       -40
mingw64/include/CL/cl.h:168:#define CL_INVALID_SAMPLER                          -41
mingw64/include/CL/cl.h:169:#define CL_INVALID_BINARY                           -42
mingw64/include/CL/cl.h:170:#define CL_INVALID_BUILD_OPTIONS                    -43
mingw64/include/CL/cl.h:171:#define CL_INVALID_PROGRAM                          -44
mingw64/include/CL/cl.h:172:#define CL_INVALID_PROGRAM_EXECUTABLE               -45
mingw64/include/CL/cl.h:173:#define CL_INVALID_KERNEL_NAME                      -46
mingw64/include/CL/cl.h:174:#define CL_INVALID_KERNEL_DEFINITION                -47
mingw64/include/CL/cl.h:175:#define CL_INVALID_KERNEL                           -48
mingw64/include/CL/cl.h:176:#define CL_INVALID_ARG_INDEX                        -49
mingw64/include/CL/cl.h:177:#define CL_INVALID_ARG_VALUE                        -50
mingw64/include/CL/cl.h:178:#define CL_INVALID_ARG_SIZE                         -51
mingw64/include/CL/cl.h:179:#define CL_INVALID_KERNEL_ARGS                      -52
mingw64/include/CL/cl.h:180:#define CL_INVALID_WORK_DIMENSION                   -53
mingw64/include/CL/cl.h:181:#define CL_INVALID_WORK_GROUP_SIZE                  -54
mingw64/include/CL/cl.h:182:#define CL_INVALID_WORK_ITEM_SIZE                   -55
mingw64/include/CL/cl.h:183:#define CL_INVALID_GLOBAL_OFFSET                    -56
mingw64/include/CL/cl.h:184:#define CL_INVALID_EVENT_WAIT_LIST                  -57
mingw64/include/CL/cl.h:185:#define CL_INVALID_EVENT                            -58
mingw64/include/CL/cl.h:186:#define CL_INVALID_OPERATION                        -59
mingw64/include/CL/cl.h:187:#define CL_INVALID_GL_OBJECT                        -60
mingw64/include/CL/cl.h:188:#define CL_INVALID_BUFFER_SIZE                      -61
mingw64/include/CL/cl.h:189:#define CL_INVALID_MIP_LEVEL                        -62
mingw64/include/CL/cl.h:190:#define CL_INVALID_GLOBAL_WORK_SIZE                 -63
mingw64/include/CL/cl.h:191:#define CL_INVALID_PROPERTY                         -64
mingw64/include/CL/cl.h:192:#define CL_INVALID_IMAGE_DESCRIPTOR                 -65
mingw64/include/CL/cl.h:193:#define CL_INVALID_COMPILER_OPTIONS                 -66
mingw64/include/CL/cl.h:194:#define CL_INVALID_LINKER_OPTIONS                   -67
mingw64/include/CL/cl.h:195:#define CL_INVALID_DEVICE_PARTITION_COUNT           -68
mingw64/include/CL/cl.h:196:#define CL_INVALID_PIPE_SIZE                        -69
mingw64/include/CL/cl.h:197:#define CL_INVALID_DEVICE_QUEUE                     -70
mingw64/include/CL/cl.h:218:/* cl_device_type - bitfield */
mingw64/include/CL/cl.h:320:/* cl_device_fp_config - bitfield */
mingw64/include/CL/cl.h:339:/* cl_device_exec_capabilities - bitfield */
mingw64/include/CL/cl.h:343:/* cl_command_queue_properties - bitfield */
mingw64/include/CL/cl.h:386:/* cl_mem_flags and cl_svm_mem_flags - bitfield */
mingw64/include/CL/cl.h:401:/* cl_mem_migration_flags - bitfield */
mingw64/include/CL/cl.h:505:/* cl_map_flags - bitfield */
mingw64/include/CL/cl.h:536:#define CL_BUILD_NONE                               -1
mingw64/include/CL/cl.h:537:#define CL_BUILD_ERROR                              -2
mingw64/include/CL/cl.h:538:#define CL_BUILD_IN_PROGRESS                        -3
mingw64/include/CL/cl_gl.h:2: * Copyright (c) 2008-2015 The Khronos Group Inc.
mingw64/include/CL/cl_gl.h:47:/* cl_gl_object_type = 0x2000 - 0x200F enum values are currently taken           */
mingw64/include/CL/cl_gl.h:136:#define CL_INVALID_GL_SHAREGROUP_REFERENCE_KHR  -1000
mingw64/include/CL/cl_ext_intel.h:2: * Copyright (c) 2008-2017 The Khronos Group Inc.
mingw64/include/CL/cl_ext_intel.h:30:Copyright (c) 2013-2017 Intel Corporation All Rights Reserved.
mingw64/include/CL/cl_ext_intel.h:82:#define CL_PARTITION_BY_NAMES_LIST_END_INTEL        -1
mingw64/include/CL/cl_ext_intel.h:106:#define CL_INVALID_ACCELERATOR_INTEL                              -1094
mingw64/include/CL/cl_ext_intel.h:107:#define CL_INVALID_ACCELERATOR_TYPE_INTEL                         -1095
mingw64/include/CL/cl_ext_intel.h:108:#define CL_INVALID_ACCELERATOR_DESCRIPTOR_INTEL                   -1096
mingw64/include/CL/cl_ext_intel.h:109:#define CL_ACCELERATOR_TYPE_NOT_SUPPORTED_INTEL                   -1097
mingw64/include/CL/opencl.h:2: * Copyright (c) 2008-2015 The Khronos Group Inc.
mingw64/include/sys/termios.h:72:#define FIONBIO     0x8004667e		 /* set/clear non-blocking i/o */
mingw64/include/sys/termios.h:295:	__newti->c_iflag = ((struct __oldtermios *)ti)->c_iflag; \
mingw64/include/sys/termios.h:296:	__newti->c_oflag = ((struct __oldtermios *)ti)->c_oflag; \
mingw64/include/sys/termios.h:297:	__newti->c_cflag = ((struct __oldtermios *)ti)->c_cflag; \
mingw64/include/sys/termios.h:298:	__newti->c_lflag = ((struct __oldtermios *)ti)->c_lflag; \
mingw64/include/sys/termios.h:299:	__newti->c_line = ((struct __oldtermios *)ti)->c_line; \
mingw64/include/sys/termios.h:300:	__newti->c_ispeed = ((struct __oldtermios *)ti)->c_ispeed; \
mingw64/include/sys/termios.h:301:	__newti->c_ospeed = ((struct __oldtermios *)ti)->c_ospeed; \
mingw64/include/sys/termios.h:302:	memcpy (__newti->c_cc, ((struct __oldtermios *)ti)->c_cc, sizeof(__newti->c_cc)); \
mingw64/include/sys/termios.h:317:	((struct __oldtermios *)toti)->c_iflag = fromti->c_iflag; \
mingw64/include/sys/termios.h:318:	((struct __oldtermios *)toti)->c_oflag = fromti->c_oflag; \
mingw64/include/sys/termios.h:319:	((struct __oldtermios *)toti)->c_cflag = fromti->c_cflag; \
mingw64/include/sys/termios.h:320:	((struct __oldtermios *)toti)->c_lflag = fromti->c_lflag; \
mingw64/include/sys/termios.h:321:	((struct __oldtermios *)toti)->c_line = fromti->c_line; \
mingw64/include/sys/termios.h:322:	((struct __oldtermios *)toti)->c_ispeed = fromti->c_ispeed; \
mingw64/include/sys/termios.h:323:	((struct __oldtermios *)toti)->c_ospeed = fromti->c_ospeed; \
mingw64/include/sys/termios.h:324:	memcpy (((struct __oldtermios*)toti)->c_cc, fromti->c_cc, sizeof(fromti->c_cc)); \
mingw64/include/sys/termios.h:356:#define cfgetispeed(tp)		((tp)->c_ispeed)
mingw64/include/sys/termios.h:357:#define cfgetospeed(tp)		((tp)->c_ospeed)
mingw64/include/sys/ioctl.h:32:#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
mingw64/include/sys/ioctl.h:33:#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
mingw64/include/sys/ioctl.h:34:#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
mingw64/include/sys/ioctl.h:35:#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
mingw64/include/_ansi.h:1:/* Provide support for both ANSI and non-ANSI environments.  */
mingw64/include/_ansi.h:4:   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
mingw64/include/_ansi.h:58:  C99-compatible behaviour, or a non-GCC compiler (which we will
mingw64/include/_ansi.h:61:  'static inline', which c99 defines to mean more-or-less the same
mingw64/include/_ansi.h:64:/* We're using GCC, but without the new C99-compatible behaviour.  */
mingw64/include/_ansi.h:76:/* On non-GNU compilers and GCC prior to version 3.1 the compiler can't be
mmc_raytrace.h:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_raytrace.h:5:**  \copyright Qianqian Fang, 2010-2021
mmc_raytrace.h:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_raytrace.h:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_raytrace.h:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_raytrace.h:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_raytrace.h:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_raytrace.h:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_raytrace.h:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_raytrace.h:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_raytrace.h:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_raytrace.h:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_raytrace.h:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_raytrace.h:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_raytrace.h:35:\brief   Definition of the core ray-tracing functions
mmc_raytrace.h:45:#define FIX_PHOTON         1e-3f      /**< offset to the ray to avoid edge/vertex */
mmc_raytrace.h:63:    float photontimer;            /**< the total time-of-fly of the photon */
mmc_raytrace.h:78:    int roiidx;           /**< edge(0-5), node (0-4) or face (0-4) index in a local element with ROIs */
mmc_raytrace.h:79:    int refeid;           /**< reference element id that is used for face-based implicit MMC*/
mmc_raytrace.h:89:    float raytet;                 /**< total number of ray-tet tests */
mmc_raytrace.h:90:    float raytet0;                /**< total number of ray-tet tests outside of the object mesh */
mmc_raytrace.h:91:    float rtstep;                 /**< reciprocal of the movement step - obsolete */
mmc_raytrace.h:94:    int   reclen;                 /**< record (4-byte per record) number per detected photon */
mmc_raytrace.h:99:    double* kahanc0;              /**< temp variable to enable Kahan summation to reduce round-off error */
mmc_raytrace.h:100:    double* kahanc1;              /**< temp variable to enable Kahan summation to reduce round-off error */
incbin.h:11:           ".size " #symbol ", .-" #symbol "\n" \
incbin.h:13:           ".long .-" #symbol "\n" \
incbin.h:28:           ".size " #symbol ", .-" #symbol "\n" \
incbin.h:30:           ".long .-" #symbol "\n" \
incbin.h:41:           ".size " #symbol ", .-" #symbol "\n"); \
incbin.h:54:           ".long .-" #symbol "\n"); \
incbin.h:69:           ".long .-" #symbol "\n"); \
mmc_vector_types.h:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_vector_types.h:5:**  \copyright Qianqian Fang, 2010-2021
mmc_vector_types.h:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_vector_types.h:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_vector_types.h:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_vector_types.h:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_vector_types.h:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_vector_types.h:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_vector_types.h:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_vector_types.h:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_vector_types.h:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_vector_types.h:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_vector_types.h:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_vector_types.h:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
sse_math/sse_math.h:13:  This software is provided 'as-is', without any express or implied
sse_math/sse_math.h:60:/* declare some SSE constants -- why can't I figure a better way to do that? */
sse_math/sse_math.h:85:_PS_CONST(cephes_log_p0, 7.0376836292E-2);
sse_math/sse_math.h:86:_PS_CONST(cephes_log_p1, - 1.1514610310E-1);
sse_math/sse_math.h:87:_PS_CONST(cephes_log_p2, 1.1676998740E-1);
sse_math/sse_math.h:88:_PS_CONST(cephes_log_p3, - 1.2420140846E-1);
sse_math/sse_math.h:89:_PS_CONST(cephes_log_p4, + 1.4249322787E-1);
sse_math/sse_math.h:90:_PS_CONST(cephes_log_p5, - 1.6668057665E-1);
sse_math/sse_math.h:91:_PS_CONST(cephes_log_p6, + 2.0000714765E-1);
sse_math/sse_math.h:92:_PS_CONST(cephes_log_p7, - 2.4999993993E-1);
sse_math/sse_math.h:93:_PS_CONST(cephes_log_p8, + 3.3333331174E-1);
sse_math/sse_math.h:94:_PS_CONST(cephes_log_q1, -2.12194440e-4);
sse_math/sse_math.h:103:   Note that the bug on _mm_cmp* does occur only at -O0 optimization level
sse_math/sse_math.h:192:  /* now e=mm0:mm1 contain the really base-2 exponent */
sse_math/sse_math.h:206:       e -= 1;
sse_math/sse_math.h:207:       x = x + x - 1.0;
sse_math/sse_math.h:208:     } else { x = x - 1.0; }
sse_math/sse_math.h:255:_PS_CONST(minus_cephes_DP1, -0.78515625);
sse_math/sse_math.h:256:_PS_CONST(minus_cephes_DP2, -2.4187564849853515625e-4);
sse_math/sse_math.h:257:_PS_CONST(minus_cephes_DP3, -3.77489497744594108e-8);
sse_math/sse_math.h:258:_PS_CONST(sincof_p0, -1.9515295891E-4);
sse_math/sse_math.h:259:_PS_CONST(sincof_p1,  8.3321608736E-3);
sse_math/sse_math.h:260:_PS_CONST(sincof_p2, -1.6666654611E-1);
sse_math/sse_math.h:261:_PS_CONST(coscof_p0,  2.443315711809948E-005);
sse_math/sse_math.h:262:_PS_CONST(coscof_p1, -1.388731625493765E-003);
sse_math/sse_math.h:263:_PS_CONST(coscof_p2,  4.166664568298827E-002);
sse_math/sse_math.h:274:   -- it does not return garbage for arguments over 8192, though, but
sse_math/sse_math.h:277:   Note that it is such that sinf((float)M_PI) = 8.74e-8, which is the
sse_math/sse_math.h:292:   Since it is based on SSE intrinsics, it has to be compiled at -O2 to
sse_math/sse_math.h:370:     x = ((x - y * DP1) - y * DP2) - y * DP3; */
sse_math/sse_math.h:396:  _mm_empty(); /* good-bye mmx */
mmc_utils.h:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_utils.h:5:**  \copyright Qianqian Fang, 2010-2021
mmc_utils.h:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_utils.h:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_utils.h:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_utils.h:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_utils.h:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_utils.h:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_utils.h:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_utils.h:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_utils.h:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_utils.h:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_utils.h:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_utils.h:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_utils.h:45:#ifdef _OPENMP                      ///< use multi-threading for running simulation on multiple GPUs
mmc_utils.h:54:#define SEED_FROM_FILE      -999                         /**< special flag indicating to load seeds from history file */
mmc_utils.h:57:#define MMC_INFO            -99999
mmc_utils.h:118:For each optical medium, we use a 4-element structure to identify its optical
mmc_utils.h:173:    int maxmpthread;  /**< maximum thread number per multi-processor */
mmc_utils.h:185:    size_t nphoton;                /**<total simulated photon number, max: 2^64-1*/
mmc_utils.h:192:    int srctype;                   /**<src type: 0 - pencil beam, 1 - isotropic ... */
mmc_utils.h:203:    uint4 crop0;                   /**<sub-volume for cache*/
mmc_utils.h:209:    float sradius;                 /**<source region radius: if set to non-zero, accumulation \
mmc_utils.h:211:                                           normalization error when using non-atomic write*/
mmc_utils.h:214:    float4 detparam1;          /**<parameters set 1 for wide-field detector*/
mmc_utils.h:215:    float4 detparam2;          /**<parameters set 2 for wide-feild detector*/
mmc_utils.h:222:                           0 for wide-field detection pattern*/
mmc_utils.h:226:    char isrowmajor;               /**<1 for C-styled array in vol, 0 for matlab-styled array*/
mmc_utils.h:234:    char issave2pt;                /**<1 to save the 2-point distribution, 0 do not save*/
mmc_utils.h:240:    char method;                   /**<0-Plucker 1-Havel, 2-Badouel, 3-branchless Badouel*/
mmc_utils.h:241:    int implicit;              /**<1 for edge- or node-based implicit MMC, 2 for face-based implicit MMC*/
mmc_utils.h:242:    char basisorder;               /**<0 to use piece-wise-constant basis for fluence, 1, linear*/
mmc_utils.h:245:    int  mcmethod;                 /**<0 use MCX-styled MC (micro-Beer-Lambert law), 1 use MCML-styled MC (Albedo-Weight)*/
mmc_utils.h:249:    int isextdet;                  /**<if 1, there is external wide-field detector (marked by -2 in the mesh)*/
mmc_utils.h:259:    float* replaytime;             /**< pointer to the detected photon time-of-fly array */
mmc_utils.h:284:    char* shapedata;    /**<a pointer points to a string defining the JSON-formatted shape data*/
mmc_utils.h:344:        if((cfg)->debuglevel & (debugflag)) {\
mmc_utils.h:346:            fflush((cfg)->flog);\
Binary file libzmat.a matches
makefile_xorshift:6:PLATFORM = $(shell uname -s)        
makefile_xorshift:15:  EXTRALIB:=-static-libgcc -lgcc_eh
makefile_xorshift:21:USERCCFLAGS=-DUSE_OS_TIMER -DMMC_XORSHIFT
makefile_xorshift:23:DUMMY:=$(shell mkdir -p built/cjson)
Binary file .mmc_optix_utils.cpp.swo matches
buildmmc.m:15:%      'include': a string made of sequences of ' -I"/folder/path" ' that 
buildmmc.m:16:%            can be included for compilation (format similar to the -I
buildmmc.m:18:%      'lib': a string made of sequences of ' -L"/folder/path" ' and '
buildmmc.m:19:%           -llibrary' that can be added for linking (format similar to -L
buildmmc.m:20:%           and -l flags for gcc)
buildmmc.m:21:%      'filelist': a user-defined list of source file names
buildmmc.m:26:%    pre-install the MATLAB support for MinGW-w64 compiler 
buildmmc.m:27:%    https://www.mathworks.com/matlabcentral/fileexchange/52848-matlab-support-for-mingw-w64-c-c-compiler
buildmmc.m:35:%       pacman -Syu
buildmmc.m:36:%       pacman -S base-devel gcc git mingw-w64-x86_64-opencl-headers
buildmmc.m:43:%    "mex -setup C" in MATLAB and select "MinGW64 Compiler (C)". 
buildmmc.m:44:%  3.Once you select the MingW C compiler, you should run "mex -setup C++"
buildmmc.m:50:% This function is part of Mesh-based Monte Carlo (MMC) URL: http://mcx.space
buildmmc.m:65:cflags='-c -Wall -g -DMCX_EMBED_CL -fno-strict-aliasing -m64 -DMMC_USE_SSE -DHAVE_SSE2 -msse -msse2 -msse3 -mssse3 -msse4.1 -O3 -fopenmp  -DUSE_OS_TIMER -DUSE_OPENCL';
buildmmc.m:77:    linkflags='$LINKLIBS -fopenmp -lstdc++ -static';
buildmmc.m:78:    cflags=[cflags ' -I./mingw64/include -I"$MINGWROOT/opt/include"'];
buildmmc.m:82:    linkflags='\$CLIBS -fopenmp -static-libgcc -static-libstdc++';
buildmmc.m:83:    cflags=[cflags ' -fPIC '];
buildmmc.m:84:    linkflags=[linkflags ' -lOpenCL '];
buildmmc.m:93:        disp(sprintf('mex OBJEXT=.o %s=''%s'' -c ''%s'' ',flag,cflags,filelist{i}));
buildmmc.m:94:        eval(sprintf('mex OBJEXT=.o %s=''%s'' -c ''%s'' ',flag,cflags,filelist{i}));
buildmmc.m:100:    fprintf(1,  'mex %s -output %s -outdir ../%slab %s=''%s''\n',strjoin({fn.name}),pname,pname,linkvar,linkflags);
buildmmc.m:101:    eval(sprintf('mex %s -output %s -outdir ../%slab %s=''%s'' ',strjoin({fn.name}),pname,pname,linkvar,linkflags));
buildmmc.m:105:        cmd=sprintf('mex %s -c ''%s'' ',cflags,filelist{i});
buildmmc.m:111:    cmd=sprintf('mex %s -o ../%slab/%s %s ',strjoin({fn.name}),pname,pname,linkflags);
mmc_rand_posix.h:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_rand_posix.h:5:**  \copyright Qianqian Fang, 2010-2021
mmc_rand_posix.h:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_rand_posix.h:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_rand_posix.h:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_rand_posix.h:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_rand_posix.h:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_rand_posix.h:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_rand_posix.h:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_rand_posix.h:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_rand_posix.h:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_rand_posix.h:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_rand_posix.h:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_rand_posix.h:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_rand_posix.h:35:\brief   An interface to use a 48bit multi-threaded GNU RNG
mmc_rand_posix.h:45:#define MCX_RNG_NAME       "POSIX Multi-threaded RNG"
mmc_rand_drand48.h:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_rand_drand48.h:5:**  \copyright Qianqian Fang, 2010-2021
mmc_rand_drand48.h:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_rand_drand48.h:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_rand_drand48.h:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_rand_drand48.h:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_rand_drand48.h:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_rand_drand48.h:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_rand_drand48.h:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_rand_drand48.h:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_rand_drand48.h:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_rand_drand48.h:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_rand_drand48.h:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_rand_drand48.h:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_rand_drand48.h:80:/* Global state for non-reentrant functions. */
Binary file bin/mmc matches
mmc_mesh.h:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_mesh.h:5:**  \copyright Qianqian Fang, 2010-2021
mmc_mesh.h:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_mesh.h:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_mesh.h:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_mesh.h:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_mesh.h:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_mesh.h:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_mesh.h:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_mesh.h:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_mesh.h:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_mesh.h:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_mesh.h:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_mesh.h:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_mesh.h:70:#define EPS        1e-6f
mmc_mesh.h:73:#define R_C0       3.335640951981520e-12f  //1/C0 in s/mm
mmc_mesh.h:74:#define DELTA_MUA  1e-4f
mmc_mesh.h:106:    int*  type;            /**< element-based media index */
mmc_mesh.h:110:    double* weight;        /**< volumetric fluence for all nodes at all time-gates */
mmc_mesh.h:114:    float4 nmin;           /**< lower-corner of the mesh bounding box */
mmc_mesh.h:115:    float4 nmax;           /**< upper-corner of the mesh bounding box */
mmc_mesh.h:126:\brief  Ray-tracer data structrure for pre-computed data
mmc_mesh.h:128:We define the precomputed data in a ray-tracer structure. For the case of
mmc_mesh.h:129:Plucker-based ray-tracing, this structure contains the displacement and
mmc_mesh.h:136:    char method;            /**< 1 for Plucker-based ray-tracing, 0 for Havel */
mmc_mesh.h:185:    res->x = a->x + b->x;
mmc_mesh.h:186:    res->y = a->y + b->y;
mmc_mesh.h:187:    res->z = a->z + b->z;
mmc_mesh.h:191:    res->x = b->x - a->x;
mmc_mesh.h:192:    res->y = b->y - a->y;
mmc_mesh.h:193:    res->z = b->z - a->z;
mmc_mesh.h:197:    res->x = sa * a->x;
mmc_mesh.h:198:    res->y = sa * a->y;
mmc_mesh.h:199:    res->z = sa * a->z;
mmc_mesh.h:203:    res->x = sb * b->x + sa * a->x;
mmc_mesh.h:204:    res->y = sb * b->y + sa * a->y;
mmc_mesh.h:205:    res->z = sb * b->z + sa * a->z;
mmc_mesh.h:209:    res->x = a->y * b->z - a->z * b->y;
mmc_mesh.h:210:    res->y = a->z * b->x - a->x * b->z;
mmc_mesh.h:211:    res->z = a->x * b->y - a->y * b->x;
mmc_mesh.h:225:    return a->x * b->x + a->y * b->y + a->z * b->z;
mmc_mesh.h:233:        na=_mm_load_ps(&a->x);
mmc_mesh.h:234:        nb=_mm_load_ps(&b->x);
mmc_mesh.h:245:        na=_mm_load_ps(&a->x);
mmc_mesh.h:246:        nb=_mm_load_ps(&b->x);
mmc_mesh.h:261:    return (p1->x - p0->x) * (p1->x - p0->x) + (p1->y - p0->y) * (p1->y - p0->y) + (p1->z - p0->z) * (p1->z - p0->z);
mmc_mesh.h:269:    return (p1[0] - p0[0]) * (p1[0] - p0[0]) + (p1[1] - p0[1]) * (p1[1] - p0[1]);
optix7.h:2:// Copyright 2018-2019 Ingo Wald                                            //
optix7.h:8://     http://www.apache.org/licenses/LICENSE-2.0                           //
makefile_sfmt:4:PLATFORM = $(shell uname -s)
makefile_sfmt:12:#  EXTRALIB:=-static-libgcc
makefile_sfmt:17:USERCCFLAGS=-DMMC_SFMT -DUSE_OS_TIMER -DMEXP=19937
makefile_sfmt:19:DUMMY:=$(shell mkdir -p built/SFMT built/cjson)
mmc_rand_xorshift128p.h:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_rand_xorshift128p.h:5:**  \copyright Qianqian Fang, 2010-2021
mmc_rand_xorshift128p.h:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_rand_xorshift128p.h:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_rand_xorshift128p.h:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_rand_xorshift128p.h:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_rand_xorshift128p.h:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_rand_xorshift128p.h:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_rand_xorshift128p.h:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_rand_xorshift128p.h:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_rand_xorshift128p.h:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_rand_xorshift128p.h:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_rand_xorshift128p.h:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_rand_xorshift128p.h:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_rand_xorshift128p.h:35:\brief   An interface to use the SFMT-19937 random number generator
mmclab.cpp:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmclab.cpp:5:**  \copyright Qianqian Fang, 2010-2021
mmclab.cpp:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmclab.cpp:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmclab.cpp:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmclab.cpp:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmclab.cpp:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmclab.cpp:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmclab.cpp:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmclab.cpp:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmclab.cpp:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmclab.cpp:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmclab.cpp:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmclab.cpp:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmclab.cpp:57:#define GET_1ST_FIELD(x,y)  if(strcmp(name,#y)==0) {double *val=mxGetPr(item);x->y=val[0];printf("mmc.%s=%g;\n",#y,(float)(x->y));}
mmclab.cpp:62://! Macro to read one 3-element vector member of cfg
mmclab.cpp:63:#define GET_VEC3_FIELD(u,v) else if(strcmp(name,#v)==0) {double *val=mxGetPr(item);u->v.x=val[0];u->v.y=val[1];u->v.z=val[2];\
mmclab.cpp:64:        printf("mmc.%s=[%g %g %g];\n",#v,(float)(u->v.x),(float)(u->v.y),(float)(u->v.z));}
mmclab.cpp:66://! Macro to read one 3- or 4-element vector member of cfg
mmclab.cpp:67:#define GET_VEC34_FIELD(u,v) else if(strcmp(name,#v)==0) {double *val=mxGetPr(item);u->v.x=val[0];u->v.y=val[1];u->v.z=val[2];if(mxGetNumberOfElements(item)==4) u->v.w=val[3];\
mmclab.cpp:68:        printf("mmc.%s=[%g %g %g %g];\n",#v,(float)(u->v.x),(float)(u->v.y),(float)(u->v.z),(float)(u->v.w));}
mmclab.cpp:70://! Macro to read one 4-element vector member of cfg
mmclab.cpp:71:#define GET_VEC4_FIELD(u,v) else if(strcmp(name,#v)==0) {double *val=mxGetPr(item);u->v.x=val[0];u->v.y=val[1];u->v.z=val[2];u->v.w=val[3];\
mmclab.cpp:72:        printf("mmc.%s=[%g %g %g %g];\n",#v,(float)(u->v.x),(float)(u->v.y),(float)(u->v.z),(float)(u->v.w));}
mmclab.cpp:76:#define ABS(a)    ((a)<0?-(a):(a))                        //! Macro to calculate the absolute value
mmclab.cpp:137:        shortcmd[MAX_SESSION_LENGTH - 1] = '\0';
mmclab.cpp:187:    printf("Launching MMCLAB - Mesh-based Monte Carlo for MATLAB & GNU Octave ...\n");
mmclab.cpp:200:     * The function can return 1-3 outputs (i.e. the LHS)
mmclab.cpp:270:            MMCDEBUG(&cfg, dlTime, (cfg.flog, "\tdone\t%d\nsimulating ... \n", dt - t0));
mmclab.cpp:329:            dt = GetTimeMillis() - dt;
mmclab.cpp:341:            MMCDEBUG(&cfg, dlTime, (cfg.flog, "\tdone\t%d\n", GetTimeMillis() - t0));
mmclab.cpp:446: * it can handle single scalar inputs, short vectors (3-4 elem), strings and arrays.
mmclab.cpp:462:    if (strcmp(name, "nphoton") == 0 && cfg->photonseed != NULL) {
mmclab.cpp:466:    cfg->flog = stderr;
mmclab.cpp:503:        cfg->e0 = val[0];
mmclab.cpp:504:        printf("mmc.e0=%d;\n", cfg->e0);
mmclab.cpp:513:        mesh->nn = arraydim[0];
mmclab.cpp:515:        if (mesh->node) {
mmclab.cpp:516:            free(mesh->node);
mmclab.cpp:519:        mesh->node = (MMCfloat3*)calloc(sizeof(MMCfloat3), mesh->nn);
mmclab.cpp:520:        mesh->fnode = (float3*)calloc(sizeof(float3), mesh->nn);
mmclab.cpp:523:            for (i = 0; i < mesh->nn; i++) {
mmclab.cpp:524:                ((float*)(&mesh->node[i]))[j] = val[j * mesh->nn + i];
mmclab.cpp:525:                ((float*)(&mesh->fnode[i]))[j] = val[j * mesh->nn + i];
mmclab.cpp:528:        printf("mmc.nn=%d;\n", mesh->nn);
mmclab.cpp:537:        mesh->ne = arraydim[0];
mmclab.cpp:538:        mesh->elemlen = arraydim[1];
mmclab.cpp:540:        if (mesh->elem) {
mmclab.cpp:541:            free(mesh->elem);
mmclab.cpp:544:        mesh->elem = (int*)calloc(sizeof(int) * arraydim[1], mesh->ne);
mmclab.cpp:546:        for (j = 0; j < mesh->elemlen; j++)
mmclab.cpp:547:            for (i = 0; i < mesh->ne; i++) {
mmclab.cpp:548:                mesh->elem[i * mesh->elemlen + j] = val[j * mesh->ne + i];
mmclab.cpp:551:        printf("mmc.elem=[%d,%d];\n", mesh->ne, mesh->elemlen);
mmclab.cpp:560:        mesh->nn = MAX(arraydim[0], arraydim[1]);
mmclab.cpp:562:        if (mesh->noderoi) {
mmclab.cpp:563:            free(mesh->noderoi);
mmclab.cpp:566:        mesh->noderoi = (float*)malloc(sizeof(float) * mesh->nn);
mmclab.cpp:568:        for (i = 0; i < mesh->nn; i++) {
mmclab.cpp:569:            mesh->noderoi[i] = val[i];
mmclab.cpp:572:        cfg->implicit = 1;
mmclab.cpp:573:        printf("mmc.noderoi=%d;\n", mesh->nn);
mmclab.cpp:582:        mesh->ne = arraydim[0];
mmclab.cpp:584:        if (mesh->edgeroi) {
mmclab.cpp:585:            free(mesh->edgeroi);
mmclab.cpp:588:        mesh->edgeroi = (float*)calloc(sizeof(float) * arraydim[1], mesh->ne);
mmclab.cpp:591:            for (i = 0; i < mesh->ne; i++) {
mmclab.cpp:592:                mesh->edgeroi[i * 6 + j] = val[j * mesh->ne + i];
mmclab.cpp:595:        cfg->implicit = 1;
mmclab.cpp:596:        printf("mmc.edgeroi=[%d,%d];\n", mesh->ne, 6);
mmclab.cpp:605:        mesh->ne = arraydim[0];
mmclab.cpp:607:        if (mesh->faceroi) {
mmclab.cpp:608:            free(mesh->faceroi);
mmclab.cpp:611:        mesh->faceroi = (float*)calloc(sizeof(float) * arraydim[1], mesh->ne);
mmclab.cpp:614:            for (i = 0; i < mesh->ne; i++) {
mmclab.cpp:615:                mesh->faceroi[i * 4 + j] = val[j * mesh->ne + i];
mmclab.cpp:618:        cfg->implicit = 2;
mmclab.cpp:619:        printf("mmc.faceroi=[%d,%d];\n", mesh->ne, 4);
mmclab.cpp:628:        mesh->ne = MAX(arraydim[0], arraydim[1]);
mmclab.cpp:630:        if (mesh->type) {
mmclab.cpp:631:            free(mesh->type);
mmclab.cpp:634:        mesh->type = (int*)malloc(sizeof(int ) * mesh->ne);
mmclab.cpp:636:        for (i = 0; i < mesh->ne; i++) {
mmclab.cpp:637:            mesh->type[i] = val[i];
mmclab.cpp:640:        printf("mmc.ne=%d;\n", mesh->ne);
mmclab.cpp:649:        mesh->ne = arraydim[0];
mmclab.cpp:650:        mesh->elemlen = arraydim[1];
mmclab.cpp:652:        if (mesh->facenb) {
mmclab.cpp:653:            free(mesh->facenb);
mmclab.cpp:656:        mesh->facenb = (int*)malloc(sizeof(int) * arraydim[1] * mesh->ne);
mmclab.cpp:659:            for (i = 0; i < mesh->ne; i++) {
mmclab.cpp:660:                mesh->facenb[i * arraydim[1] + j] = val[j * mesh->ne + i];
mmclab.cpp:663:        printf("mmc.facenb=[%d,%d];\n", mesh->ne, mesh->elemlen);
mmclab.cpp:672:        mesh->ne = MAX(arraydim[0], arraydim[1]);
mmclab.cpp:674:        if (mesh->evol) {
mmclab.cpp:675:            free(mesh->evol);
mmclab.cpp:678:        mesh->evol = (float*)malloc(sizeof(float) * mesh->ne);
mmclab.cpp:680:        for (i = 0; i < mesh->ne; i++) {
mmclab.cpp:681:            mesh->evol[i] = val[i];
mmclab.cpp:684:        printf("mmc.evol=%d;\n", mesh->ne);
mmclab.cpp:693:        cfg->detnum = arraydim[0];
mmclab.cpp:695:        if (cfg->detpos) {
mmclab.cpp:696:            free(cfg->detpos);
mmclab.cpp:699:        cfg->detpos = (float4*)malloc(cfg->detnum * sizeof(float4));
mmclab.cpp:702:            for (i = 0; i < cfg->detnum; i++) {
mmclab.cpp:703:                ((float*)(&cfg->detpos[i]))[j] = val[j * cfg->detnum + i];
mmclab.cpp:706:        printf("mmc.detnum=%d;\n", cfg->detnum);
mmclab.cpp:715:        mesh->prop = arraydim[0] - 1;
mmclab.cpp:717:        if (mesh->med) {
mmclab.cpp:718:            free(mesh->med);
mmclab.cpp:721:        if (mesh->atte) {
mmclab.cpp:722:            free(mesh->atte);
mmclab.cpp:725:        mesh->med = (medium*)calloc(sizeof(medium), mesh->prop + 1);
mmclab.cpp:726:        mesh->atte = (float*)calloc(sizeof(float), mesh->prop + 1);
mmclab.cpp:729:            for (i = 0; i <= mesh->prop; i++) {
mmclab.cpp:730:                ((float*)(&mesh->med[i]))[j] = val[j * (mesh->prop + 1) + i];
mmclab.cpp:733:        cfg->his.maxmedia = mesh->prop;
mmclab.cpp:734:        printf("mmc.prop=%d;\n", mesh->prop);
mmclab.cpp:740:            MEXERROR("the 'debuglevel' field must be a non-empty string");
mmclab.cpp:753:        cfg->debuglevel = mcx_parsedebugopt(buf);
mmclab.cpp:761:            mexErrMsgTxt("the 'srctype' field must be a non-empty string");
mmclab.cpp:774:        cfg->srctype = mcx_keylookup(strtypestr, srctypeid);
mmclab.cpp:776:        if (cfg->srctype == -1) {
mmclab.cpp:785:            MEXERROR("the 'session' field must be a non-empty string");
mmclab.cpp:792:        int status = mxGetString(item, cfg->session, MAX_SESSION_LENGTH);
mmclab.cpp:798:        printf("mmc.session='%s';\n", cfg->session);
mmclab.cpp:803:        if (cfg->srcpattern) {
mmclab.cpp:804:            free(cfg->srcpattern);
mmclab.cpp:808:            cfg->srcnum = arraydim[2];
mmclab.cpp:810:            cfg->srcnum = 1;
mmclab.cpp:813:        cfg->srcpattern = (float*)malloc(arraydim[0] * arraydim[1] * cfg->srcnum * sizeof(float));
mmclab.cpp:815:        for (k = 0; k < arraydim[0]*arraydim[1]*cfg->srcnum; k++) {
mmclab.cpp:816:            cfg->srcpattern[k] = val[k];
mmclab.cpp:819:        printf("mmc.srcpattern=[%d %d %d];\n", (int)arraydim[0], (int)arraydim[1], cfg->srcnum);
mmclab.cpp:826:            mexErrMsgTxt("the 'method' field must be a non-empty string");
mmclab.cpp:839:        cfg->method = mcx_keylookup(methodstr, methods);
mmclab.cpp:841:        if (cfg->method == -1) {
mmclab.cpp:852:            mexErrMsgTxt("the 'outputtype' field must be a non-empty string");
mmclab.cpp:865:        cfg->outputtype = mcx_keylookup(outputstr, outputtype);
mmclab.cpp:867:        if (cfg->outputtype == -1) {
mmclab.cpp:878:            mexErrMsgTxt("the 'compute' field must be a non-empty string");
mmclab.cpp:891:        cfg->compute = mcx_keylookup(computestr, computebackend);
mmclab.cpp:893:        if (cfg->compute == -1) {
mmclab.cpp:902:            MEXERROR("the 'shapes' field must be a non-empty string");
mmclab.cpp:917:            cfg->seed = val[0];
mmclab.cpp:918:            printf("mmc.seed=%d;\n", cfg->seed);
mmclab.cpp:920:            cfg->photonseed = malloc(arraydim[0] * arraydim[1]);
mmclab.cpp:923:                MEXERROR("the row number of cfg.seed does not match RNG seed byte-length");
mmclab.cpp:926:            memcpy(cfg->photonseed, mxGetData(item), arraydim[0]*arraydim[1]);
mmclab.cpp:927:            cfg->seed = SEED_FROM_FILE;
mmclab.cpp:928:            cfg->nphoton = arraydim[1];
mmclab.cpp:929:            printf("mmc.nphoton=%zu;\n", cfg->nphoton);
mmclab.cpp:938:        cfg->his.detected = arraydim[0] * arraydim[1];
mmclab.cpp:939:        cfg->replayweight = (float*)malloc(cfg->his.detected * sizeof(float));
mmclab.cpp:940:        memcpy(cfg->replayweight, mxGetData(item), cfg->his.detected * sizeof(float));
mmclab.cpp:941:        printf("mmc.replayweight=%d;\n", cfg->his.detected);
mmclab.cpp:949:        cfg->his.detected = arraydim[0] * arraydim[1];
mmclab.cpp:950:        cfg->replaytime = (float*)malloc(cfg->his.detected * sizeof(float));
mmclab.cpp:951:        memcpy(cfg->replaytime, mxGetData(item), cfg->his.detected * sizeof(float));
mmclab.cpp:952:        printf("mmc.replaytime=%d;\n", cfg->his.detected);
mmclab.cpp:958:                mexErrMsgTxt("the 'gpuid' field must be an integer or non-empty string");
mmclab.cpp:965:            int status = mxGetString(item, cfg->deviceid, MAX_DEVICE);
mmclab.cpp:971:            printf("mmc.gpuid='%s';\n", cfg->deviceid);
mmclab.cpp:974:            cfg->gpuid = val[0];
mmclab.cpp:975:            memset(cfg->deviceid, 0, MAX_DEVICE);
mmclab.cpp:977:            if (cfg->gpuid > 0 && cfg->gpuid < MAX_DEVICE) {
mmclab.cpp:978:                memset(cfg->deviceid, '0', cfg->gpuid - 1);
mmclab.cpp:979:                cfg->deviceid[cfg->gpuid - 1] = '1';
mmclab.cpp:982:            printf("mmc.gpuid=%d;\n", cfg->gpuid);
mmclab.cpp:986:            if (cfg->deviceid[i] == '0') {
mmclab.cpp:987:                cfg->deviceid[i] = '\0';
mmclab.cpp:998:            cfg->workload[i] = val[i];
mmclab.cpp:1016: * Perform self-checking and raise exceptions or warnings when input error is detected
mmclab.cpp:1025:    if (cfg->nphoton <= 0) {
mmclab.cpp:1029:    if (cfg->tstart > cfg->tend || cfg->tstep == 0.f) {
mmclab.cpp:1033:    if (cfg->tstep > cfg->tend - cfg->tstart) {
mmclab.cpp:1034:        cfg->tstep = cfg->tend - cfg->tstart;
mmclab.cpp:1037:    if (ABS(cfg->srcdir.x * cfg->srcdir.x + cfg->srcdir.y * cfg->srcdir.y + cfg->srcdir.z * cfg->srcdir.z - 1.f) > 1e-5) {
mmclab.cpp:1041:    if (cfg->tend <= cfg->tstart) {
mmclab.cpp:1045:    cfg->maxgate = (int)((cfg->tend - cfg->tstart) / cfg->tstep + 0.5);
mmclab.cpp:1046:    cfg->tend = cfg->tstart + cfg->tstep * cfg->maxgate;
mmclab.cpp:1048:    if (mesh->prop == 0) {
mmclab.cpp:1052:    if (mesh->nn == 0 || mesh->ne == 0 || mesh->evol == NULL || mesh->facenb == NULL) {
mmclab.cpp:1056:    mesh->nvol = (float*)calloc(sizeof(float), mesh->nn);
mmclab.cpp:1058:    for (i = 0; i < mesh->ne; i++) {
mmclab.cpp:1059:        if (mesh->type[i] <= 0) {
mmclab.cpp:1063:        ee = (int*)(mesh->elem + i * mesh->elemlen);
mmclab.cpp:1066:            mesh->nvol[ee[j] - 1] += mesh->evol[i] * 0.25f;
mmclab.cpp:1070:    if (mesh->weight) {
mmclab.cpp:1071:        free(mesh->weight);
mmclab.cpp:1074:    if (cfg->method == rtBLBadouelGrid) {
mmclab.cpp:1076:        cfg->basisorder = 0;
mmclab.cpp:1079:    datalen = (cfg->method == rtBLBadouelGrid) ? cfg->crop0.z : ( (cfg->basisorder) ? mesh->nn : mesh->ne);
mmclab.cpp:1080:    mesh->weight = (double*)calloc(sizeof(double) * datalen * cfg->srcnum, cfg->maxgate);
mmclab.cpp:1082:    if (cfg->srctype == stPattern && cfg->srcpattern == NULL) {
mmclab.cpp:1086:    if (cfg->srcnum > 1 && cfg->seed == SEED_FROM_FILE) {
mmclab.cpp:1090:    if (cfg->method != rtBLBadouelGrid && cfg->unitinmm != 1.f) {
mmclab.cpp:1091:        for (i = 1; i <= mesh->prop; i++) {
mmclab.cpp:1092:            mesh->med[i].mus *= cfg->unitinmm;
mmclab.cpp:1093:            mesh->med[i].mua *= cfg->unitinmm;
mmclab.cpp:1097:    cfg->his.unitinmm = cfg->unitinmm;
mmclab.cpp:1099:    if (cfg->steps.x != cfg->steps.y || cfg->steps.y != cfg->steps.z) {
mmclab.cpp:1100:        MEXERROR("MMC dual-grid algorithm currently does not support anisotropic voxels");
mmclab.cpp:1103:    if (mesh->node == NULL || mesh->elem == NULL || mesh->prop == 0) {
mmclab.cpp:1108:    if (cfg->isextdet) {
mmclab.cpp:1109:        mesh->med = (medium*)realloc(mesh->med, sizeof(medium) * (mesh->prop + 2));
mmclab.cpp:1110:        memcpy(mesh->med + mesh->prop + 1, mesh->med, sizeof(medium));
mmclab.cpp:1112:        for (i = 0; i < mesh->ne; i++) {
mmclab.cpp:1113:            if (mesh->type[i] == -2) {
mmclab.cpp:1114:                mesh->type[i] = mesh->prop + 1;
mmclab.cpp:1119:    if (cfg->issavedet && cfg->detnum == 0 && cfg->isextdet == 0) {
mmclab.cpp:1120:        cfg->issavedet = 0;
mmclab.cpp:1123:    if (cfg->seed < 0 && cfg->seed != SEED_FROM_FILE) {
mmclab.cpp:1124:        cfg->seed = time(NULL);
mmclab.cpp:1127:    if (cfg->issavedet == 0) {
mmclab.cpp:1128:        cfg->ismomentum = 0;
mmclab.cpp:1129:        cfg->issaveexit = 0;
mmclab.cpp:1132:    if (cfg->seed == SEED_FROM_FILE && cfg->his.detected != cfg->nphoton) {
mmclab.cpp:1133:        cfg->his.detected = 0;
mmclab.cpp:1135:        if (cfg->replayweight == NULL) {
mmclab.cpp:1137:        } else if (cfg->replaytime == NULL) {
mmclab.cpp:1144:    // cfg->his.maxmedia=cfg->medianum-1; /*skip medium 0*/
mmclab.cpp:1145:    cfg->his.detnum = cfg->detnum;
mmclab.cpp:1146:    cfg->his.colcount = (1 + (cfg->ismomentum > 0)) * cfg->his.maxmedia + (cfg->issaveexit > 0) * 6 + 1;
mmc.c:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc.c:5:**  \copyright Qianqian Fang, 2010-2021
mmc.c:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc.c:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc.c:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc.c:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc.c:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc.c:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc.c:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc.c:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc.c:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc.c:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc.c:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc.c:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc.c:55:tetrahedral mesh (mesh) and the ray-tracer precomputed data (tracer).
mmc.c:65:    initialize all elements to its default settings, and then set user-specified
mmc.c:71:           In the second step, we pre-compute all needed mesh and ray-tracing data
mmc_doxygen.cfg:13:#---------------------------------------------------------------------------
mmc_doxygen.cfg:15:#---------------------------------------------------------------------------
mmc_doxygen.cfg:18:# that follow. The default is UTF-8 which is also the encoding used for all
mmc_doxygen.cfg:23:DOXYFILE_ENCODING      = UTF-8
mmc_doxygen.cfg:44:# 4096 sub-directories (in 2 levels) under the output directory of each output
mmc_doxygen.cfg:56:# Afrikaans, Arabic, Brazilian, Catalan, Chinese, Chinese-Traditional,
mmc_doxygen.cfg:58:# Greek, Hungarian, Italian, Japanese, Japanese-en (Japanese with English
mmc_doxygen.cfg:59:# messages), Korean, Korean-en, Lithuanian, Norwegian, Macedonian, Persian,
mmc_doxygen.cfg:60:# Polish, Portuguese, Romanian, Russian, Serbian, Serbian-Cyrilic, Slovak,
mmc_doxygen.cfg:79:# This tag implements a quasi-intelligent brief description abbreviator
mmc_doxygen.cfg:83:# used as the annotated text. Otherwise, the brief description is used as-is.
mmc_doxygen.cfg:111:# can be used to strip a user-defined part of the path. Stripping is
mmc_doxygen.cfg:112:# only done if one of the specified strings matches the left-hand part of
mmc_doxygen.cfg:119:# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of
mmc_doxygen.cfg:124:# are normally passed to the compiler using the -I flag.
mmc_doxygen.cfg:130:# doesn't support long names like on DOS, Mac, or CD-ROM.
mmc_doxygen.cfg:135:# will interpret the first line (until the first dot) of a JavaDoc-style
mmc_doxygen.cfg:137:# comments will behave just like regular Qt-style comments
mmc_doxygen.cfg:143:# interpret the first line (until the first dot) of a Qt-style
mmc_doxygen.cfg:145:# will behave just like regular Qt-style comments (thus requiring
mmc_doxygen.cfg:151:# treat a multi-line C++ special comment block (i.e. a block of //! or ///
mmc_doxygen.cfg:153:# The new default is to treat a multi-line C++ comment block as a detailed
mmc_doxygen.cfg:160:# re-implements.
mmc_doxygen.cfg:179:# will result in a user-defined paragraph with heading "Side Effects:".
mmc_doxygen.cfg:212:# Doxygen has a built-in mapping, but you can override or extend it using this tag.
mmc_doxygen.cfg:215:# Objective-C, Python, Fortran, VHDL, C, C++. For instance to make doxygen treat
mmc_doxygen.cfg:291:#---------------------------------------------------------------------------
mmc_doxygen.cfg:293:#---------------------------------------------------------------------------
mmc_doxygen.cfg:318:# This flag is only useful for Objective-C code. When set to YES local
mmc_doxygen.cfg:370:# file names in lower-case letters. If set to YES upper-case letters are also
mmc_doxygen.cfg:425:# sorted by fully-qualified names, including namespaces. If set to
mmc_doxygen.cfg:501:# popen()) the command <command> <input-file>, where <command> is the value of
mmc_doxygen.cfg:502:# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file
mmc_doxygen.cfg:511:# doxygen's defaults, run doxygen with the -l option. You can optionally specify a
mmc_doxygen.cfg:517:#---------------------------------------------------------------------------
mmc_doxygen.cfg:519:#---------------------------------------------------------------------------
mmc_doxygen.cfg:568:#---------------------------------------------------------------------------
mmc_doxygen.cfg:570:#---------------------------------------------------------------------------
mmc_doxygen.cfg:580:# that doxygen parses. Internally doxygen uses the UTF-8 encoding, which is
mmc_doxygen.cfg:585:INPUT_ENCODING         = UTF-8
mmc_doxygen.cfg:589:# and *.h) to filter out the source-files in the directories. If left
mmc_doxygen.cfg:638:# and *.h) to filter out the source-files in the directories. If left
mmc_doxygen.cfg:658:# by executing (via popen()) the command <filter> <input-file>, where <filter>
mmc_doxygen.cfg:659:# is the value of the INPUT_FILTER tag, and <input-file> is the name of an
mmc_doxygen.cfg:684:#---------------------------------------------------------------------------
mmc_doxygen.cfg:686:#---------------------------------------------------------------------------
mmc_doxygen.cfg:689:# be generated. Documented entities will be cross-referenced with these sources.
mmc_doxygen.cfg:728:# built-in source browser. The htags tool is part of GNU's global source
mmc_doxygen.cfg:740:#---------------------------------------------------------------------------
mmc_doxygen.cfg:742:#---------------------------------------------------------------------------
mmc_doxygen.cfg:763:#---------------------------------------------------------------------------
mmc_doxygen.cfg:765:#---------------------------------------------------------------------------
mmc_doxygen.cfg:796:# The HTML_STYLESHEET tag can be used to specify a user-defined cascading
mmc_doxygen.cfg:798:# fine-tune the look of the HTML output. If the tag is left blank doxygen
mmc_doxygen.cfg:846:# reverse domain-name style string, e.g. com.mycompany.MyDocSet. Doxygen
mmc_doxygen.cfg:867:# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run
mmc_doxygen.cfg:916:# http://doc.trolltech.com/qthelpproject.html#virtual-folders
mmc_doxygen.cfg:922:# http://doc.trolltech.com/qthelpproject.html#custom-filters
mmc_doxygen.cfg:927:# <a href="http://doc.trolltech.com/qthelpproject.html#custom-filters">Qt Help Project / Custom Filters</a>.
mmc_doxygen.cfg:933:# <a href="http://doc.trolltech.com/qthelpproject.html#filter-attributes">Qt Help Project / Filter Attributes</a>.
mmc_doxygen.cfg:939:# If non-empty doxygen will try to run qhelpgenerator on the generated
mmc_doxygen.cfg:971:# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
mmc_doxygen.cfg:974:# containing a tree-like index structure (just like the one that
mmc_doxygen.cfg:1013:#---------------------------------------------------------------------------
mmc_doxygen.cfg:1015:#---------------------------------------------------------------------------
mmc_doxygen.cfg:1096:#---------------------------------------------------------------------------
mmc_doxygen.cfg:1098:#---------------------------------------------------------------------------
mmc_doxygen.cfg:1138:#---------------------------------------------------------------------------
mmc_doxygen.cfg:1140:#---------------------------------------------------------------------------
mmc_doxygen.cfg:1166:#---------------------------------------------------------------------------
mmc_doxygen.cfg:1168:#---------------------------------------------------------------------------
mmc_doxygen.cfg:1196:# and cross-referencing information) to the XML output. Note that
mmc_doxygen.cfg:1201:#---------------------------------------------------------------------------
mmc_doxygen.cfg:1203:#---------------------------------------------------------------------------
mmc_doxygen.cfg:1213:#---------------------------------------------------------------------------
mmc_doxygen.cfg:1215:#---------------------------------------------------------------------------
mmc_doxygen.cfg:1248:#---------------------------------------------------------------------------
mmc_doxygen.cfg:1250:#---------------------------------------------------------------------------
mmc_doxygen.cfg:1253:# evaluate all C-preprocessor directives found in the sources and include
mmc_doxygen.cfg:1283:# patterns (like *.h and *.hpp) to filter out the header-files in the
mmc_doxygen.cfg:1290:# are defined before the preprocessor is started (similar to the -D option of
mmc_doxygen.cfg:1307:# doxygen's preprocessor will remove all function-like macros that are alone
mmc_doxygen.cfg:1309:# function macros are typically used for boiler-plate code, and will confuse
mmc_doxygen.cfg:1314:#---------------------------------------------------------------------------
mmc_doxygen.cfg:1316:#---------------------------------------------------------------------------
mmc_doxygen.cfg:1359:#---------------------------------------------------------------------------
mmc_doxygen.cfg:1361:#---------------------------------------------------------------------------
mmc_doxygen.cfg:1529:# enabling this option may lead to badly anti-aliased labels on the edges of
mmc_doxygen.cfg:1535:# files in one run (i.e. multiple -o and -T options on the command line). This
mmc_rand_posix.c:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_rand_posix.c:5:**  \copyright Qianqian Fang, 2010-2021
mmc_rand_posix.c:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_rand_posix.c:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_rand_posix.c:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_rand_posix.c:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_rand_posix.c:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_rand_posix.c:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_rand_posix.c:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_rand_posix.c:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_rand_posix.c:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_rand_posix.c:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_rand_posix.c:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_rand_posix.c:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_rand_posix.c:35:\brief   A POSIX Random Number Generator for multi-threaded applications
mmc_tictoc.c:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_tictoc.c:5:**  \copyright Qianqian Fang, 2010-2021
mmc_tictoc.c:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_tictoc.c:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_tictoc.c:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_tictoc.c:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_tictoc.c:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_tictoc.c:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_tictoc.c:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_tictoc.c:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_tictoc.c:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_tictoc.c:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_tictoc.c:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_tictoc.c:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_tictoc.c:51:    elapsedTime = (timerStop - timerStart) * 1e-6;
mmc_tictoc.c:117: * GetTime --
mmc_tictoc.c:154:  between 10-15 ms query for the range of value periods and then set timer
mmc_tictoc.c:193:  @brief Cross-platform sleep function
mmc_optix_utils.cpp:60:    MMC_FPRINTF(cfg->flog, "optix init complete:  \t%d ms\n",
mmc_optix_utils.cpp:61:                GetTimeMillis() - tic0);
mmc_optix_utils.cpp:62:    fflush(cfg->flog);
mmc_optix_utils.cpp:66:    MMC_FPRINTF(cfg->flog, "optix module complete:  \t%d ms\n",
mmc_optix_utils.cpp:67:                GetTimeMillis() - tic0);
mmc_optix_utils.cpp:68:    fflush(cfg->flog);
mmc_optix_utils.cpp:73:    MMC_FPRINTF(cfg->flog, "optix device programs complete:  \t%d ms\n",
mmc_optix_utils.cpp:74:                GetTimeMillis() - tic0);
mmc_optix_utils.cpp:75:    fflush(cfg->flog);
mmc_optix_utils.cpp:81:        (surfmesh*)calloc((mesh->prop + 1), sizeof(surfmesh));
mmc_optix_utils.cpp:99:        for (int i = 0; i <= mesh->prop; ++i) {
mmc_optix_utils.cpp:108:    MMC_FPRINTF(cfg->flog,
mmc_optix_utils.cpp:110:                GetTimeMillis() - tic0);
mmc_optix_utils.cpp:111:    fflush(cfg->flog);
mmc_optix_utils.cpp:114:    MMC_FPRINTF(cfg->flog, "optix pipeline complete:  \t%d ms\n",
mmc_optix_utils.cpp:115:                GetTimeMillis() - tic0);
mmc_optix_utils.cpp:116:    fflush(cfg->flog);
mmc_optix_utils.cpp:120:    MMC_FPRINTF(cfg->flog,
mmc_optix_utils.cpp:122:                GetTimeMillis() - tic0);
mmc_optix_utils.cpp:123:    fflush(cfg->flog);
mmc_optix_utils.cpp:130:    MMC_FPRINTF(cfg->flog, "optix launch parameters complete:  \t%d ms\n",
mmc_optix_utils.cpp:131:                GetTimeMillis() - tic0);
mmc_optix_utils.cpp:132:    fflush(cfg->flog);
mmc_optix_utils.cpp:137:    MMC_FPRINTF(cfg->flog,
mmc_optix_utils.cpp:139:                cfg->tstart * 1e9, cfg->tend * 1e9);
mmc_optix_utils.cpp:140:    fflush(cfg->flog);
mmc_optix_utils.cpp:150:    MMC_FPRINTF(cfg->flog,
mmc_optix_utils.cpp:152:                GetTimeMillis() - tic0);
mmc_optix_utils.cpp:153:    fflush(cfg->flog);
mmc_optix_utils.cpp:160:    MMC_FPRINTF(cfg->flog, "transfer complete:        %d ms\n",
mmc_optix_utils.cpp:161:                GetTimeMillis() - tic0);
mmc_optix_utils.cpp:162:    fflush(cfg->flog);
mmc_optix_utils.cpp:167:        mesh->weight[i] +=
mmc_optix_utils.cpp:176:    if (cfg->isnormalized) {
mmc_optix_utils.cpp:177:        MMC_FPRINTF(cfg->flog, "normalizing raw data ...\t");
mmc_optix_utils.cpp:178:        fflush(cfg->flog);
mmc_optix_utils.cpp:180:        // not used if cfg->method == rtBLBadouelGrid
mmc_optix_utils.cpp:181:        cfg->energyabs = 0.0f;
mmc_optix_utils.cpp:184:        cfg->energytot = cfg->nphoton;
mmc_optix_utils.cpp:185:        mesh_normalize(mesh, cfg, cfg->energyabs, cfg->energytot, 0);
mmc_optix_utils.cpp:186:        MMC_FPRINTF(cfg->flog, "normalization complete:    %d ms\n",
mmc_optix_utils.cpp:187:                    GetTimeMillis() - tic0);
mmc_optix_utils.cpp:188:        fflush(cfg->flog);
mmc_optix_utils.cpp:193:        if (cfg->issave2pt && cfg->parentid == mpStandalone) {
mmc_optix_utils.cpp:194:            MMC_FPRINTF(cfg->flog, "saving data to file ...\t");
mmc_optix_utils.cpp:196:            MMC_FPRINTF(cfg->flog,
mmc_optix_utils.cpp:198:                        GetTimeMillis() - tic0);
mmc_optix_utils.cpp:199:            fflush(cfg->flog);
mmc_optix_utils.cpp:213:    int* fnb = (int*)calloc(tmesh->ne * tmesh->elemlen, sizeof(int));
mmc_optix_utils.cpp:214:    memcpy(fnb, tmesh->facenb, (tmesh->ne * tmesh->elemlen) * sizeof(int));
mmc_optix_utils.cpp:218:    for (int i = 0; i < tmesh->ne; ++i) {
mmc_optix_utils.cpp:220:        unsigned int currmedid = tmesh->type[i];
mmc_optix_utils.cpp:222:        for (int j = 0; j < tmesh->elemlen; ++j) {
mmc_optix_utils.cpp:224:            int nexteid = fnb[(i * tmesh->elemlen) + j];
mmc_optix_utils.cpp:231:                ((nexteid < 0) ? 0 : tmesh->type[nexteid - 1]);
mmc_optix_utils.cpp:236:                    tmesh->elem[(i * tmesh->elemlen) +
mmc_optix_utils.cpp:237:                                                     out[ifaceorder[j]][0]] -
mmc_optix_utils.cpp:240:                    tmesh->elem[(i * tmesh->elemlen) +
mmc_optix_utils.cpp:241:                                                     out[ifaceorder[j]][1]] -
mmc_optix_utils.cpp:244:                    tmesh->elem[(i * tmesh->elemlen) +
mmc_optix_utils.cpp:245:                                                     out[ifaceorder[j]][2]] -
mmc_optix_utils.cpp:254:                // outward-pointing face norm
mmc_optix_utils.cpp:255:                v0 = *(float3*)&tmesh->fnode[n0];
mmc_optix_utils.cpp:256:                v1 = *(float3*)&tmesh->fnode[n1];
mmc_optix_utils.cpp:257:                v2 = *(float3*)&tmesh->fnode[n2];
mmc_optix_utils.cpp:271:                smesh[nextmedid].norm.push_back(-vnorm);
mmc_optix_utils.cpp:277:                fnb[(i * tmesh->elemlen) + j] = INT_MIN;
mmc_optix_utils.cpp:280:                    for (int k = 0; k < tmesh->elemlen;
mmc_optix_utils.cpp:282:                        if (fnb[((nexteid - 1) *
mmc_optix_utils.cpp:283:                                                tmesh->elemlen) +
mmc_optix_utils.cpp:285:                            fnb[((nexteid - 1) *
mmc_optix_utils.cpp:286:                                                tmesh->elemlen) +
mmc_optix_utils.cpp:302:    if (cfg->method != rtBLBadouelGrid) {
mmc_optix_utils.cpp:303:        mcx_error(-1, "Optix MMC only supports dual grid mode",
mmc_optix_utils.cpp:307:    int timeSteps = (int)((cfg->tend - cfg->tstart) / cfg->tstep + 0.5);
mmc_optix_utils.cpp:310:        mcx_error(-1, "There must be at least one time step.", __FILE__,
mmc_optix_utils.cpp:315:    if (mesh->prop + 1 > MAX_PROP_OPTIX) {
mmc_optix_utils.cpp:316:        mcx_error(-1, "Medium type count exceeds limit.", __FILE__,
mmc_optix_utils.cpp:320:    for (int i = 0; i <= mesh->prop; ++i) {
mmc_optix_utils.cpp:321:        optixcfg->launchParams.medium[i].mua = mesh->med[i].mua;
mmc_optix_utils.cpp:322:        optixcfg->launchParams.medium[i].mus = mesh->med[i].mus;
mmc_optix_utils.cpp:323:        optixcfg->launchParams.medium[i].g = mesh->med[i].g;
mmc_optix_utils.cpp:324:        optixcfg->launchParams.medium[i].n = mesh->med[i].n;
mmc_optix_utils.cpp:328:    optixcfg->launchParams.srcpos =
mmc_optix_utils.cpp:329:        make_float3(cfg->srcpos.x, cfg->srcpos.y, cfg->srcpos.z);
mmc_optix_utils.cpp:330:    optixcfg->launchParams.srcdir =
mmc_optix_utils.cpp:331:        make_float3(cfg->srcdir.x, cfg->srcdir.y, cfg->srcdir.z);
mmc_optix_utils.cpp:336:        capsules_buf.alloc_and_upload(optixcfg->capsules);
mmc_optix_utils.cpp:338:        optixcfg->launchParams.capsuleData = capsules_buf.d_pointer();
mmc_optix_utils.cpp:344:        surfaceData_buf.alloc_and_upload(optixcfg->surfaceData);
mmc_optix_utils.cpp:345:        optixcfg->launchParams.surfaceData = surfaceData_buf.d_pointer();
mmc_optix_utils.cpp:349:    optixcfg->launchParams.nmin =
mmc_optix_utils.cpp:350:        make_float3(mesh->nmin.x, mesh->nmin.y, mesh->nmin.z);
mmc_optix_utils.cpp:351:    optixcfg->launchParams.nmax = make_float3(mesh->nmax.x - mesh->nmin.x,
mmc_optix_utils.cpp:352:                                  mesh->nmax.y - mesh->nmin.y,
mmc_optix_utils.cpp:353:                                  mesh->nmax.z - mesh->nmin.z);
mmc_optix_utils.cpp:354:    optixcfg->launchParams.crop0 = make_uint4(
mmc_optix_utils.cpp:355:                                       cfg->crop0.x, cfg->crop0.y, cfg->crop0.z, cfg->crop0.z * timeSteps);
mmc_optix_utils.cpp:356:    optixcfg->launchParams.dstep = 1.0f / cfg->unitinmm;
mmc_optix_utils.cpp:358:    // time-gate settings
mmc_optix_utils.cpp:359:    optixcfg->launchParams.tstart = cfg->tstart;
mmc_optix_utils.cpp:360:    optixcfg->launchParams.tend = cfg->tend;
mmc_optix_utils.cpp:361:    optixcfg->launchParams.Rtstep = 1.0f / cfg->tstep;
mmc_optix_utils.cpp:362:    optixcfg->launchParams.maxgate = cfg->maxgate;
mmc_optix_utils.cpp:370:           optixcfg->launchParams.mediumid0 = IMPLICIT_MATERIAL;   
mmc_optix_utils.cpp:371:           optixcfg->launchParams.gashandle0 = 
mmc_optix_utils.cpp:372:               optixcfg->inside_primitive_handles[optixcfg->launchParams.mediumid0];
mmc_optix_utils.cpp:377:            optixcfg->launchParams.mediumid0 = mesh->type[cfg->e0 - 1];
mmc_optix_utils.cpp:380:            optixcfg->launchParams.gashandle0 = 
mmc_optix_utils.cpp:381:            optixcfg->outside_primitive_handles[optixcfg->launchParams.mediumid0];
mmc_optix_utils.cpp:386:    optixcfg->launchParams.mediumid0 = mesh->type[cfg->e0 - 1];
mmc_optix_utils.cpp:389:    optixcfg->launchParams.gashandle0 =
mmc_optix_utils.cpp:390:        optixcfg->gashandles[optixcfg->launchParams.mediumid0];
mmc_optix_utils.cpp:394:    optixcfg->launchParams.isreflect = cfg->isreflect;
mmc_optix_utils.cpp:397:    optixcfg->launchParams.outputtype = static_cast<int>(cfg->outputtype);
mmc_optix_utils.cpp:400:    int totalthread = cfg->nthread;
mmc_optix_utils.cpp:406:    gpuid = cfg->deviceid[threadid] - 1;
mmc_optix_utils.cpp:408:    if (cfg->autopilot) {
mmc_optix_utils.cpp:412:    optixcfg->launchWidth = totalthread;
mmc_optix_utils.cpp:413:    optixcfg->launchParams.threadphoton =
mmc_optix_utils.cpp:414:        cfg->nphoton / optixcfg->launchWidth;
mmc_optix_utils.cpp:415:    optixcfg->launchParams.oddphoton =
mmc_optix_utils.cpp:416:        cfg->nphoton - optixcfg->launchParams.threadphoton * totalthread;
mmc_optix_utils.cpp:419:    optixcfg->outputBufferSize = (optixcfg->launchParams.crop0.w << 1);
mmc_optix_utils.cpp:420:    optixcfg->outputHostBuffer =
mmc_optix_utils.cpp:421:        (float*)calloc(optixcfg->outputBufferSize, sizeof(float));
mmc_optix_utils.cpp:422:    optixcfg->outputBuffer.alloc_and_upload(optixcfg->outputHostBuffer,
mmc_optix_utils.cpp:423:                                            optixcfg->outputBufferSize);
mmc_optix_utils.cpp:424:    optixcfg->launchParams.outputbuffer =
mmc_optix_utils.cpp:425:        optixcfg->outputBuffer.d_pointer();
mmc_optix_utils.cpp:428:    if (cfg->seed > 0) {
mmc_optix_utils.cpp:429:        srand(cfg->seed);
mmc_optix_utils.cpp:440:    optixcfg->seedBuffer.alloc_and_upload(hseed, totalthread);
mmc_optix_utils.cpp:441:    optixcfg->launchParams.seedbuffer = optixcfg->seedBuffer.d_pointer();
mmc_optix_utils.cpp:448:    optixcfg->launchParamsBuffer.alloc_and_upload(&optixcfg->launchParams,
mmc_optix_utils.cpp:474:    gpuid = cfg->deviceid[threadid] - 1;
mmc_optix_utils.cpp:477:        mcx_error(-1, "GPU ID must be non-zero", __FILE__, __LINE__);
mmc_optix_utils.cpp:481:    CUDA_ASSERT(cudaStreamCreate(&optixcfg->stream));
mmc_optix_utils.cpp:483:    cudaGetDeviceProperties(&optixcfg->deviceProps, gpuid);
mmc_optix_utils.cpp:484:    std::cout << "Running on device: " << optixcfg->deviceProps.name
mmc_optix_utils.cpp:487:    CUresult cuRes = cuCtxGetCurrent(&optixcfg->cudaContext);
mmc_optix_utils.cpp:509:    OPTIX_CHECK(optixDeviceContextCreate(optixcfg->cudaContext, &options,
mmc_optix_utils.cpp:510:                                         &optixcfg->optixContext));
mmc_optix_utils.cpp:519:    optixcfg->moduleCompileOptions.maxRegisterCount =
mmc_optix_utils.cpp:522:    optixcfg->moduleCompileOptions.debugLevel =
mmc_optix_utils.cpp:524:    optixcfg->moduleCompileOptions.optLevel =
mmc_optix_utils.cpp:527:    optixcfg->moduleCompileOptions.debugLevel =
mmc_optix_utils.cpp:529:    optixcfg->moduleCompileOptions.optLevel =
mmc_optix_utils.cpp:534:    optixcfg->pipelineCompileOptions = {};
mmc_optix_utils.cpp:535:    optixcfg->pipelineCompileOptions.usesMotionBlur = false;
mmc_optix_utils.cpp:539:        optixcfg->pipelineCompileOptions.numPayloadValues = 18;
mmc_optix_utils.cpp:540:        optixcfg->pipelineCompileOptions.numAttributeValues = 4;
mmc_optix_utils.cpp:541:        optixcfg->pipelineCompileOptions.usesPrimitiveTypeFlags = OPTIX_PRIMITIVE_TYPE_TRIANGLE | OPTIX_PRIMITIVE_TYPE_FLAGS_SPHERE | OPTIX_PRIMITIVE_TYPE_FLAGS_CUSTOM;
mmc_optix_utils.cpp:542:        optixcfg->pipelineCompileOptions.traversableGraphFlags =
mmc_optix_utils.cpp:546:        optixcfg->pipelineCompileOptions.numPayloadValues = 16;
mmc_optix_utils.cpp:547:        optixcfg->pipelineCompileOptions.numAttributeValues =
mmc_optix_utils.cpp:549:        optixcfg->pipelineCompileOptions.traversableGraphFlags =
mmc_optix_utils.cpp:554:    optixcfg->pipelineCompileOptions.exceptionFlags =
mmc_optix_utils.cpp:558:    optixcfg->pipelineCompileOptions.exceptionFlags =
mmc_optix_utils.cpp:561:    optixcfg->pipelineCompileOptions.pipelineLaunchParamsVariableName =
mmc_optix_utils.cpp:565:    optixcfg->pipelineLinkOptions.maxTraceDepth = 1;
mmc_optix_utils.cpp:570:                    optixcfg->optixContext, &optixcfg->moduleCompileOptions,
mmc_optix_utils.cpp:571:                    &optixcfg->pipelineCompileOptions, ptxcode.c_str(), ptxcode.size(),
mmc_optix_utils.cpp:572:                    log, &logsize, &optixcfg->module));
mmc_optix_utils.cpp:583:    optixcfg->raygenPGs.resize(1);
mmc_optix_utils.cpp:588:    pgDesc.raygen.module = optixcfg->module;
mmc_optix_utils.cpp:593:    OPTIX_CHECK(optixProgramGroupCreate(optixcfg->optixContext, &pgDesc, 1,
mmc_optix_utils.cpp:595:                                        &optixcfg->raygenPGs[0]));
mmc_optix_utils.cpp:606:    optixcfg->missPGs.resize(1);
mmc_optix_utils.cpp:611:    pgDesc.raygen.module = optixcfg->module;
mmc_optix_utils.cpp:616:    OPTIX_CHECK(optixProgramGroupCreate(optixcfg->optixContext, &pgDesc, 1,
mmc_optix_utils.cpp:618:                                        &optixcfg->missPGs[0]));
mmc_optix_utils.cpp:625:// helper function for getting built-in intersection shader for sphere
mmc_optix_utils.cpp:638:    OPTIX_CHECK(optixBuiltinISModuleGet(ctx, &module_compile_options, &optixcfg->pipelineCompileOptions,
mmc_optix_utils.cpp:649:        optixcfg->hitgroupPGs.resize(3);  // TODO fix this global mutation
mmc_optix_utils.cpp:651:        OptixDeviceContext context = optixcfg->optixContext;
mmc_optix_utils.cpp:656:        capsules_grp_desc.hitgroup.moduleCH = optixcfg->module;
mmc_optix_utils.cpp:658:        capsules_grp_desc.hitgroup.moduleIS = optixcfg->module;
mmc_optix_utils.cpp:663:        spheres_grp_desc.hitgroup.moduleCH = optixcfg->module;
mmc_optix_utils.cpp:665:        spheres_grp_desc.hitgroup.moduleIS = getSphereModule(optixcfg->optixContext, optixcfg);
mmc_optix_utils.cpp:670:        triangles_grp_desc.hitgroup.moduleCH = optixcfg->module;
mmc_optix_utils.cpp:680:        OPTIX_CHECK(optixProgramGroupCreate(optixcfg->optixContext,
mmc_optix_utils.cpp:686:                                            optixcfg->hitgroupPGs.data()));
mmc_optix_utils.cpp:694:    optixcfg->hitgroupPGs.resize(1);
mmc_optix_utils.cpp:697:    pgDesc.hitgroup.moduleCH = optixcfg->module;
mmc_optix_utils.cpp:704:    OPTIX_CHECK(optixProgramGroupCreate(optixcfg->optixContext, &pgDesc, 1,
mmc_optix_utils.cpp:706:                                        &optixcfg->hitgroupPGs[0]));
mmc_optix_utils.cpp:722:    std::cout << "Building acceleration structures." << mesh->prop
mmc_optix_utils.cpp:727:    for (int i = 0; i <= mesh->prop; ++i) {
mmc_optix_utils.cpp:735:    for (int i = 0; i <= mesh->prop; ++i) {
mmc_optix_utils.cpp:741:    optixcfg->inside_primitive_handles = inside_prim_handles;
mmc_optix_utils.cpp:742:    optixcfg->outside_primitive_handles = outside_prim_handles;
mmc_optix_utils.cpp:750:    // add handles and material ID for all entering-implicit acceleration structures
mmc_optix_utils.cpp:751:    for (int i = 0; i <= mesh->prop; ++i) {
mmc_optix_utils.cpp:753:        for (const immc::ImplicitCapsule& capsule : optixcfg->capsules) {
mmc_optix_utils.cpp:755:                optixcfg->inside_primitive_handles[i]};
mmc_optix_utils.cpp:756:            optixcfg->surfaceData.push_back(c_data);
mmc_optix_utils.cpp:760:        for (const immc::ImplicitSphere& sphere : optixcfg->spheres) {
mmc_optix_utils.cpp:765:                                             optixcfg->inside_primitive_handles[i]};
mmc_optix_utils.cpp:766:            optixcfg->surfaceData.push_back(s_data);
mmc_optix_utils.cpp:775:                                                optixcfg->outside_primitive_handles[i]};
mmc_optix_utils.cpp:776:            optixcfg->surfaceData.push_back(t_data);
mmc_optix_utils.cpp:782:    // add handles and material ID for all exiting-implicit acceleration structures
mmc_optix_utils.cpp:783:    for (int i = 0; i <= mesh->prop; ++i) {
mmc_optix_utils.cpp:785:        for (const immc::ImplicitCapsule& capsule : optixcfg->capsules) {
mmc_optix_utils.cpp:790:                                        optixcfg->inside_primitive_handles[i]};
mmc_optix_utils.cpp:791:            optixcfg->surfaceData.push_back(c_data);
mmc_optix_utils.cpp:795:        for (const immc::ImplicitSphere& sphere : optixcfg->spheres) {
mmc_optix_utils.cpp:799:                                            0), optixcfg->inside_primitive_handles[i]};
mmc_optix_utils.cpp:801:            optixcfg->surfaceData.push_back(s_data);
mmc_optix_utils.cpp:811:                                            optixcfg->outside_primitive_handles[i]};
mmc_optix_utils.cpp:812:            optixcfg->surfaceData.push_back(t_data);
mmc_optix_utils.cpp:839:    for (immc::ImplicitCapsule capsule : optixcfg->capsules) {
mmc_optix_utils.cpp:863:    for (immc::ImplicitSphere sphere : optixcfg->spheres) {
mmc_optix_utils.cpp:883:    primitiveoffset += smesh->norm.size();
mmc_optix_utils.cpp:894:// end-caps) custom capsules. Had to make it custom because OptiX does not
mmc_optix_utils.cpp:895:// support in-to-out ray tracing vertexBuffer represents a list of the endpoints
mmc_optix_utils.cpp:934:        temp_aabb.minX = std::min(vertex_one.x, vertex_two.x) - width;
mmc_optix_utils.cpp:935:        temp_aabb.minY = std::min(vertex_one.y, vertex_two.y) - width;
mmc_optix_utils.cpp:936:        temp_aabb.minZ = std::min(vertex_one.z, vertex_two.z) - width;
mmc_optix_utils.cpp:964:                    optixcfg->optixContext, &accelerationOptions, &buildInput,
mmc_optix_utils.cpp:984:        optixAccelBuild(optixcfg->optixContext, optixcfg->stream,
mmc_optix_utils.cpp:999:        optixAccelCompact(optixcfg->optixContext, optixcfg->stream,
mmc_optix_utils.cpp:1063:                    optixcfg->optixContext, &accelerationOptions, &buildInput,
mmc_optix_utils.cpp:1083:        optixAccelBuild(optixcfg->optixContext, optixcfg->stream,
mmc_optix_utils.cpp:1098:        optixAccelCompact(optixcfg->optixContext, optixcfg->stream,
mmc_optix_utils.cpp:1118:    if(optixcfg->spheres.size() == 0)
mmc_optix_utils.cpp:1121:    float3 startPos = optixcfg->launchParams.srcpos;
mmc_optix_utils.cpp:1123:    for (immc::ImplicitSphere sphere : optixcfg->spheres) {
mmc_optix_utils.cpp:1124:        float3 displacement = startPos - sphere.position;
mmc_optix_utils.cpp:1133:    if(optixcfg->capsules.size() == 0)
mmc_optix_utils.cpp:1137:    float3 position = optixcfg->launchParams.srcpos; 
mmc_optix_utils.cpp:1138:    for (immc::ImplicitCapsule capsule : optixcfg->capsules) {
mmc_optix_utils.cpp:1141:            make_float3(capsule.vertex2.x - capsule.vertex1.x,
mmc_optix_utils.cpp:1142:                capsule.vertex2.y - capsule.vertex1.y,
mmc_optix_utils.cpp:1143:                capsule.vertex2.z - capsule.vertex1.z);
mmc_optix_utils.cpp:1146:            position.x - capsule.vertex1.x, position.y - capsule.vertex1.y,
mmc_optix_utils.cpp:1147:            position.z - capsule.vertex1.z);
mmc_optix_utils.cpp:1160:            make_float3(vector_toposition.x - projection.x,
mmc_optix_utils.cpp:1161:                vector_toposition.y - projection.y,
mmc_optix_utils.cpp:1162:                vector_toposition.z - projection.z);
mmc_optix_utils.cpp:1182:    if (smesh->face.empty()) {
mmc_optix_utils.cpp:1188:    // note: mesh->fnode needs to be float3
mmc_optix_utils.cpp:1189:    // mesh->face needs to be uint3 (zero-indexed)
mmc_optix_utils.cpp:1193:    vert_buff.alloc_and_upload(tmesh->fnode, tmesh->nn);
mmc_optix_utils.cpp:1196:    idx_buff.alloc_and_upload(smesh->face);
mmc_optix_utils.cpp:1211:    triangleInput.triangleArray.numVertices = tmesh->nn;
mmc_optix_utils.cpp:1217:    triangleInput.triangleArray.numIndexTriplets = smesh->face.size();
mmc_optix_utils.cpp:1222:    // in this example we have one SBT entry, and no per-primitive
mmc_optix_utils.cpp:1241:    OPTIX_CHECK(optixAccelComputeMemoryUsage(optixcfg->optixContext,
mmc_optix_utils.cpp:1266:                    optixcfg->optixContext, optixcfg->stream, &accelOptions,
mmc_optix_utils.cpp:1282:    OPTIX_CHECK(optixAccelCompact(optixcfg->optixContext,
mmc_optix_utils.cpp:1283:                                  optixcfg->stream,
mmc_optix_utils.cpp:1339:    OPTIX_CHECK(optixAccelComputeMemoryUsage(optixcfg->optixContext,
mmc_optix_utils.cpp:1355:        optixAccelBuild(optixcfg->optixContext, optixcfg->stream,
mmc_optix_utils.cpp:1371:        optixAccelCompact(optixcfg->optixContext, optixcfg->stream,
mmc_optix_utils.cpp:1390:    for (auto pg : optixcfg->raygenPGs) {
mmc_optix_utils.cpp:1394:    for (auto pg : optixcfg->missPGs) {
mmc_optix_utils.cpp:1398:    for (auto pg : optixcfg->hitgroupPGs) {
mmc_optix_utils.cpp:1405:                    optixcfg->optixContext, &optixcfg->pipelineCompileOptions,
mmc_optix_utils.cpp:1406:                    &optixcfg->pipelineLinkOptions, programGroups.data(),
mmc_optix_utils.cpp:1407:                    (int)programGroups.size(), log, &logsize, &optixcfg->pipeline));
mmc_optix_utils.cpp:1423:    for (size_t i = 0; i < optixcfg->raygenPGs.size(); i++) {
mmc_optix_utils.cpp:1426:            optixSbtRecordPackHeader(optixcfg->raygenPGs[i], &rec));
mmc_optix_utils.cpp:1431:    optixcfg->raygenRecordsBuffer.alloc_and_upload(raygenRecords);
mmc_optix_utils.cpp:1432:    optixcfg->sbt.raygenRecord = optixcfg->raygenRecordsBuffer.d_pointer();
mmc_optix_utils.cpp:1439:    for (size_t i = 0; i < optixcfg->missPGs.size(); i++) {
mmc_optix_utils.cpp:1442:            optixSbtRecordPackHeader(optixcfg->missPGs[i], &rec));
mmc_optix_utils.cpp:1447:    optixcfg->missRecordsBuffer.alloc_and_upload(missRecords);
mmc_optix_utils.cpp:1448:    optixcfg->sbt.missRecordBase = optixcfg->missRecordsBuffer.d_pointer();
mmc_optix_utils.cpp:1449:    optixcfg->sbt.missRecordStrideInBytes = sizeof(MissRecord);
mmc_optix_utils.cpp:1450:    optixcfg->sbt.missRecordCount = (int)missRecords.size();
mmc_optix_utils.cpp:1461:        OPTIX_CHECK(optixSbtRecordPackHeader(optixcfg->hitgroupPGs[0], &capsules_rec));
mmc_optix_utils.cpp:1462:        OPTIX_CHECK(optixSbtRecordPackHeader(optixcfg->hitgroupPGs[1], &spheres_rec));
mmc_optix_utils.cpp:1463:        OPTIX_CHECK(optixSbtRecordPackHeader(optixcfg->hitgroupPGs[2], &triangles_rec));
mmc_optix_utils.cpp:1473:        optixcfg->hitgroupRecordsBuffer.alloc_and_upload(hitgroupRecords);
mmc_optix_utils.cpp:1474:        optixcfg->sbt.hitgroupRecordBase = optixcfg->hitgroupRecordsBuffer.d_pointer();
mmc_optix_utils.cpp:1475:        optixcfg->sbt.hitgroupRecordStrideInBytes = sizeof(HitgroupRecord);
mmc_optix_utils.cpp:1476:        optixcfg->sbt.hitgroupRecordCount = (int)hitgroupRecords.size();
mmc_optix_utils.cpp:1486:    OPTIX_CHECK(optixSbtRecordPackHeader(optixcfg->hitgroupPGs[0], &rec));
mmc_optix_utils.cpp:1492:    for (int i = 0; i <= mesh->prop; ++i) {
mmc_optix_utils.cpp:1498:                optixcfg->gashandles[smesh[i].nbtype[j]]);
mmc_optix_utils.cpp:1502:    // prepare buffers on the gpu for holding face-normal data and
mmc_optix_utils.cpp:1504:    optixcfg->fnormBuffer.alloc_and_upload(fnorm);
mmc_optix_utils.cpp:1505:    optixcfg->nbgashandleBuffer.alloc_and_upload(nbgashandle);
mmc_optix_utils.cpp:1507:    // save the locations of the face-normals and triangle mesh handles on
mmc_optix_utils.cpp:1509:    rec.data.fnorm = (float4*)optixcfg->fnormBuffer.d_pointer();
mmc_optix_utils.cpp:1511:        (OptixTraversableHandle*)optixcfg->nbgashandleBuffer.d_pointer();
mmc_optix_utils.cpp:1515:    optixcfg->hitgroupRecordsBuffer.alloc_and_upload(hitgroupRecords);
mmc_optix_utils.cpp:1516:    optixcfg->sbt.hitgroupRecordBase =
mmc_optix_utils.cpp:1517:        optixcfg->hitgroupRecordsBuffer.d_pointer();
mmc_optix_utils.cpp:1518:    optixcfg->sbt.hitgroupRecordStrideInBytes = sizeof(HitgroupRecord);
mmc_optix_utils.cpp:1519:    optixcfg->sbt.hitgroupRecordCount = (int)hitgroupRecords.size();
mmc_optix_utils.cpp:1527:    optixcfg->raygenRecordsBuffer.free();
mmc_optix_utils.cpp:1528:    optixcfg->missRecordsBuffer.free();
mmc_optix_utils.cpp:1529:    optixcfg->hitgroupRecordsBuffer.free();
mmc_optix_utils.cpp:1530:    optixcfg->launchParamsBuffer.free();
mmc_optix_utils.cpp:1531:    optixcfg->vertexBuffer.free();
mmc_optix_utils.cpp:1532:    optixcfg->indexBuffer.free();
mmc_optix_utils.cpp:1533:    optixcfg->fnormBuffer.free();
mmc_optix_utils.cpp:1534:    optixcfg->nbgashandleBuffer.free();
mmc_optix_utils.cpp:1535:    optixcfg->asBuffer.free();
mmc_optix_utils.cpp:1536:    optixcfg->seedBuffer.free();
mmc_optix_utils.cpp:1537:    optixcfg->outputBuffer.free();
mmc_optix_utils.cpp:1538:    free(optixcfg->outputHostBuffer);
makefile_logistic:5:USERCCFLAGS=-DMMC_LOGISTIC -DUSE_OS_TIMER
mexopts_cygwin64_gcc.bat:7:set COMPILER=x86_64-w64-mingw32-g++
mexopts_cygwin64_gcc.bat:8:set COMPFLAGS=-c -m64 -mwin32 -mdll -Wall -std=c++11 -DMATLAB_MEX_FILE
mexopts_cygwin64_gcc.bat:9:set OPTIMFLAGS=-DNDEBUG -O2
mexopts_cygwin64_gcc.bat:10:set DEBUGFLAGS=-g
mexopts_cygwin64_gcc.bat:11:set NAME_OBJECT=-o
mexopts_cygwin64_gcc.bat:13:set LINKER=x86_64-w64-mingw32-g++
mexopts_cygwin64_gcc.bat:14:set LINKFLAGS=-shared -L"%MATLAB%\extern\lib\win64\microsoft" -L"%MATLAB%\bin\win64"
mexopts_cygwin64_gcc.bat:15:set LINKFLAGSPOST=-lmx -lmex -lmat
mexopts_cygwin64_gcc.bat:16:set LINKOPTIMFLAGS=-O2
mexopts_cygwin64_gcc.bat:17:set LINKDEBUGFLAGS=-g
mexopts_cygwin64_gcc.bat:20:set NAME_OUTPUT=-o "%OUTDIR%%MEX_NAME%%MEX_EXT%"
cjson/README:29:It's like XML, but fat-free. You use it to move data around, store things, or just
cjson/README:37:gcc cJSON.c test.c -o test -lm
cjson/README:43:in one of two modes: Auto and Manual. Let's have a quick run-through.
cjson/README:71:	int framerate = cJSON_GetObjectItem(format,"frame rate")->valueint;
cjson/README:75:	cJSON_GetObjectItem(format,"frame rate")->valueint=25;
cjson/README:145:the root object, and traverse the structure (which is, formally, an N-tree),
cjson/README:153:		char *newprefix=malloc(strlen(prefix)+strlen(item->name)+2);
cjson/README:154:		sprintf(newprefix,"%s/%s",prefix,item->name);
cjson/README:155:		int dorecurse=callback(newprefix, item->type, item);
cjson/README:156:		if (item->child && dorecurse) parse_and_callback(item->child,newprefix);
cjson/README:157:		item=item->next;
cjson/README:163:The 'dorecurse' flag would let the callback decide to handle sub-arrays on it's own, or
cjson/README:164:let you invoke it per-item. For the item above, your callback might look like this:
cjson/README:193:	cJSON *subitem=item->child;
cjson/README:197:		if (subitem->child) parse_object(subitem->child);
cjson/README:199:		subitem=subitem->next;
cjson/README:203:Of course, this should look familiar, since this is just a stripped-down version
cjson/README:204:of the callback-parser.
cjson/README:211:You can, of course, hand your sub-objects to other functions to populate.
cjson/README:222:		if (!i)	root->child=objects[i];
cjson/README:223:		else	prev->next=objects[i], objects[i]->prev=prev;
cjson/README:247:- Dave Gamble, Aug 2009
cjson/test.c:64:	int numbers[3][3]={{0,-1,0},{1,0,0},{0,0,1}};
cjson/test.c:69:		{"zip",37.7668,-1.223959e+2,"","SAN FRANCISCO","CA","94107","US"},
cjson/test.c:70:		{"zip",37.371991,-1.22026e+2,"","SUNNYVALE","CA","94085","US"}};
cjson/test.c:140:	char text3[]="[\n    [0, -1, 0],\n    [1, 0, 0],\n    [0, 0, 1]\n	]\n";
cjson/test.c:142:	char text5[]="[\n	 {\n	 \"precision\": \"zip\",\n	 \"Latitude\":  37.7668,\n	 \"Longitude\": -122.3959,\n	 \"Address\":   \"\",\n	 \"City\":      \"SAN FRANCISCO\",\n	 \"State\":     \"CA\",\n	 \"Zip\":       \"94107\",\n	 \"Country\":   \"US\"\n	 },\n	 {\n	 \"precision\": \"zip\",\n	 \"Latitude\":  37.371991,\n	 \"Longitude\": -122.026020,\n	 \"Address\":   \"\",\n	 \"City\":      \"SUNNYVALE\",\n	 \"State\":     \"CA\",\n	 \"Zip\":       \"94085\",\n	 \"Country\":   \"US\"\n	 }\n	 ]";
cjson/cJSON.h:2:  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors
cjson/cJSON.h:39:CJSON_HIDE_SYMBOLS - Define this in the case where you don't want to ever dllexport symbols
cjson/cJSON.h:40:CJSON_EXPORT_SYMBOLS - Define this on library build when you want to dllexport symbols (default)
cjson/cJSON.h:41:CJSON_IMPORT_SYMBOLS - Define this if you want to dllimport symbol
cjson/cJSON.h:46:-fvisibility=hidden (for gcc)
cjson/cJSON.h:48:-xldscope=hidden (for sun cc)
cjson/cJSON.h:227: * WARNING: When this function was used, make sure to always check that (item->type & cJSON_StringIsConst) is zero before
cjson/cJSON.h:228: * writing to `item->string` */
cjson/cJSON.h:244:CJSON_PUBLIC(void) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem); /* Shifts pre-existing items to the right. */
cjson/cJSON.h:254: * The item->next and ->prev pointers are always zero on return from Duplicate. */
cjson/cJSON.h:260: * The input pointer json cannot point to a read-only address area, such as a string constant, 
cjson/cJSON.h:277:#define cJSON_SetIntValue(object, number) ((object) ? (object)->valueint = (object)->valuedouble = (number) : (number))
cjson/cJSON.h:283:#define cJSON_ArrayForEach(element, array) for(element = (array != NULL) ? (array)->child : NULL; element != NULL; element = element->next)
cjson/cJSON.c:2:  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors
cjson/cJSON.c:87:    return item->valuestring;
cjson/cJSON.c:90:/* This is a safeguard to prevent copy-pasters from using incompatible C and header files */
cjson/cJSON.c:124:    return tolower(*string1) - tolower(*string2);
cjson/cJSON.c:155:#define static_strlen(string_literal) (sizeof(string_literal) - sizeof(""))
cjson/cJSON.c:170:    copy = (unsigned char*)hooks->allocate(length);
cjson/cJSON.c:192:    if (hooks->malloc_fn != NULL)
cjson/cJSON.c:194:        global_hooks.allocate = hooks->malloc_fn;
cjson/cJSON.c:198:    if (hooks->free_fn != NULL)
cjson/cJSON.c:200:        global_hooks.deallocate = hooks->free_fn;
cjson/cJSON.c:214:    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));
cjson/cJSON.c:229:        next = item->next;
cjson/cJSON.c:230:        if (!(item->type & cJSON_IsReference) && (item->child != NULL))
cjson/cJSON.c:232:            cJSON_Delete(item->child);
cjson/cJSON.c:234:        if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))
cjson/cJSON.c:236:            global_hooks.deallocate(item->valuestring);
cjson/cJSON.c:238:        if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
cjson/cJSON.c:240:            global_hooks.deallocate(item->string);
cjson/cJSON.c:252:    return (unsigned char) lconv->decimal_point[0];
cjson/cJSON.c:268:#define can_read(buffer, size) ((buffer != NULL) && (((buffer)->offset + size) <= (buffer)->length))
cjson/cJSON.c:270:#define can_access_at_index(buffer, index) ((buffer != NULL) && (((buffer)->offset + index) < (buffer)->length))
cjson/cJSON.c:273:#define buffer_at_offset(buffer) ((buffer)->content + (buffer)->offset)
cjson/cJSON.c:284:    if ((input_buffer == NULL) || (input_buffer->content == NULL))
cjson/cJSON.c:292:    for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++)
cjson/cJSON.c:307:            case '-':
cjson/cJSON.c:330:    item->valuedouble = number;
cjson/cJSON.c:335:        item->valueint = INT_MAX;
cjson/cJSON.c:339:        item->valueint = INT_MIN;
cjson/cJSON.c:343:        item->valueint = (int)number;
cjson/cJSON.c:346:    item->type = cJSON_Number;
cjson/cJSON.c:348:    input_buffer->offset += (size_t)(after_end - number_c_string);
cjson/cJSON.c:357:        object->valueint = INT_MAX;
cjson/cJSON.c:361:        object->valueint = INT_MIN;
cjson/cJSON.c:365:        object->valueint = (int)number;
cjson/cJSON.c:368:    return object->valuedouble = number;
cjson/cJSON.c:388:    if ((p == NULL) || (p->buffer == NULL))
cjson/cJSON.c:393:    if ((p->length > 0) && (p->offset >= p->length))
cjson/cJSON.c:405:    needed += p->offset + 1;
cjson/cJSON.c:406:    if (needed <= p->length)
cjson/cJSON.c:408:        return p->buffer + p->offset;
cjson/cJSON.c:411:    if (p->noalloc) {
cjson/cJSON.c:433:    if (p->hooks.reallocate != NULL)
cjson/cJSON.c:436:        newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);
cjson/cJSON.c:439:            p->hooks.deallocate(p->buffer);
cjson/cJSON.c:440:            p->length = 0;
cjson/cJSON.c:441:            p->buffer = NULL;
cjson/cJSON.c:449:        newbuffer = (unsigned char*)p->hooks.allocate(newsize);
cjson/cJSON.c:452:            p->hooks.deallocate(p->buffer);
cjson/cJSON.c:453:            p->length = 0;
cjson/cJSON.c:454:            p->buffer = NULL;
cjson/cJSON.c:460:            memcpy(newbuffer, p->buffer, p->offset + 1);
cjson/cJSON.c:462:        p->hooks.deallocate(p->buffer);
cjson/cJSON.c:464:    p->length = newsize;
cjson/cJSON.c:465:    p->buffer = newbuffer;
cjson/cJSON.c:467:    return newbuffer + p->offset;
cjson/cJSON.c:474:    if ((buffer == NULL) || (buffer->buffer == NULL))
cjson/cJSON.c:478:    buffer_pointer = buffer->buffer + buffer->offset;
cjson/cJSON.c:480:    buffer->offset += strlen((const char*)buffer_pointer);
cjson/cJSON.c:483:/* securely comparison of floating-point variables */
cjson/cJSON.c:486:    return (fabs(a - b) <= CJSON_DOUBLE_PRECISION);
cjson/cJSON.c:493:    double d = item->valuedouble;
cjson/cJSON.c:524:    if ((length < 0) || (length > (int)(sizeof(number_buffer) - 1)))
cjson/cJSON.c:550:    output_buffer->offset += (size_t)length;
cjson/cJSON.c:566:            h += (unsigned int) input[i] - '0';
cjson/cJSON.c:570:            h += (unsigned int) 10 + input[i] - 'A';
cjson/cJSON.c:574:            h += (unsigned int) 10 + input[i] - 'a';
cjson/cJSON.c:591:/* converts a UTF-16 literal to UTF-8
cjson/cJSON.c:603:    if ((input_end - first_sequence) < 6)
cjson/cJSON.c:625:        if ((input_end - second_sequence) < 6)
cjson/cJSON.c:656:    /* encode as UTF-8
cjson/cJSON.c:689:    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
cjson/cJSON.c:731:        while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\"'))
cjson/cJSON.c:736:                if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length)
cjson/cJSON.c:746:        if (((size_t)(input_end - input_buffer->content) >= input_buffer->length) || (*input_end != '\"'))
cjson/cJSON.c:752:        allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;
cjson/cJSON.c:753:        output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(""));
cjson/cJSON.c:772:            if ((input_end - input_pointer) < 1)
cjson/cJSON.c:800:                /* UTF-16 literal */
cjson/cJSON.c:805:                        /* failed to convert UTF16-literal to UTF-8 */
cjson/cJSON.c:820:    item->type = cJSON_String;
cjson/cJSON.c:821:    item->valuestring = (char*)output;
cjson/cJSON.c:823:    input_buffer->offset = (size_t) (input_end - input_buffer->content);
cjson/cJSON.c:824:    input_buffer->offset++;
cjson/cJSON.c:831:        input_buffer->hooks.deallocate(output);
cjson/cJSON.c:836:        input_buffer->offset = (size_t)(input_pointer - input_buffer->content);
cjson/cJSON.c:888:                    /* UTF-16 escape sequence uXXXX */
cjson/cJSON.c:894:    output_length = (size_t)(input_pointer - input) + escape_characters;
cjson/cJSON.c:967:    return print_string_ptr((unsigned char*)item->valuestring, p);
cjson/cJSON.c:981:    if ((buffer == NULL) || (buffer->content == NULL))
cjson/cJSON.c:988:       buffer->offset++;
cjson/cJSON.c:991:    if (buffer->offset == buffer->length)
cjson/cJSON.c:993:        buffer->offset--;
cjson/cJSON.c:999:/* skip the UTF-8 BOM (byte order mark) if it is at the beginning of a buffer */
cjson/cJSON.c:1002:    if ((buffer == NULL) || (buffer->content == NULL) || (buffer->offset != 0))
cjson/cJSON.c:1009:        buffer->offset += 3;
cjson/cJSON.c:1015:/* Parse an object - create a new root, and populate. */
cjson/cJSON.c:1047:    /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
cjson/cJSON.c:1081:            local_error.position = buffer.length - 1;
cjson/cJSON.c:1112:    buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);
cjson/cJSON.c:1113:    buffer->length = default_buffer_size;
cjson/cJSON.c:1114:    buffer->format = format;
cjson/cJSON.c:1115:    buffer->hooks = *hooks;
cjson/cJSON.c:1116:    if (buffer->buffer == NULL)
cjson/cJSON.c:1129:    if (hooks->reallocate != NULL)
cjson/cJSON.c:1131:        printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->offset + 1);
cjson/cJSON.c:1135:        buffer->buffer = NULL;
cjson/cJSON.c:1139:        printed = (unsigned char*) hooks->allocate(buffer->offset + 1);
cjson/cJSON.c:1144:        memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));
cjson/cJSON.c:1145:        printed[buffer->offset] = '\0'; /* just to be sure */
cjson/cJSON.c:1148:        hooks->deallocate(buffer->buffer);
cjson/cJSON.c:1154:    if (buffer->buffer != NULL)
cjson/cJSON.c:1156:        hooks->deallocate(buffer->buffer);
cjson/cJSON.c:1161:        hooks->deallocate(printed);
cjson/cJSON.c:1227:/* Parser core - when encountering text, process appropriately. */
cjson/cJSON.c:1230:    if ((input_buffer == NULL) || (input_buffer->content == NULL))
cjson/cJSON.c:1239:        item->type = cJSON_NULL;
cjson/cJSON.c:1240:        input_buffer->offset += 4;
cjson/cJSON.c:1246:        item->type = cJSON_False;
cjson/cJSON.c:1247:        input_buffer->offset += 5;
cjson/cJSON.c:1253:        item->type = cJSON_True;
cjson/cJSON.c:1254:        item->valueint = 1;
cjson/cJSON.c:1255:        input_buffer->offset += 4;
cjson/cJSON.c:1264:    if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))
cjson/cJSON.c:1292:    switch ((item->type) & 0xFF)
cjson/cJSON.c:1327:            if (item->valuestring == NULL)
cjson/cJSON.c:1332:            raw_length = strlen(item->valuestring) + sizeof("");
cjson/cJSON.c:1338:            memcpy(output, item->valuestring, raw_length);
cjson/cJSON.c:1362:    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
cjson/cJSON.c:1366:    input_buffer->depth++;
cjson/cJSON.c:1374:    input_buffer->offset++;
cjson/cJSON.c:1385:        input_buffer->offset--;
cjson/cJSON.c:1390:    input_buffer->offset--;
cjson/cJSON.c:1395:        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
cjson/cJSON.c:1410:            current_item->next = new_item;
cjson/cJSON.c:1411:            new_item->prev = current_item;
cjson/cJSON.c:1416:        input_buffer->offset++;
cjson/cJSON.c:1432:    input_buffer->depth--;
cjson/cJSON.c:1434:    item->type = cJSON_Array;
cjson/cJSON.c:1435:    item->child = head;
cjson/cJSON.c:1437:    input_buffer->offset++;
cjson/cJSON.c:1455:    cJSON *current_element = item->child;
cjson/cJSON.c:1471:    output_buffer->offset++;
cjson/cJSON.c:1472:    output_buffer->depth++;
cjson/cJSON.c:1481:        if (current_element->next)
cjson/cJSON.c:1483:            length = (size_t) (output_buffer->format ? 2 : 1);
cjson/cJSON.c:1490:            if(output_buffer->format)
cjson/cJSON.c:1495:            output_buffer->offset += length;
cjson/cJSON.c:1497:        current_element = current_element->next;
cjson/cJSON.c:1507:    output_buffer->depth--;
cjson/cJSON.c:1518:    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
cjson/cJSON.c:1522:    input_buffer->depth++;
cjson/cJSON.c:1529:    input_buffer->offset++;
cjson/cJSON.c:1539:        input_buffer->offset--;
cjson/cJSON.c:1544:    input_buffer->offset--;
cjson/cJSON.c:1549:        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
cjson/cJSON.c:1564:            current_item->next = new_item;
cjson/cJSON.c:1565:            new_item->prev = current_item;
cjson/cJSON.c:1570:        input_buffer->offset++;
cjson/cJSON.c:1579:        current_item->string = current_item->valuestring;
cjson/cJSON.c:1580:        current_item->valuestring = NULL;
cjson/cJSON.c:1588:        input_buffer->offset++;
cjson/cJSON.c:1604:    input_buffer->depth--;
cjson/cJSON.c:1606:    item->type = cJSON_Object;
cjson/cJSON.c:1607:    item->child = head;
cjson/cJSON.c:1609:    input_buffer->offset++;
cjson/cJSON.c:1626:    cJSON *current_item = item->child;
cjson/cJSON.c:1634:    length = (size_t) (output_buffer->format ? 2 : 1); /* fmt: {\n */
cjson/cJSON.c:1642:    output_buffer->depth++;
cjson/cJSON.c:1643:    if (output_buffer->format)
cjson/cJSON.c:1647:    output_buffer->offset += length;
cjson/cJSON.c:1651:        if (output_buffer->format)
cjson/cJSON.c:1654:            output_pointer = ensure(output_buffer, output_buffer->depth);
cjson/cJSON.c:1659:            for (i = 0; i < output_buffer->depth; i++)
cjson/cJSON.c:1663:            output_buffer->offset += output_buffer->depth;
cjson/cJSON.c:1667:        if (!print_string_ptr((unsigned char*)current_item->string, output_buffer))
cjson/cJSON.c:1673:        length = (size_t) (output_buffer->format ? 2 : 1);
cjson/cJSON.c:1680:        if (output_buffer->format)
cjson/cJSON.c:1684:        output_buffer->offset += length;
cjson/cJSON.c:1694:        length = ((size_t)(output_buffer->format ? 1 : 0) + (size_t)(current_item->next ? 1 : 0));
cjson/cJSON.c:1700:        if (current_item->next)
cjson/cJSON.c:1705:        if (output_buffer->format)
cjson/cJSON.c:1710:        output_buffer->offset += length;
cjson/cJSON.c:1712:        current_item = current_item->next;
cjson/cJSON.c:1715:    output_pointer = ensure(output_buffer, output_buffer->format ? (output_buffer->depth + 1) : 2);
cjson/cJSON.c:1720:    if (output_buffer->format)
cjson/cJSON.c:1723:        for (i = 0; i < (output_buffer->depth - 1); i++)
cjson/cJSON.c:1730:    output_buffer->depth--;
cjson/cJSON.c:1746:    child = array->child;
cjson/cJSON.c:1751:        child = child->next;
cjson/cJSON.c:1768:    current_child = array->child;
cjson/cJSON.c:1771:        index--;
cjson/cJSON.c:1772:        current_child = current_child->next;
cjson/cJSON.c:1797:    current_element = object->child;
cjson/cJSON.c:1800:        while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))
cjson/cJSON.c:1802:            current_element = current_element->next;
cjson/cJSON.c:1807:        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
cjson/cJSON.c:1809:            current_element = current_element->next;
cjson/cJSON.c:1813:    if ((current_element == NULL) || (current_element->string == NULL)) {
cjson/cJSON.c:1838:    prev->next = item;
cjson/cJSON.c:1839:    item->prev = prev;
cjson/cJSON.c:1858:    reference->string = NULL;
cjson/cJSON.c:1859:    reference->type |= cJSON_IsReference;
cjson/cJSON.c:1860:    reference->next = reference->prev = NULL;
cjson/cJSON.c:1873:    child = array->child;
cjson/cJSON.c:1878:        array->child = item;
cjson/cJSON.c:1883:        while (child->next)
cjson/cJSON.c:1885:            child = child->next;
cjson/cJSON.c:1903:#pragma GCC diagnostic ignored "-Wcast-qual"
cjson/cJSON.c:1928:        new_type = item->type | cJSON_StringIsConst;
cjson/cJSON.c:1938:        new_type = item->type & ~cJSON_StringIsConst;
cjson/cJSON.c:1941:    if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
cjson/cJSON.c:1943:        hooks->deallocate(item->string);
cjson/cJSON.c:1946:    item->string = new_key;
cjson/cJSON.c:1947:    item->type = new_type;
cjson/cJSON.c:2098:    if (item->prev != NULL)
cjson/cJSON.c:2101:        item->prev->next = item->next;
cjson/cJSON.c:2103:    if (item->next != NULL)
cjson/cJSON.c:2106:        item->next->prev = item->prev;
cjson/cJSON.c:2109:    if (item == parent->child)
cjson/cJSON.c:2112:        parent->child = item->next;
cjson/cJSON.c:2115:    item->prev = NULL;
cjson/cJSON.c:2116:    item->next = NULL;
cjson/cJSON.c:2177:    newitem->next = after_inserted;
cjson/cJSON.c:2178:    newitem->prev = after_inserted->prev;
cjson/cJSON.c:2179:    after_inserted->prev = newitem;
cjson/cJSON.c:2180:    if (after_inserted == array->child)
cjson/cJSON.c:2182:        array->child = newitem;
cjson/cJSON.c:2186:        newitem->prev->next = newitem;
cjson/cJSON.c:2202:    replacement->next = item->next;
cjson/cJSON.c:2203:    replacement->prev = item->prev;
cjson/cJSON.c:2205:    if (replacement->next != NULL)
cjson/cJSON.c:2207:        replacement->next->prev = replacement;
cjson/cJSON.c:2209:    if (replacement->prev != NULL)
cjson/cJSON.c:2211:        replacement->prev->next = replacement;
cjson/cJSON.c:2213:    if (parent->child == item)
cjson/cJSON.c:2215:        parent->child = replacement;
cjson/cJSON.c:2218:    item->next = NULL;
cjson/cJSON.c:2219:    item->prev = NULL;
cjson/cJSON.c:2243:    if (!(replacement->type & cJSON_StringIsConst) && (replacement->string != NULL))
cjson/cJSON.c:2245:        cJSON_free(replacement->string);
cjson/cJSON.c:2247:    replacement->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
cjson/cJSON.c:2248:    replacement->type &= ~cJSON_StringIsConst;
cjson/cJSON.c:2271:        item->type = cJSON_NULL;
cjson/cJSON.c:2282:        item->type = cJSON_True;
cjson/cJSON.c:2293:        item->type = cJSON_False;
cjson/cJSON.c:2304:        item->type = boolean ? cJSON_True : cJSON_False;
cjson/cJSON.c:2315:        item->type = cJSON_Number;
cjson/cJSON.c:2316:        item->valuedouble = num;
cjson/cJSON.c:2321:            item->valueint = INT_MAX;
cjson/cJSON.c:2325:            item->valueint = INT_MIN;
cjson/cJSON.c:2329:            item->valueint = (int)num;
cjson/cJSON.c:2341:        item->type = cJSON_String;
cjson/cJSON.c:2342:        item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
cjson/cJSON.c:2343:        if(!item->valuestring)
cjson/cJSON.c:2358:        item->type = cJSON_String | cJSON_IsReference;
cjson/cJSON.c:2359:        item->valuestring = (char*)cast_away_const(string);
cjson/cJSON.c:2369:        item->type = cJSON_Object | cJSON_IsReference;
cjson/cJSON.c:2370:        item->child = (cJSON*)cast_away_const(child);
cjson/cJSON.c:2379:        item->type = cJSON_Array | cJSON_IsReference;
cjson/cJSON.c:2380:        item->child = (cJSON*)cast_away_const(child);
cjson/cJSON.c:2391:        item->type = cJSON_Raw;
cjson/cJSON.c:2392:        item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);
cjson/cJSON.c:2393:        if(!item->valuestring)
cjson/cJSON.c:2408:        item->type=cJSON_Array;
cjson/cJSON.c:2419:        item->type = cJSON_Object;
cjson/cJSON.c:2449:            a->child = n;
cjson/cJSON.c:2485:            a->child = n;
cjson/cJSON.c:2521:            a->child = n;
cjson/cJSON.c:2557:            a->child = n;
cjson/cJSON.c:2589:    newitem->type = item->type & (~cJSON_IsReference);
cjson/cJSON.c:2590:    newitem->valueint = item->valueint;
cjson/cJSON.c:2591:    newitem->valuedouble = item->valuedouble;
cjson/cJSON.c:2592:    if (item->valuestring)
cjson/cJSON.c:2594:        newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);
cjson/cJSON.c:2595:        if (!newitem->valuestring)
cjson/cJSON.c:2600:    if (item->string)
cjson/cJSON.c:2602:        newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);
cjson/cJSON.c:2603:        if (!newitem->string)
cjson/cJSON.c:2608:    /* If non-recursive, then we're done! */
cjson/cJSON.c:2613:    /* Walk the ->next chain for the child. */
cjson/cJSON.c:2614:    child = item->child;
cjson/cJSON.c:2617:        newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */
cjson/cJSON.c:2624:            /* If newitem->child already set, then crosswire ->prev and ->next and move on */
cjson/cJSON.c:2625:            next->next = newchild;
cjson/cJSON.c:2626:            newchild->prev = next;
cjson/cJSON.c:2631:            /* Set newitem->child and move to it */
cjson/cJSON.c:2632:            newitem->child = newchild;
cjson/cJSON.c:2635:        child = child->next;
cjson/cJSON.c:2742:    /* and null-terminate. */
cjson/cJSON.c:2753:    return (item->type & 0xFF) == cJSON_Invalid;
cjson/cJSON.c:2763:    return (item->type & 0xFF) == cJSON_False;
cjson/cJSON.c:2773:    return (item->type & 0xff) == cJSON_True;
cjson/cJSON.c:2784:    return (item->type & (cJSON_True | cJSON_False)) != 0;
cjson/cJSON.c:2793:    return (item->type & 0xFF) == cJSON_NULL;
cjson/cJSON.c:2803:    return (item->type & 0xFF) == cJSON_Number;
cjson/cJSON.c:2813:    return (item->type & 0xFF) == cJSON_String;
cjson/cJSON.c:2823:    return (item->type & 0xFF) == cJSON_Array;
cjson/cJSON.c:2833:    return (item->type & 0xFF) == cJSON_Object;
cjson/cJSON.c:2843:    return (item->type & 0xFF) == cJSON_Raw;
cjson/cJSON.c:2848:    if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)) || cJSON_IsInvalid(a))
cjson/cJSON.c:2854:    switch (a->type & 0xFF)
cjson/cJSON.c:2876:    switch (a->type & 0xFF)
cjson/cJSON.c:2885:            if (compare_double(a->valuedouble, b->valuedouble))
cjson/cJSON.c:2893:            if ((a->valuestring == NULL) || (b->valuestring == NULL))
cjson/cJSON.c:2897:            if (strcmp(a->valuestring, b->valuestring) == 0)
cjson/cJSON.c:2906:            cJSON *a_element = a->child;
cjson/cJSON.c:2907:            cJSON *b_element = b->child;
cjson/cJSON.c:2916:                a_element = a_element->next;
cjson/cJSON.c:2917:                b_element = b_element->next;
cjson/cJSON.c:2935:                b_element = get_object_item(b, a_element->string, case_sensitive);
cjson/cJSON.c:2951:                a_element = get_object_item(a, b_element->string, case_sensitive);
mmc_cl_host.c:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_cl_host.c:5:**  \copyright Qianqian Fang, 2010-2021
mmc_cl_host.c:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_cl_host.c:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_cl_host.c:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_cl_host.c:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_cl_host.c:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_cl_host.c:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_cl_host.c:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_cl_host.c:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_cl_host.c:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_cl_host.c:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_cl_host.c:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_cl_host.c:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_cl_host.c:46:#define IPARAM_TO_MACRO(macro,a,b) sprintf(macro+strlen(macro)," -Dgcfg%s=%u ",    #b,(a.b))
mmc_cl_host.c:47:#define FPARAM_TO_MACRO(macro,a,b) sprintf(macro+strlen(macro)," -Dgcfg%s=%.10ef ",#b,(a.b))
mmc_cl_host.c:52:tetrahedral mesh (mesh) and the ray-tracer precomputed data (tracer).
mmc_cl_host.c:55:const char* sourceflag[] = {"-DMCX_SRC_PENCIL", "-DMCX_SRC_ISOTROPIC", "-DMCX_SRC_CONE",
mmc_cl_host.c:56:                            "-DMCX_SRC_GAUSSIAN", "-DMCX_SRC_PLANAR", "-DMCX_SRC_PATTERN", "-DMCX_SRC_FOURIER",
mmc_cl_host.c:57:                            "-DMCX_SRC_ARCSINE", "-DMCX_SRC_DISK", "-DMCX_SRC_FOURIERX", "-DMCX_SRC_FOURIERX2D",
mmc_cl_host.c:58:                            "-DMCX_SRC_ZGAUSSIAN", "-DMCX_SRC_LINE", "-DMCX_SRC_SLIT", "-DMCX_SRC_PENCILARRAY",
mmc_cl_host.c:59:                            "-DMCX_SRC_PATTERN3D"
mmc_cl_host.c:91:    cl_mem* gproperty = NULL, *gparam = NULL, *gsrcpattern = NULL, *greplayweight = NULL, *greplaytime = NULL, *greplayseed = NULL; /*read-only buffers*/
mmc_cl_host.c:92:    cl_mem* gweight, *gdref, *gdetphoton, *gseed, *genergy, *greporter;     /*read-write buffers*/
mmc_cl_host.c:93:    cl_mem* gprogress = NULL, *gdetected = NULL, *gphotonseed = NULL; /*write-only buffers*/
mmc_cl_host.c:95:    cl_uint meshlen = ((cfg->method == rtBLBadouelGrid) ? cfg->crop0.z : mesh->ne) << cfg->nbuffer; // use 4 copies to reduce racing
mmc_cl_host.c:96:    cfg->crop0.w = meshlen * cfg->maxgate; // offset for the second buffer
mmc_cl_host.c:104:    cl_uint detreclen = (2 + ((cfg->ismomentum) > 0)) * mesh->prop + (cfg->issaveexit > 0) * 6 + 1;
mmc_cl_host.c:109:    MCXParam param = {{{cfg->srcpos.x, cfg->srcpos.y, cfg->srcpos.z}}, {{cfg->srcdir.x, cfg->srcdir.y, cfg->srcdir.z}},
mmc_cl_host.c:110:        cfg->tstart, cfg->tend, (uint)cfg->isreflect, (uint)cfg->issavedet, (uint)cfg->issaveexit,
mmc_cl_host.c:111:        (uint)cfg->ismomentum, (uint)cfg->isatomic, (uint)cfg->isspecular, 1.f / cfg->tstep, cfg->minenergy,
mmc_cl_host.c:112:        cfg->maxdetphoton, mesh->prop, cfg->detnum, (uint)cfg->voidtime, (uint)cfg->srctype,
mmc_cl_host.c:113:        {{cfg->srcparam1.x, cfg->srcparam1.y, cfg->srcparam1.z, cfg->srcparam1.w}},
mmc_cl_host.c:114:        {{cfg->srcparam2.x, cfg->srcparam2.y, cfg->srcparam2.z, cfg->srcparam2.w}},
mmc_cl_host.c:115:        cfg->issaveref, cfg->maxgate, (uint)cfg->debuglevel, detreclen, cfg->outputtype, mesh->elemlen,
mmc_cl_host.c:116:        cfg->mcmethod, cfg->method, 1.f / cfg->steps.x,
mmc_cl_host.c:118:        cfg->srcdir.w,
mmc_cl_host.c:122:        mesh->nn, mesh->ne, mesh->nf, {{mesh->nmin.x, mesh->nmin.y, mesh->nmin.z}}, cfg->nout,
mmc_cl_host.c:123:        cfg->roulettesize, cfg->srcnum, {{cfg->crop0.x, cfg->crop0.y, cfg->crop0.z, cfg->crop0.w}},
mmc_cl_host.c:124:        mesh->srcelemlen, {{cfg->bary0.x, cfg->bary0.y, cfg->bary0.z, cfg->bary0.w}},
mmc_cl_host.c:125:        cfg->e0, cfg->isextdet, meshlen, cfg->nbuffer, (mesh->prop + 1 + cfg->isextdet) + cfg->detnum,
mmc_cl_host.c:126:        (MIN((MAX_PROP - param.maxpropdet), ((mesh->ne) << 2)) >> 2), /*max count of elem normal data in const mem*/
mmc_cl_host.c:127:        cfg->issaveseed, cfg->seed
mmc_cl_host.c:134:        cfg->debuglevel = cfg->debuglevel & (~MCX_DEBUG_PROGRESS);
mmc_cl_host.c:142:        mcx_error(-99, (char*)("Unable to find devices!"), __FILE__, __LINE__);
mmc_cl_host.c:187:        if (!cfg->autopilot) {
mmc_cl_host.c:188:            gpu[i].autothread = cfg->nthread;
mmc_cl_host.c:189:            gpu[i].autoblock = cfg->nblocksize;
mmc_cl_host.c:190:            gpu[i].maxgate = cfg->maxgate;
mmc_cl_host.c:195:                gpu[i].autothread = gpu[i].autoblock * 7 * gpu[i].sm; // 7 thread x SIMD-16 per Exec Unit (EU)
mmc_cl_host.c:218:            int needmem = meshlen + gpu[i].autothread * sizeof(float4) * 4 + sizeof(float) * cfg->maxdetphoton * hostdetreclen + 10 * 1024 * 1024; /*keep 10M for other things*/
mmc_cl_host.c:219:            gpu[i].maxgate = (gpu[i].globalmem - needmem) / meshlen;
mmc_cl_host.c:220:            gpu[i].maxgate = MIN(((cfg->tend - cfg->tstart) / cfg->tstep + 0.5), gpu[i].maxgate);
mmc_cl_host.c:224:    cfg->maxgate = (int)((cfg->tend - cfg->tstart) / cfg->tstep + 0.5);
mmc_cl_host.c:225:    param.maxgate = cfg->maxgate;
mmc_cl_host.c:226:    cl_uint nflen = mesh->nf * cfg->maxgate;
mmc_cl_host.c:231:        fullload += cfg->workload[i];
mmc_cl_host.c:236:            cfg->workload[i] = gpu[i].core;
mmc_cl_host.c:242:    field = (cl_float*)calloc(sizeof(cl_float) * meshlen * 2, cfg->maxgate);
mmc_cl_host.c:243:    dref = (cl_float*)calloc(sizeof(cl_float) * mesh->nf, cfg->maxgate);
mmc_cl_host.c:244:    Pdet = (float*)calloc(cfg->maxdetphoton * sizeof(float), hostdetreclen);
mmc_cl_host.c:246:    if (cfg->issaveseed) {
mmc_cl_host.c:247:        Pphotonseed = (RandType*)calloc(cfg->maxdetphoton, (sizeof(RandType) * RAND_BUF_LEN));
mmc_cl_host.c:250:    fieldlen = meshlen * cfg->maxgate;
mmc_cl_host.c:252:    if (cfg->seed > 0) {
mmc_cl_host.c:253:        srand(cfg->seed);
mmc_cl_host.c:274:    memcpy(propdet, mesh->med, (mesh->prop + 1 + cfg->isextdet)*sizeof(medium));
mmc_cl_host.c:276:    if (cfg->detpos && cfg->detnum) {
mmc_cl_host.c:277:        memcpy(propdet + (mesh->prop + 1 + cfg->isextdet), cfg->detpos, cfg->detnum * sizeof(float4));
mmc_cl_host.c:280:    memcpy(propdet + param.maxpropdet, tracer->n, (param.normbuf << 2)*sizeof(float4));
mmc_cl_host.c:283:        OCL_ASSERT(((gnode[i] = clCreateBuffer(mcxcontext, RO_MEM, sizeof(float3) * (mesh->nn), mesh->node, &status), status)));
mmc_cl_host.c:284:        OCL_ASSERT(((gelem[i] = clCreateBuffer(mcxcontext, RO_MEM, sizeof(int4) * (mesh->ne), mesh->elem, &status), status)));
mmc_cl_host.c:285:        OCL_ASSERT(((gtype[i] = clCreateBuffer(mcxcontext, RO_MEM, sizeof(int) * (mesh->ne), mesh->type, &status), status)));
mmc_cl_host.c:286:        OCL_ASSERT(((gfacenb[i] = clCreateBuffer(mcxcontext, RO_MEM, sizeof(int4) * (mesh->ne), mesh->facenb, &status), status)));
mmc_cl_host.c:288:        if (mesh->srcelemlen > 0) {
mmc_cl_host.c:289:            OCL_ASSERT(((gsrcelem[i] = clCreateBuffer(mcxcontext, RO_MEM, sizeof(int) * (mesh->srcelemlen), mesh->srcelem, &status), status)));
mmc_cl_host.c:294:        OCL_ASSERT(((gnormal[i] = clCreateBuffer(mcxcontext, RO_MEM, sizeof(float4) * (mesh->ne) * 4, tracer->n, &status), status)));
mmc_cl_host.c:309:        OCL_ASSERT(((gdetphoton[i] = clCreateBuffer(mcxcontext, RW_MEM, sizeof(float) * cfg->maxdetphoton * hostdetreclen, Pdet, &status), status)));
mmc_cl_host.c:311:        if (cfg->issaveseed) {
mmc_cl_host.c:312:            OCL_ASSERT(((gphotonseed[i] = clCreateBuffer(mcxcontext, RW_MEM, cfg->maxdetphoton * (sizeof(RandType) * RAND_BUF_LEN), Pphotonseed, &status), status)));
mmc_cl_host.c:321:        if (cfg->srctype == MCX_SRC_PATTERN) {
mmc_cl_host.c:322:            OCL_ASSERT(((gsrcpattern[i] = clCreateBuffer(mcxcontext, RO_MEM, sizeof(float) * (int)(cfg->srcparam1.w * cfg->srcparam2.w), cfg->srcpattern, &status), status)));
mmc_cl_host.c:323:        } else if (cfg->srctype == MCX_SRC_PATTERN3D) {
mmc_cl_host.c:324:            OCL_ASSERT(((gsrcpattern[i] = clCreateBuffer(mcxcontext, RO_MEM, sizeof(float) * (int)(cfg->srcparam1.x * cfg->srcparam1.y * cfg->srcparam1.z), cfg->srcpattern, &status), status)));
mmc_cl_host.c:329:        if (cfg->seed == SEED_FROM_FILE) {
mmc_cl_host.c:330:            OCL_ASSERT(((greplayweight[i] = clCreateBuffer(mcxcontext, RO_MEM, sizeof(float) * cfg->nphoton, cfg->replayweight, &status), status)));
mmc_cl_host.c:331:            OCL_ASSERT(((greplaytime[i] = clCreateBuffer(mcxcontext, RO_MEM, sizeof(float) * cfg->nphoton, cfg->replaytime, &status), status)));
mmc_cl_host.c:332:            OCL_ASSERT(((greplayseed[i] = clCreateBuffer(mcxcontext, RO_MEM, (sizeof(RandType) * RAND_BUF_LEN) * cfg->nphoton, cfg->photonseed, &status), status)));
mmc_cl_host.c:349:    if (cfg->issavedet) {
mmc_cl_host.c:350:        MMC_FPRINTF(cfg->flog, "- variant name: [%s] compiled with OpenCL version [%d]\n",
mmc_cl_host.c:351:                    "MMC-OpenCL", CL_VERSION_1_0);
mmc_cl_host.c:353:        MMC_FPRINTF(cfg->flog, "- code name: [MMC-OpenCL] compiled with OpenCL version [%d]\n",
mmc_cl_host.c:357:    MMC_FPRINTF(cfg->flog, "- compiled with: [RNG] %s [Seed Length] %d\n", MCX_RNG_NAME, RAND_SEED_WORD_LEN);
mmc_cl_host.c:358:    MMC_FPRINTF(cfg->flog, "initializing streams ...\t");
mmc_cl_host.c:360:    MMC_FPRINTF(cfg->flog, "init complete : %d ms\n", GetTimeMillis() - tic);
mmc_cl_host.c:361:    fflush(cfg->flog);
mmc_cl_host.c:363:    OCL_ASSERT(((mcxprogram = clCreateProgramWithSource(mcxcontext, 1, (const char**) & (cfg->clsource), NULL, &status), status)));
mmc_cl_host.c:365:    if (cfg->optlevel >= 1) {
mmc_cl_host.c:366:        sprintf(opt, "%s ", "-cl-mad-enable -DMCX_USE_NATIVE");
mmc_cl_host.c:369:    if (cfg->optlevel >= 3) {
mmc_cl_host.c:370:        sprintf(opt + strlen(opt), "%s ", "-DMCX_SIMPLIFY_BRANCH -DMCX_VECTOR_INDEX");
mmc_cl_host.c:373:    if (cfg->optlevel >= 4) {
mmc_cl_host.c:374:        sprintf(opt + strlen(opt), "%s ", "-DUSE_MACRO_CONST");
mmc_cl_host.c:377:    if ((uint)cfg->srctype < sizeof(sourceflag) / sizeof(sourceflag[0])) {
mmc_cl_host.c:378:        sprintf(opt + strlen(opt), "%s ", sourceflag[(uint)cfg->srctype]);
mmc_cl_host.c:381:    sprintf(opt + strlen(opt), "%s ", cfg->compileropt);
mmc_cl_host.c:383:    if (cfg->isatomic) {
mmc_cl_host.c:384:        sprintf(opt + strlen(opt), " -DUSE_ATOMIC");
mmc_cl_host.c:387:    if (cfg->issave2pt == 0) {
mmc_cl_host.c:388:        sprintf(opt + strlen(opt), " -DMCX_SKIP_VOLUME");
mmc_cl_host.c:391:    if (cfg->issavedet) {
mmc_cl_host.c:392:        sprintf(opt + strlen(opt), " -DMCX_SAVE_DETECTORS");
mmc_cl_host.c:395:    if (cfg->issaveref) {
mmc_cl_host.c:396:        sprintf(opt + strlen(opt), " -DMCX_SAVE_DREF");
mmc_cl_host.c:399:    if (cfg->issaveseed) {
mmc_cl_host.c:400:        sprintf(opt + strlen(opt), " -DMCX_SAVE_SEED");
mmc_cl_host.c:403:    if (cfg->isreflect) {
mmc_cl_host.c:404:        sprintf(opt + strlen(opt), " -DMCX_DO_REFLECTION");
mmc_cl_host.c:407:    if (cfg->method == rtBLBadouelGrid) {
mmc_cl_host.c:408:        sprintf(opt + strlen(opt), " -DUSE_DMMC");
mmc_cl_host.c:411:    if (cfg->method == rtBLBadouel) {
mmc_cl_host.c:412:        sprintf(opt + strlen(opt), " -DUSE_BLBADOUEL");
mmc_cl_host.c:416:        sprintf(opt + strlen(opt), " -DUSE_NVIDIA_GPU");
mmc_cl_host.c:450:    MMC_FPRINTF(cfg->flog, "Building kernel with option: %s\n", opt);
mmc_cl_host.c:465:                MMC_FPRINTF(cfg->flog, "Kernel build log:\n%s\n", msg);
mmc_cl_host.c:473:        mcx_error(-(int)status, (char*)("Error: Failed to build program executable!"), __FILE__, __LINE__);
mmc_cl_host.c:476:    MMC_FPRINTF(cfg->flog, "build program complete : %d ms\n", GetTimeMillis() - tic);
mmc_cl_host.c:477:    fflush(cfg->flog);
mmc_cl_host.c:484:        threadphoton = (int)(cfg->nphoton * cfg->workload[i] / (fullload * gpu[i].autothread * cfg->respin));
mmc_cl_host.c:485:        oddphotons = (int)(cfg->nphoton * cfg->workload[i] / (fullload * cfg->respin) - threadphoton * gpu[i].autothread);
mmc_cl_host.c:487:        MMC_FPRINTF(cfg->flog, "- [device %d(%d): %s] threadph=%d oddphotons=%d np=%.1f nthread=%d nblock=%d repetition=%d\n", i, gpu[i].id, gpu[i].name, threadphoton, oddphotons,
mmc_cl_host.c:488:                    cfg->nphoton * cfg->workload[i] / fullload, (int)gpu[i].autothread, (int)gpu[i].autoblock, cfg->respin);
mmc_cl_host.c:494:        OCL_ASSERT((clSetKernelArg(mcxkernel[i], 3, cfg->issavedet ? sizeof(cl_float) * ((int)gpu[i].autoblock)*detreclen : sizeof(int), NULL)));
mmc_cl_host.c:517:    MMC_FPRINTF(cfg->flog, "set kernel arguments complete : %d ms %d\n", GetTimeMillis() - tic, param.method);
mmc_cl_host.c:518:    fflush(cfg->flog);
mmc_cl_host.c:520:    if (cfg->exportfield == NULL) {
mmc_cl_host.c:521:        cfg->exportfield = mesh->weight;
mmc_cl_host.c:524:    if (cfg->exportdetected == NULL) {
mmc_cl_host.c:525:        cfg->exportdetected = (float*)malloc(hostdetreclen * cfg->maxdetphoton * sizeof(float));
mmc_cl_host.c:528:    if (cfg->issaveseed && cfg->exportseed == NULL) {
mmc_cl_host.c:529:        cfg->exportseed = (unsigned char*)malloc(cfg->maxdetphoton * (sizeof(RandType) * RAND_BUF_LEN));
mmc_cl_host.c:532:    cfg->energytot = 0.f;
mmc_cl_host.c:533:    cfg->energyesc = 0.f;
mmc_cl_host.c:534:    cfg->runtime = 0;
mmc_cl_host.c:536:    //simulate for all time-gates in maxgate groups per run
mmc_cl_host.c:540:    for (t = cfg->tstart; t < cfg->tend; t += cfg->tstep * cfg->maxgate) {
mmc_cl_host.c:542:        twindow1 = t + cfg->tstep * cfg->maxgate;
mmc_cl_host.c:544:        MMC_FPRINTF(cfg->flog, "lauching mcx_main_loop for time window [%.1fns %.1fns] ...\n"
mmc_cl_host.c:546:        fflush(cfg->flog);
mmc_cl_host.c:549:        for (iter = 0; iter < cfg->respin; iter++) {
mmc_cl_host.c:550:            MMC_FPRINTF(cfg->flog, "simulation run#%2d ... \n", iter + 1);
mmc_cl_host.c:551:            fflush(cfg->flog);
mmc_cl_host.c:552:            fflush(cfg->flog);
mmc_cl_host.c:569:            if ((cfg->debuglevel & MCX_DEBUG_PROGRESS)) {
mmc_cl_host.c:570:                int p0 = 0, ndone = -1;
mmc_cl_host.c:572:                progressfun(-0.f, handle);
mmc_cl_host.c:585:                progressfun(cfg->nphoton, handle);
mmc_cl_host.c:586:                MMC_FPRINTF(cfg->flog, "\n");
mmc_cl_host.c:597:            toc += tic1 - tic0;
mmc_cl_host.c:598:            MMC_FPRINTF(cfg->flog, "kernel complete:  \t%d ms\nretrieving flux ... \t", tic1 - tic);
mmc_cl_host.c:599:            fflush(cfg->flog);
mmc_cl_host.c:601:            if (cfg->runtime < tic1 - tic) {
mmc_cl_host.c:602:                cfg->runtime = tic1 - tic;
mmc_cl_host.c:611:                if (cfg->issavedet) {
mmc_cl_host.c:614:                    OCL_ASSERT((clEnqueueReadBuffer(mcxqueue[devid], gdetphoton[devid], CL_TRUE, 0, sizeof(float)*cfg->maxdetphoton * hostdetreclen,
mmc_cl_host.c:617:                    if (cfg->issaveseed) {
mmc_cl_host.c:618:                        OCL_ASSERT((clEnqueueReadBuffer(mcxqueue[devid], gphotonseed[devid], CL_TRUE, 0, cfg->maxdetphoton * (sizeof(RandType)*RAND_BUF_LEN),
mmc_cl_host.c:622:                    if (detected > cfg->maxdetphoton) {
mmc_cl_host.c:623:                        MMC_FPRINTF(cfg->flog, "WARNING: the detected photon (%d) \
mmc_cl_host.c:624:is more than what your have specified (%d), please use the -H option to specify a greater number\t"
mmc_cl_host.c:625:                                    , detected, cfg->maxdetphoton);
mmc_cl_host.c:627:                        MMC_FPRINTF(cfg->flog, "detected %d photons, total: %d\t", detected, cfg->detectedcount + detected);
mmc_cl_host.c:630:                    cfg->his.detected += detected;
mmc_cl_host.c:631:                    detected = MIN(detected, cfg->maxdetphoton);
mmc_cl_host.c:633:                    if (cfg->exportdetected) {
mmc_cl_host.c:634:                        cfg->exportdetected = (float*)realloc(cfg->exportdetected, (cfg->detectedcount + detected) * hostdetreclen * sizeof(float));
mmc_cl_host.c:635:                        memcpy(cfg->exportdetected + cfg->detectedcount * (hostdetreclen), Pdet, detected * (hostdetreclen)*sizeof(float));
mmc_cl_host.c:637:                        if (cfg->issaveseed) {
mmc_cl_host.c:638:                            cfg->exportseed = (unsigned char*)realloc(cfg->exportseed, (cfg->detectedcount + detected) * (sizeof(RandType) * RAND_BUF_LEN));
mmc_cl_host.c:639:                            memcpy(cfg->exportseed + cfg->detectedcount * sizeof(RandType)*RAND_BUF_LEN, Pphotonseed, detected * (sizeof(RandType)*RAND_BUF_LEN));
mmc_cl_host.c:642:                        cfg->detectedcount += detected;
mmc_cl_host.c:646:                if (cfg->issaveref) {
mmc_cl_host.c:659:                if (cfg->issave2pt) {
mmc_cl_host.c:664:                    MMC_FPRINTF(cfg->flog, "transfer complete:        %d ms\n", GetTimeMillis() - tic);
mmc_cl_host.c:665:                    fflush(cfg->flog);
mmc_cl_host.c:668:                        field[(i >> cfg->nbuffer)] += rawfield[i] + rawfield[i + fieldlen];    //+rawfield[i+fieldlen];
mmc_cl_host.c:673:                    /*          if(cfg->respin>1){
mmc_cl_host.c:677:                                if(iter+1==cfg->respin){
mmc_cl_host.c:678:                                        if(cfg->respin>1)  //copy the accumulated fields back
mmc_cl_host.c:688:                        cfg->energyesc += energy[(i << 1)];
mmc_cl_host.c:689:                        cfg->energytot += energy[(i << 1) + 1];
mmc_cl_host.c:696:                if (cfg->respin > 1 && RAND_SEED_WORD_LEN > 1) {
mmc_cl_host.c:714:    fieldlen = (fieldlen >> cfg->nbuffer);
mmc_cl_host.c:717:    if (cfg->exportfield) {
mmc_cl_host.c:718:        if (cfg->basisorder == 0 || cfg->method == rtBLBadouelGrid) {
mmc_cl_host.c:720:                cfg->exportfield[i] += field[i];
mmc_cl_host.c:723:            for (i = 0; i < cfg->maxgate; i++)
mmc_cl_host.c:724:                for (j = 0; j < mesh->ne; j++) {
mmc_cl_host.c:725:                    float ww = field[i * mesh->ne + j] * 0.25f;
mmc_cl_host.c:728:                    for (k = 0; k < mesh->elemlen; k++) {
mmc_cl_host.c:729:                        cfg->exportfield[i * mesh->nn + mesh->elem[j * mesh->elemlen + k] - 1] += ww;
mmc_cl_host.c:735:    if (cfg->issaveref && mesh->dref) {
mmc_cl_host.c:737:            mesh->dref[i] += dref[i];
mmc_cl_host.c:741:    if (cfg->isnormalized) {
mmc_cl_host.c:742:        MMC_FPRINTF(cfg->flog, "normalizing raw data ...\t");
mmc_cl_host.c:743:        fflush(cfg->flog);
mmc_cl_host.c:745:        cfg->energyabs = cfg->energytot - cfg->energyesc;
mmc_cl_host.c:746:        mesh_normalize(mesh, cfg, cfg->energyabs, cfg->energytot, 0);
mmc_cl_host.c:749:    if (cfg->issave2pt && cfg->parentid == mpStandalone) {
mmc_cl_host.c:750:        MMC_FPRINTF(cfg->flog, "saving data to file ...\t");
mmc_cl_host.c:752:        MMC_FPRINTF(cfg->flog, "saving data complete : %d ms\n\n", GetTimeMillis() - tic);
mmc_cl_host.c:753:        fflush(cfg->flog);
mmc_cl_host.c:756:    if (cfg->issavedet && cfg->parentid == mpStandalone && cfg->exportdetected) {
mmc_cl_host.c:757:        cfg->his.unitinmm = cfg->unitinmm;
mmc_cl_host.c:758:        cfg->his.savedphoton = cfg->detectedcount;
mmc_cl_host.c:759:        cfg->his.detected = cfg->detectedcount;
mmc_cl_host.c:760:        mesh_savedetphoton(cfg->exportdetected, (void*)(cfg->exportseed), cfg->detectedcount, (sizeof(RandType)*RAND_BUF_LEN), cfg);
mmc_cl_host.c:763:    if (cfg->issaveref) {
mmc_cl_host.c:764:        MMC_FPRINTF(cfg->flog, "saving surface diffuse reflectance ...");
mmc_cl_host.c:769:    MMC_FPRINTF(cfg->flog, "simulated %zu photons (%zu) with %d devices (ray-tet %.0f)\nMCX simulation speed: %.2f photon/ms\n",
mmc_cl_host.c:770:                cfg->nphoton, cfg->nphoton, workdev, reporter.raytet, (double)cfg->nphoton / toc);
mmc_cl_host.c:771:    MMC_FPRINTF(cfg->flog, "total simulated energy: %.2f\tabsorbed: %5.5f%%\n(loss due to initial specular reflection is excluded in the total)\n",
mmc_cl_host.c:772:                cfg->energytot, (cfg->energytot - cfg->energyesc) / cfg->energytot * 100.f);
mmc_cl_host.c:773:    fflush(cfg->flog);
mmc_host.c:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_host.c:5:**  \copyright Qianqian Fang, 2010-2021
mmc_host.c:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_host.c:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_host.c:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_host.c:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_host.c:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_host.c:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_host.c:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_host.c:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_host.c:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_host.c:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_host.c:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_host.c:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_host.c:50:tetrahedral mesh (mesh) and the ray-tracer precomputed data (tracer).
mmc_host.c:58: * \param[in] tracer: the ray-tracer data structure
mmc_host.c:67:    if (cfg->isgpuinfo == 0) {
mmc_host.c:79: * \param[in] tracer: the ray-tracer data structure
mmc_host.c:88:    tracer_init(tracer, mesh, cfg->method);
mmc_host.c:97: * \param[out] tracer: the ray-tracer data structure
mmc_host.c:112: * \param[out] tracer: the ray-tracer data structure
mmc_host.c:127: * \param[out] tracer: the ray-tracer data structure
mmc_host.c:132:    tracer_init(tracer, mesh, cfg->method);
mmc_host.c:145: * \param[out] tracer: the ray-tracer data structure
mmc_host.c:158:        cfg->debuglevel = cfg->debuglevel & (~dlProgress);
mmc_host.c:166:    cfg->issaveseed = 0;
mmc_host.c:169:    MMCDEBUG(cfg, dlTime, (cfg->flog, "seed=%u\nsimulating ... \n", cfg->seed));
mmc_host.c:171:    if (cfg->debugphoton >= 0) {
mmc_host.c:172:        debuglevel = cfg->debuglevel;
mmc_host.c:173:        cfg->debuglevel &= 0xFFFFEA00;
mmc_host.c:182:    The master thread then spawn multiple work-threads depending on your
mmc_host.c:184:    your total CPU core number. For example, if you have a dual-core CPU,
mmc_host.c:185:    the total thread number is 2; if you have two quad-core CPUs, the total
mmc_host.c:195:        visitor visit = {0.f, 0.f, 1.f / cfg->tstep, DET_PHOTON_BUF, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL};
mmc_host.c:207:            srand(cfg->seed);
mmc_host.c:214:        visit.reclen = (2 + ((cfg->ismomentum) > 0)) * mesh->prop + (cfg->issaveexit > 0) * 6 + 2;
mmc_host.c:217:        if (cfg->issavedet) {
mmc_host.c:218:            if (cfg->issaveseed) {
mmc_host.c:231:        if ((cfg->debuglevel & dlProgress) && threadid == 0) {
mmc_host.c:232:            progressfun(-0.f, handle);
mmc_host.c:238:        for (id = 0; id < cfg->nphoton; id++) {
mmc_host.c:242:            if (id == cfg->debugphoton) {
mmc_host.c:243:                cfg->debuglevel = debuglevel;
mmc_host.c:246:            if (cfg->seed == SEED_FROM_FILE) {
mmc_host.c:247:                onephoton(id, tracer, mesh, cfg, ((RandType*)cfg->photonseed) + id * RAND_BUF_LEN, ran1, &visit);
mmc_host.c:255:            if (id == cfg->debugphoton) {
mmc_host.c:256:                cfg->debuglevel &= 0xFFFFEA00;
mmc_host.c:262:            if ((cfg->debuglevel & dlProgress) && threadid == 0) {
mmc_host.c:263:                progressfun((float)ncomplete / cfg->nphoton, handle);
mmc_host.c:267:        for (j = 0; j < cfg->srcnum; j++) {
mmc_host.c:274:        if (cfg->issavedet) {
mmc_host.c:282:                if (cfg->issaveseed) {
mmc_host.c:293:                if (cfg->issaveseed)
mmc_host.c:308:        if (cfg->issaveseed && visit.photonseed) {
mmc_host.c:319:    if ((cfg->debuglevel & dlProgress)) {
mmc_host.c:323:    dt = GetTimeMillis() - dt;
mmc_host.c:324:    MMCDEBUG(cfg, dlProgress, (cfg->flog, "\n"));
mmc_host.c:325:    MMCDEBUG(cfg, dlTime, (cfg->flog, "\tdone\t%d\n", dt));
mmc_host.c:326:    MMCDEBUG(cfg, dlTime, (cfg->flog, "speed ...\t"S_BOLD""S_BLUE"%.2f photon/ms"S_RESET", %.0f ray-tetrahedron tests (%.0f overhead, %.2f test/ms)\n", (double)cfg->nphoton / dt, raytri, raytri0, raytri / dt));
mmc_host.c:328:    if (cfg->issavedet) {
mmc_host.c:329:        MMC_FPRINTF(cfg->flog, "detected %d photons\n", master.detcount);
mmc_host.c:332:    if (cfg->isnormalized) {
mmc_host.c:335:        for (j = 0; j < cfg->srcnum; j++) {
mmc_host.c:338:            MMCDEBUG(cfg, dlTime, (cfg->flog, "source %d\ttotal simulated energy: %f\tabsorbed: "S_BOLD""S_BLUE"%5.5f%%"S_RESET"\tnormalizor=%g\n",
mmc_host.c:342:        cfg->his.normalizer = sum_normalizer / cfg->srcnum; // average normalizer value for all simulated sources
mmc_host.c:345:    if (cfg->issave2pt) {
mmc_host.c:346:        switch (cfg->outputtype) {
mmc_host.c:348:                MMCDEBUG(cfg, dlTime, (cfg->flog, "saving flux ..."));
mmc_host.c:352:                MMCDEBUG(cfg, dlTime, (cfg->flog, "saving fluence ..."));
mmc_host.c:356:                MMCDEBUG(cfg, dlTime, (cfg->flog, "saving energy deposit ..."));
mmc_host.c:363:    if (cfg->issavedet) {
mmc_host.c:364:        MMCDEBUG(cfg, dlTime, (cfg->flog, "saving detected photons ..."));
mmc_host.c:366:        if (cfg->issaveexit) {
mmc_host.c:370:        if (cfg->issaveexit == 2) {
mmc_host.c:371:            float* detimage = (float*)calloc(cfg->detparam1.w * cfg->detparam2.w * cfg->maxgate, sizeof(float));
mmc_host.c:379:        if (cfg->issaveseed && master.photonseed) {
mmc_host.c:380:            cfg->exportseed = (unsigned char*)malloc(cfg->detectedcount * sizeof(RandType) * RAND_BUF_LEN);
mmc_host.c:381:            memcpy(cfg->exportseed, master.photonseed, cfg->detectedcount * sizeof(RandType)*RAND_BUF_LEN);
mmc_host.c:386:    if (cfg->issaveref) {
mmc_host.c:387:        MMCDEBUG(cfg, dlTime, (cfg->flog, "saving surface diffuse reflectance ..."));
mmc_host.c:391:    MMCDEBUG(cfg, dlTime, (cfg->flog, "\tdone\t%d\n", GetTimeMillis() - t0));
mmc_rand_sfmt.c:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_rand_sfmt.c:5:**  \copyright Qianqian Fang, 2010-2021
mmc_rand_sfmt.c:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_rand_sfmt.c:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_rand_sfmt.c:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_rand_sfmt.c:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_rand_sfmt.c:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_rand_sfmt.c:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_rand_sfmt.c:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_rand_sfmt.c:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_rand_sfmt.c:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_rand_sfmt.c:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_rand_sfmt.c:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_rand_sfmt.c:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_rand_sfmt.c:50:#define R_MAX_SFMT_RAND      2.3283064359966e-10f //1/(2^32+1)
SFMT/SFMT.c:16:#include "SFMT-params.h"
SFMT/SFMT.c:26:    #error "-DONLY64 must be specified with -DBIG_ENDIAN64"
SFMT/SFMT.c:30:/*------------------------------------------------------
SFMT/SFMT.c:31:  128-bit SIMD data type for Altivec, SSE2 or standard C
SFMT/SFMT.c:32:  ------------------------------------------------------*/
SFMT/SFMT.c:37:/** 128-bit data structure */
SFMT/SFMT.c:42:/** 128-bit data type */
SFMT/SFMT.c:48:/** 128-bit data structure */
SFMT/SFMT.c:53:/** 128-bit data type */
SFMT/SFMT.c:58:/** 128-bit data structure */
SFMT/SFMT.c:62:/** 128-bit data type */
SFMT/SFMT.c:67:/*--------------------------------------
SFMT/SFMT.c:70:  --------------------------------------*/
SFMT/SFMT.c:71:/** the 128-bit internal state array */
SFMT/SFMT.c:73:/** the 32bit integer pointer to the 128-bit internal state array */
SFMT/SFMT.c:76:/** the 64bit integer pointer to the 128-bit internal state array */
SFMT/SFMT.c:79:/** index counter to the 32-bit internal state array */
SFMT/SFMT.c:87:/*----------------
SFMT/SFMT.c:89:  ----------------*/
SFMT/SFMT.c:103:  #include "SFMT-alti.h"
SFMT/SFMT.c:105:  #include "SFMT-sse2.h"
SFMT/SFMT.c:109: * This function simulate a 64-bit index of LITTLE ENDIAN 
SFMT/SFMT.c:122: * This function simulates SIMD 128-bit right shift by the standard C.
SFMT/SFMT.c:123: * The 128-bit integer given in in is shifted by (shift * 8) bits.
SFMT/SFMT.c:126: * @param in the 128-bit data to be shifted
SFMT/SFMT.c:133:    th = ((uint64_t)in->u[2] << 32) | ((uint64_t)in->u[3]);
SFMT/SFMT.c:134:    tl = ((uint64_t)in->u[0] << 32) | ((uint64_t)in->u[1]);
SFMT/SFMT.c:138:    ol |= th << (64 - shift * 8);
SFMT/SFMT.c:139:    out->u[0] = (uint32_t)(ol >> 32);
SFMT/SFMT.c:140:    out->u[1] = (uint32_t)ol;
SFMT/SFMT.c:141:    out->u[2] = (uint32_t)(oh >> 32);
SFMT/SFMT.c:142:    out->u[3] = (uint32_t)oh;
SFMT/SFMT.c:148:    th = ((uint64_t)in->u[3] << 32) | ((uint64_t)in->u[2]);
SFMT/SFMT.c:149:    tl = ((uint64_t)in->u[1] << 32) | ((uint64_t)in->u[0]);
SFMT/SFMT.c:153:    ol |= th << (64 - shift * 8);
SFMT/SFMT.c:154:    out->u[1] = (uint32_t)(ol >> 32);
SFMT/SFMT.c:155:    out->u[0] = (uint32_t)ol;
SFMT/SFMT.c:156:    out->u[3] = (uint32_t)(oh >> 32);
SFMT/SFMT.c:157:    out->u[2] = (uint32_t)oh;
SFMT/SFMT.c:161: * This function simulates SIMD 128-bit left shift by the standard C.
SFMT/SFMT.c:162: * The 128-bit integer given in in is shifted by (shift * 8) bits.
SFMT/SFMT.c:165: * @param in the 128-bit data to be shifted
SFMT/SFMT.c:172:    th = ((uint64_t)in->u[2] << 32) | ((uint64_t)in->u[3]);
SFMT/SFMT.c:173:    tl = ((uint64_t)in->u[0] << 32) | ((uint64_t)in->u[1]);
SFMT/SFMT.c:177:    oh |= tl >> (64 - shift * 8);
SFMT/SFMT.c:178:    out->u[0] = (uint32_t)(ol >> 32);
SFMT/SFMT.c:179:    out->u[1] = (uint32_t)ol;
SFMT/SFMT.c:180:    out->u[2] = (uint32_t)(oh >> 32);
SFMT/SFMT.c:181:    out->u[3] = (uint32_t)oh;
SFMT/SFMT.c:187:    th = ((uint64_t)in->u[3] << 32) | ((uint64_t)in->u[2]);
SFMT/SFMT.c:188:    tl = ((uint64_t)in->u[1] << 32) | ((uint64_t)in->u[0]);
SFMT/SFMT.c:192:    oh |= tl >> (64 - shift * 8);
SFMT/SFMT.c:193:    out->u[1] = (uint32_t)(ol >> 32);
SFMT/SFMT.c:194:    out->u[0] = (uint32_t)ol;
SFMT/SFMT.c:195:    out->u[3] = (uint32_t)(oh >> 32);
SFMT/SFMT.c:196:    out->u[2] = (uint32_t)oh;
SFMT/SFMT.c:203: * @param a a 128-bit part of the internal state array
SFMT/SFMT.c:204: * @param b a 128-bit part of the internal state array
SFMT/SFMT.c:205: * @param c a 128-bit part of the internal state array
SFMT/SFMT.c:206: * @param d a 128-bit part of the internal state array
SFMT/SFMT.c:217:    r->u[0] = a->u[0] ^ x.u[0] ^ ((b->u[0] >> SR1) & MSK2) ^ y.u[0] 
SFMT/SFMT.c:218:	^ (d->u[0] << SL1);
SFMT/SFMT.c:219:    r->u[1] = a->u[1] ^ x.u[1] ^ ((b->u[1] >> SR1) & MSK1) ^ y.u[1] 
SFMT/SFMT.c:220:	^ (d->u[1] << SL1);
SFMT/SFMT.c:221:    r->u[2] = a->u[2] ^ x.u[2] ^ ((b->u[2] >> SR1) & MSK4) ^ y.u[2] 
SFMT/SFMT.c:222:	^ (d->u[2] << SL1);
SFMT/SFMT.c:223:    r->u[3] = a->u[3] ^ x.u[3] ^ ((b->u[3] >> SR1) & MSK3) ^ y.u[3] 
SFMT/SFMT.c:224:	^ (d->u[3] << SL1);
SFMT/SFMT.c:234:    r->u[0] = a->u[0] ^ x.u[0] ^ ((b->u[0] >> SR1) & MSK1) ^ y.u[0] 
SFMT/SFMT.c:235:	^ (d->u[0] << SL1);
SFMT/SFMT.c:236:    r->u[1] = a->u[1] ^ x.u[1] ^ ((b->u[1] >> SR1) & MSK2) ^ y.u[1] 
SFMT/SFMT.c:237:	^ (d->u[1] << SL1);
SFMT/SFMT.c:238:    r->u[2] = a->u[2] ^ x.u[2] ^ ((b->u[2] >> SR1) & MSK3) ^ y.u[2] 
SFMT/SFMT.c:239:	^ (d->u[2] << SL1);
SFMT/SFMT.c:240:    r->u[3] = a->u[3] ^ x.u[3] ^ ((b->u[3] >> SR1) & MSK4) ^ y.u[3] 
SFMT/SFMT.c:241:	^ (d->u[3] << SL1);
SFMT/SFMT.c:255:    r1 = &sfmt[N - 2];
SFMT/SFMT.c:256:    r2 = &sfmt[N - 1];
SFMT/SFMT.c:257:    for (i = 0; i < N - POS1; i++) {
SFMT/SFMT.c:263:	do_recursion(&sfmt[i], &sfmt[i], &sfmt[i + POS1 - N], r1, r2);
SFMT/SFMT.c:270: * This function fills the user-specified array with pseudorandom
SFMT/SFMT.c:273: * @param array an 128-bit array to be filled by pseudorandom numbers.  
SFMT/SFMT.c:274: * @param size number of 128-bit pseudorandom numbers to be generated.
SFMT/SFMT.c:280:    r1 = &sfmt[N - 2];
SFMT/SFMT.c:281:    r2 = &sfmt[N - 1];
SFMT/SFMT.c:282:    for (i = 0; i < N - POS1; i++) {
SFMT/SFMT.c:288:	do_recursion(&array[i], &sfmt[i], &array[i + POS1 - N], r1, r2);
SFMT/SFMT.c:292:    for (; i < size - N; i++) {
SFMT/SFMT.c:293:	do_recursion(&array[i], &array[i - N], &array[i + POS1 - N], r1, r2);
SFMT/SFMT.c:297:    for (j = 0; j < 2 * N - size; j++) {
SFMT/SFMT.c:298:	sfmt[j] = array[j + size - N];
SFMT/SFMT.c:301:	do_recursion(&array[i], &array[i - N], &array[i + POS1 - N], r1, r2);
SFMT/SFMT.c:327: * @param x 32-bit integer
SFMT/SFMT.c:328: * @return 32-bit integer
SFMT/SFMT.c:337: * @param x 32-bit integer
SFMT/SFMT.c:338: * @return 32-bit integer
SFMT/SFMT.c:374:/*----------------
SFMT/SFMT.c:376:  ----------------*/
SFMT/SFMT.c:406: * This function generates and returns 32-bit pseudorandom number.
SFMT/SFMT.c:408: * @return 32-bit pseudorandom number
SFMT/SFMT.c:423: * This function generates and returns 64-bit pseudorandom number.
SFMT/SFMT.c:427: * @return 64-bit pseudorandom number
SFMT/SFMT.c:457: * This function generates pseudorandom 32-bit integers in the
SFMT/SFMT.c:467: * @param array an array where pseudorandom 32-bit integers are filled
SFMT/SFMT.c:470: * refers to the address of a 128-bit integer.  In the standard C
SFMT/SFMT.c:473: * @param size the number of 32-bit pseudorandom integers to be
SFMT/SFMT.c:493: * This function generates pseudorandom 64-bit integers in the
SFMT/SFMT.c:503: * @param array an array where pseudorandom 64-bit integers are filled
SFMT/SFMT.c:506: * refers to the address of a 128-bit integer.  In the standard C
SFMT/SFMT.c:509: * @param size the number of 64-bit pseudorandom integers to be
SFMT/SFMT.c:532: * This function initializes the internal state array with a 32-bit
SFMT/SFMT.c:535: * @param seed a 32-bit integer used as the seed.
SFMT/SFMT.c:542:	psfmt32[idxof(i)] = 1812433253UL * (psfmt32[idxof(i - 1)] 
SFMT/SFMT.c:543:					    ^ (psfmt32[idxof(i - 1)] >> 30))
SFMT/SFMT.c:553: * with an array of 32-bit integers used as the seeds
SFMT/SFMT.c:554: * @param init_key the array of 32-bit integers, used as a seed.
SFMT/SFMT.c:573:    mid = (size - lag) / 2;
SFMT/SFMT.c:582:	      ^ psfmt32[idxof(N32 - 1)]);
SFMT/SFMT.c:588:    count--;
SFMT/SFMT.c:591:		  ^ psfmt32[idxof((i + N32 - 1) % N32)]);
SFMT/SFMT.c:600:		  ^ psfmt32[idxof((i + N32 - 1) % N32)]);
SFMT/SFMT.c:609:		  + psfmt32[idxof((i + N32 - 1) % N32)]);
SFMT/SFMT.c:611:	r -= i;
SFMT/SFMT-sse2.h:2: * @file  SFMT-sse2.h
SFMT/SFMT-sse2.h:24: * @param a a 128-bit part of the interal state array
SFMT/SFMT-sse2.h:25: * @param b a 128-bit part of the interal state array
SFMT/SFMT-sse2.h:26: * @param c a 128-bit part of the interal state array
SFMT/SFMT-sse2.h:27: * @param d a 128-bit part of the interal state array
SFMT/SFMT-sse2.h:28: * @param mask 128-bit mask
SFMT/SFMT-sse2.h:57:    r1 = _mm_load_si128(&sfmt[N - 2].si);
SFMT/SFMT-sse2.h:58:    r2 = _mm_load_si128(&sfmt[N - 1].si);
SFMT/SFMT-sse2.h:59:    for (i = 0; i < N - POS1; i++) {
SFMT/SFMT-sse2.h:66:	r = mm_recursion(&sfmt[i].si, &sfmt[i + POS1 - N].si, r1, r2, mask);
SFMT/SFMT-sse2.h:74: * This function fills the user-specified array with pseudorandom
SFMT/SFMT-sse2.h:77: * @param array an 128-bit array to be filled by pseudorandom numbers.  
SFMT/SFMT-sse2.h:78: * @param size number of 128-bit pesudorandom numbers to be generated.
SFMT/SFMT-sse2.h:85:    r1 = _mm_load_si128(&sfmt[N - 2].si);
SFMT/SFMT-sse2.h:86:    r2 = _mm_load_si128(&sfmt[N - 1].si);
SFMT/SFMT-sse2.h:87:    for (i = 0; i < N - POS1; i++) {
SFMT/SFMT-sse2.h:94:	r = mm_recursion(&sfmt[i].si, &array[i + POS1 - N].si, r1, r2, mask);
SFMT/SFMT-sse2.h:100:    for (; i < size - N; i++) {
SFMT/SFMT-sse2.h:101:	r = mm_recursion(&array[i - N].si, &array[i + POS1 - N].si, r1, r2,
SFMT/SFMT-sse2.h:107:    for (j = 0; j < 2 * N - size; j++) {
SFMT/SFMT-sse2.h:108:	r = _mm_load_si128(&array[j + size - N].si);
SFMT/SFMT-sse2.h:112:	r = mm_recursion(&array[i - N].si, &array[i + POS1 - N].si, r1, r2,
SFMT/SFMT-params19937.h:44:#define IDSTR	"SFMT-19937:122-18-1-11-1:dfffffef-ddfecb7f-bffaffff-bffffff6"
SFMT/SFMT-params.h:10:/*-----------------
SFMT/SFMT-params.h:12:  -----------------*/
SFMT/SFMT-params.h:14: *  is a multiple of 2^MEXP-1.
SFMT/SFMT-params.h:16:/** SFMT generator has an internal state array of 128-bit integers,
SFMT/SFMT-params.h:20: * of 32-bit integers.*/
SFMT/SFMT-params.h:23: * of 64-bit integers.*/
SFMT/SFMT-params.h:26:/*----------------------
SFMT/SFMT-params.h:29:  ----------------------*/
SFMT/SFMT-params.h:34:/** the parameter of shift left as four 32-bit registers.
SFMT/SFMT-params.h:38:/** the parameter of shift left as one 128-bit register. 
SFMT/SFMT-params.h:39: * The 128-bit integer is shifted by (SL2 * 8) bits. 
SFMT/SFMT-params.h:43:/** the parameter of shift right as four 32-bit registers.
SFMT/SFMT-params.h:47:/** the parameter of shift right as one 128-bit register. 
SFMT/SFMT-params.h:48: * The 128-bit integer is shifted by (SL2 * 8) bits. 
SFMT/SFMT-params.h:60:/** These definitions are part of a 128-bit period certification vector.
SFMT/SFMT-params.h:68:  #include "SFMT-params607.h"
SFMT/SFMT-params.h:70:  #include "SFMT-params1279.h"
SFMT/SFMT-params.h:72:  #include "SFMT-params2281.h"
SFMT/SFMT-params.h:74:  #include "SFMT-params4253.h"
SFMT/SFMT-params.h:76:  #include "SFMT-params11213.h"
SFMT/SFMT-params.h:78:  #include "SFMT-params19937.h"
SFMT/SFMT-params.h:80:  #include "SFMT-params44497.h"
SFMT/SFMT-params.h:82:  #include "SFMT-params86243.h"
SFMT/SFMT-params.h:84:  #include "SFMT-params132049.h"
SFMT/SFMT-params.h:86:  #include "SFMT-params216091.h"
SFMT/SFMT.h:25: * uint32_t must be exactly 32-bit unsigned integer type (no more, no
SFMT/SFMT.h:26: * less), and uint64_t must be exactly 64-bit unsigned integer type.
SFMT/SFMT.h:27: * PRIu64 and PRIx64 are used for printf function to print 64-bit
SFMT/SFMT.h:28: * unsigned int and 64-bit unsigned int in hexadecimal format.
SFMT/SFMT.h:93:/** generates a random number on [0,1]-real-interval */
SFMT/SFMT.h:97:    /* divided by 2^32-1 */ 
SFMT/SFMT.h:100:/** generates a random number on [0,1]-real-interval */
SFMT/SFMT.h:106:/** generates a random number on [0,1)-real-interval */
SFMT/SFMT.h:113:/** generates a random number on [0,1)-real-interval */
SFMT/SFMT.h:119:/** generates a random number on (0,1)-real-interval */
SFMT/SFMT.h:126:/** generates a random number on (0,1)-real-interval */
SFMT/SFMT.h:133:/** generates a random number on [0,1) with 53-bit resolution*/
SFMT/SFMT.h:139:/** generates a random number on [0,1) with 53-bit resolution from two
SFMT/SFMT.h:146:/** generates a random number on [0,1) with 53-bit resolution
SFMT/SFMT.h:153:/** generates a random number on [0,1) with 53-bit resolution
mmc_host.h:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_host.h:5:**  \copyright Qianqian Fang, 2010-2021
mmc_host.h:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_host.h:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_host.h:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_host.h:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_host.h:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_host.h:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_host.h:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_host.h:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_host.h:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_host.h:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_host.h:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_host.h:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_host.h:35:\brief   Definition of mmc high-level driver functions
mmc_highorder.h:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_highorder.h:5:**  \copyright Qianqian Fang, 2010-2021
mmc_highorder.h:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_highorder.h:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_highorder.h:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_highorder.h:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_highorder.h:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_highorder.h:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_highorder.h:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_highorder.h:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_highorder.h:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_highorder.h:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_highorder.h:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_highorder.h:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
waitmex/waitmex.c:1:/* -------------------------------------------------------------------------- */
waitmex/waitmex.c:3:/* -------------------------------------------------------------------------- */
waitmex/waitmex.c:13:    ----                            -----------------
waitmex/waitmex.c:25:/* -------------------------------------------------------------------------- */
waitmex/waitmex.c:27:/* -------------------------------------------------------------------------- */
waitmex/waitmex.c:45:    h->fraction = mxCreateDoubleScalar (fraction) ;
waitmex/waitmex.c:46:    h->message = mxCreateString (message) ;
waitmex/waitmex.c:49:    h->inputs [0] = h->fraction ;
waitmex/waitmex.c:50:    h->inputs [1] = h->message ;
waitmex/waitmex.c:51:    error = mexCallMATLAB (1, h->outputs, 2, h->inputs, "waitbar") ;
waitmex/waitmex.c:58:    h->handle = h->outputs [0] ;
waitmex/waitmex.c:63:/* -------------------------------------------------------------------------- */
waitmex/waitmex.c:65:/* -------------------------------------------------------------------------- */
waitmex/waitmex.c:82:    static double oldperc=-1.0;
waitmex/waitmex.c:87:    (* mxGetPr (h->fraction)) = fraction ;  /* update the fraction */
waitmex/waitmex.c:88:    h->inputs [0] = h->fraction ;           /* define the inputs x and h */
waitmex/waitmex.c:89:    h->inputs [1] = h->handle ;
waitmex/waitmex.c:96:        error = mexCallMATLAB (0, h->outputs, 2, h->inputs, "waitbar") ;
waitmex/waitmex.c:101:        mxDestroyArray (h->message) ;
waitmex/waitmex.c:102:        h->message = mxCreateString (message) ;
waitmex/waitmex.c:103:        h->inputs [2] = h->message ;
waitmex/waitmex.c:104:        error = mexCallMATLAB (0, h->outputs, 3, h->inputs, "waitbar") ;
waitmex/waitmex.c:116:/* -------------------------------------------------------------------------- */
waitmex/waitmex.c:118:/* -------------------------------------------------------------------------- */
waitmex/waitmex.c:129:    h->inputs [0] = h->handle ;
waitmex/waitmex.c:130:    mxDestroyArray (h->fraction) ;      /* free the internal mxArrays */
waitmex/waitmex.c:131:    mxDestroyArray (h->message) ;
waitmex/waitmex.c:132:    error = mexCallMATLAB (0, h->outputs, 1, h->inputs, "close") ;
waitmex/waitmex.c:133:    mxDestroyArray (h->handle) ;
waitmex/waitmex.c:141:/* -------------------------------------------------------------------------- */
waitmex/waitmex.c:143:/* -------------------------------------------------------------------------- */
waitmex/waitmex.c:158:    handle = h->handle ;                /* get the MATLAB handle */
waitmex/waitmex.c:159:    mxDestroyArray (h->fraction) ;      /* free the internal mxArrays */
waitmex/waitmex.c:160:    mxDestroyArray (h->message) ;
waitmex/waitmex.h:1:/* -------------------------------------------------------------------------- */
waitmex/waitmex.h:3:/* -------------------------------------------------------------------------- */
waitmex/README.txt:8:    waitex.m	    a MATLAB m-file equivalent of waitexample.m
mmc_optix_host.cpp:21:        mcx_error(-1, "No GPU device found\n", __FILE__, __LINE__);
random.cu:33:    this->seed[0] = a;
random.cu:34:    this->seed[1] = b;
random.cu:38:    this->intSeed = se;
random.cu:42:    return (b - a) * this->xorshift128p_nextf() + a;
random.cu:46:    return -logf(this->xorshift128p_nextf() + std::numeric_limits<float>::epsilon());
random.cu:56:    const uint64_t s0 = this->seed[1];
random.cu:57:    s1.i = this->seed[0];
random.cu:58:    this->seed[0] = s0;
random.cu:60:    this->seed[1] = s1.i ^ s0 ^ (s1.i >> 18) ^ (s0 >> 5); // b, c
random.cu:61:    s1.i = this->seed[1] + s0;
random.cu:64:    return s1.f[0] - 1.0f;
ubj/ubjr.c:37:	ctx->userdata = userdata;
ubj/ubjr.c:38:	ctx->read_cb = read_cb;
ubj/ubjr.c:39:	ctx->peek_cb = peek_cb;
ubj/ubjr.c:40:	ctx->close_cb = close_cb;
ubj/ubjr.c:41:	ctx->error_cb = error_cb;
ubj/ubjr.c:44:/*	ctx->head = ctx->container_stack;
ubj/ubjr.c:45:	ctx->head->flags = 0;
ubj/ubjr.c:46:	ctx->head->type = UBJ_MIXED;
ubj/ubjr.c:47:	ctx->head->elements_remaining = 0;
ubj/ubjr.c:49:	ctx->ignore_container_flags = 0;*/
ubj/ubjr.c:51:	ctx->last_error_code = 0;
ubj/ubjr.c:53:	ctx->total_read = 0;
ubj/ubjr.c:59:	size_t n = ctx->total_read;
ubj/ubjr.c:67:	ctx->total_read += 1;
ubj/ubjr.c:68:	ctx->read_cb(&a, 1, 1, ctx->userdata);
ubj/ubjr.c:98:	size_t lim = fp->end - fp->current;
ubj/ubjr.c:103:	memcpy(data, fp->current, n);
ubj/ubjr.c:104:	fp->current += n;
ubj/ubjr.c:109:	return *mfd->current;
ubj/ubjr.c:115:	mfd->current = be;
ubj/ubjr.c:116:	mfd->begin = be;
ubj/ubjr.c:117:	mfd->end = en;
ubj/ubjr.c:123:	return ctx->peek_cb(ctx->userdata);
ubj/ubjr.c:127:	size_t nr=ctx->read_cb(dst,n,1,ctx->userdata);
ubj/ubjr.c:128:	ctx->total_read+=nr;
ubj/ubjr.c:144:	return strcmp(a->key,b->key);
ubj/ubjr.c:162:	priv_ubjr_sorted_key_t* sorted_keysmem = malloc(obj->size*sizeof(priv_ubjr_sorted_key_t));
ubj/ubjr.c:164:	for (i = 0; i < obj->size; i++)
ubj/ubjr.c:166:		sorted_keysmem[i].key = obj->keys[i];
ubj/ubjr.c:167:		sorted_keysmem[i].value = (const uint8_t*)obj->values + i*UBJR_TYPE_localsize[obj->type];
ubj/ubjr.c:169:	qsort(sorted_keysmem, obj->size, sizeof(priv_ubjr_sorted_key_t), _obj_key_cmp);
ubj/ubjr.c:262:	if (obj->metatable == NULL)
ubj/ubjr.c:264:		//memcpy(obj->sorted_keys,obj->keys)
ubj/ubjr.c:265:		obj->metatable = priv_ubjr_object_build_sorted_keys(obj);
ubj/ubjr.c:267:	void* result=bsearch(key, obj->metatable,obj->size, sizeof(priv_ubjr_sorted_key_t),_obj_key_cmp);
ubj/ubjr.c:275:	return priv_ubjr_pointer_to_dynamic(obj->type,result_key->value);
ubj/ubjr.c:280:	//multi-dimensional array to linear array lookup
ubj/ubjr.c:284:	uint8_t nd = arr->num_dims;
ubj/ubjr.c:285:	const size_t* dims = arr->dims;
ubj/ubjr.c:341:	if (myarray.type != UBJ_MIXED && myarray.size==0) //params detected this is a typed array but no size was detected..possibly an N-D array?
ubj/ubjr.c:381:		myarray.values=malloc(1*ls+1); //the +1 is for memory for the 0-size elements
ubj/ubjr.c:403:			buf_endian_swap(myarray.values, sz, myarray.size); //do nothing for 0-sized buffers
ubj/ubjr.c:432:		myobject.values = malloc(1 * ls + 1); //the +1 is for memory for the 0-size elements
ubj/ubjr.c:485:			switch(dyn->type)
ubj/ubjr.c:488:				priv_ubjr_cleanup_pointer(UBJ_STRING,&dyn->string);
ubj/ubjr.c:491:				priv_ubjr_cleanup_pointer(UBJ_ARRAY,&dyn->container_array);
ubj/ubjr.c:494:				priv_ubjr_cleanup_pointer(UBJ_OBJECT,&dyn->container_object);
ubj/ubjr.c:508:			priv_ubjr_cleanup_container(arr->type,arr->size,arr->values);
ubj/ubjr.c:509:			free(arr->dims);
ubj/ubjr.c:515:			priv_ubjr_cleanup_container(obj->type,obj->size,obj->values);
ubj/ubjr.c:516:			priv_ubjr_cleanup_container(UBJ_STRING,obj->size,obj->keys);
ubj/ubjr.c:517:			if(obj->metatable)
ubj/ubjr.c:519:				free(obj->metatable);
ubj/Makefile:9:# Allow only one "make -f Makefile2" at a time, but pass parallelism.
ubj/Makefile:45:RM = /usr/bin/cmake -E remove -f
ubj/Makefile:50:# The top-level source directory on which CMake was run.
ubj/Makefile:53:# The top-level build directory on which CMake was run.
ubj/Makefile:61:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Running CMake cache editor..."
ubj/Makefile:62:	/usr/bin/cmake-gui -H$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR)
ubj/Makefile:72:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Running CMake to regenerate build system..."
ubj/Makefile:73:	/usr/bin/cmake -H$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR)
ubj/Makefile:83:	$(CMAKE_COMMAND) -E cmake_progress_start /home/users/fangq/space/git/Project/github/ubj/CMakeFiles /home/users/fangq/space/git/Project/github/ubj/CMakeFiles/progress.marks
ubj/Makefile:84:	$(MAKE) -f CMakeFiles/Makefile2 all
ubj/Makefile:85:	$(CMAKE_COMMAND) -E cmake_progress_start /home/users/fangq/space/git/Project/github/ubj/CMakeFiles 0
ubj/Makefile:90:	$(MAKE) -f CMakeFiles/Makefile2 clean
ubj/Makefile:100:	$(MAKE) -f CMakeFiles/Makefile2 preinstall
ubj/Makefile:105:	$(MAKE) -f CMakeFiles/Makefile2 preinstall
ubj/Makefile:110:	$(CMAKE_COMMAND) -H$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR) --check-build-system CMakeFiles/Makefile.cmake 1
ubj/Makefile:118:	$(MAKE) -f CMakeFiles/Makefile2 ubj
ubj/Makefile:123:	$(MAKE) -f CMakeFiles/ubj.dir/build.make CMakeFiles/ubj.dir/build
ubj/Makefile:131:	$(MAKE) -f CMakeFiles/Makefile2 ubjwtest
ubj/Makefile:136:	$(MAKE) -f tests/CMakeFiles/ubjwtest.dir/build.make tests/CMakeFiles/ubjwtest.dir/build
ubj/Makefile:144:	$(MAKE) -f CMakeFiles/Makefile2 ubjrtest
ubj/Makefile:149:	$(MAKE) -f tests/CMakeFiles/ubjrtest.dir/build.make tests/CMakeFiles/ubjrtest.dir/build
ubj/Makefile:157:	$(MAKE) -f CMakeFiles/Makefile2 ubjopt
ubj/Makefile:162:	$(MAKE) -f tools/CMakeFiles/ubjopt.dir/build.make tools/CMakeFiles/ubjopt.dir/build
ubj/Makefile:170:	$(MAKE) -f CMakeFiles/Makefile2 ubjdump
ubj/Makefile:175:	$(MAKE) -f tools/CMakeFiles/ubjdump.dir/build.make tools/CMakeFiles/ubjdump.dir/build
ubj/Makefile:184:	$(MAKE) -f CMakeFiles/ubj.dir/build.make CMakeFiles/ubj.dir/ubjr.c.o
ubj/Makefile:193:	$(MAKE) -f CMakeFiles/ubj.dir/build.make CMakeFiles/ubj.dir/ubjr.c.i
ubj/Makefile:202:	$(MAKE) -f CMakeFiles/ubj.dir/build.make CMakeFiles/ubj.dir/ubjr.c.s
ubj/Makefile:211:	$(MAKE) -f CMakeFiles/ubj.dir/build.make CMakeFiles/ubj.dir/ubjrw.c.o
ubj/Makefile:220:	$(MAKE) -f CMakeFiles/ubj.dir/build.make CMakeFiles/ubj.dir/ubjrw.c.i
ubj/Makefile:229:	$(MAKE) -f CMakeFiles/ubj.dir/build.make CMakeFiles/ubj.dir/ubjrw.c.s
ubj/Makefile:238:	$(MAKE) -f CMakeFiles/ubj.dir/build.make CMakeFiles/ubj.dir/ubjw.c.o
ubj/Makefile:247:	$(MAKE) -f CMakeFiles/ubj.dir/build.make CMakeFiles/ubj.dir/ubjw.c.i
ubj/Makefile:256:	$(MAKE) -f CMakeFiles/ubj.dir/build.make CMakeFiles/ubj.dir/ubjw.c.s
ubj/Makefile:292:	$(CMAKE_COMMAND) -H$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR) --check-build-system CMakeFiles/Makefile.cmake 0
ubj/ubjrw.c:62:	else if(tm && !(tm & (tm- 1)))  //if only one bit is set in typemask
ubj/README.md:8:There are three components, each of which may be compiled and used seperately from each-other.
ubj/ubjw.c:51:	ctx->userdata = userdata;
ubj/ubjw.c:52:	ctx->write_cb = write_cb;
ubj/ubjw.c:53:	ctx->close_cb = close_cb;
ubj/ubjw.c:54:	ctx->error_cb = error_cb;
ubj/ubjw.c:56:	ctx->head = ctx->container_stack;
ubj/ubjw.c:57:	ctx->head->flags = 0;
ubj/ubjw.c:58:	ctx->head->type = UBJ_MIXED;
ubj/ubjw.c:59:	ctx->head->elements_remaining = 0;
ubj/ubjw.c:60:	//ctx->head->num_dims=1;
ubj/ubjw.c:62:	ctx->ignore_container_flags = 0;
ubj/ubjw.c:64:	ctx->last_error_code = 0;
ubj/ubjw.c:66:	ctx->total_written = 0;
ubj/ubjw.c:87:	size_t lim = fp->end - fp->current;
ubj/ubjw.c:92:	memcpy(fp->current, data, n);
ubj/ubjw.c:93:	fp->current += n;
ubj/ubjw.c:100:	mfd->current = be;
ubj/ubjw.c:101:	mfd->begin = be;
ubj/ubjw.c:102:	mfd->end = en;
ubj/ubjw.c:108:	ctx->total_written += 1;
ubj/ubjw.c:109:	ctx->write_cb(&a, 1, 1, ctx->userdata);
ubj/ubjw.c:127:	int n = ctx->head - ctx->container_stack;
ubj/ubjw.c:139:	if (head->flags & CONTAINER_IS_SIZED)
ubj/ubjw.c:141:		if (head->elements_remaining > 0)
ubj/ubjw.c:149:		if (head->flags & CONTAINER_IS_UBJ_ARRAY)
ubj/ubjw.c:153:		else if (head->flags & CONTAINER_IS_UBJ_OBJECT)
ubj/ubjw.c:163:	size_t height = ctx->head-ctx->container_stack+1;
ubj/ubjw.c:166:		*(++(ctx->head))=*cnt;
ubj/ubjw.c:175:	return *ctx->head--;
ubj/ubjw.c:180:	while (ctx->head > ctx->container_stack)
ubj/ubjw.c:185:	size_t n = ctx->total_written;
ubj/ubjw.c:186:	if (ctx->close_cb)
ubj/ubjw.c:187:		ctx->close_cb(ctx->userdata);
ubj/ubjw.c:195:	ctx->total_written += sz;
ubj/ubjw.c:196:	return ctx->write_cb(data, 1, sz, ctx->userdata);
ubj/ubjw.c:201:	struct priv_ubjw_container_t* ch = ctx->head;
ubj/ubjw.c:202:	if (!ctx->ignore_container_flags)
ubj/ubjw.c:206:			(!(ch->flags & (CONTAINER_IS_UBJ_ARRAY | CONTAINER_IS_UBJ_OBJECT))) &&
ubj/ubjw.c:212:		if (ch->flags & CONTAINER_IS_UBJ_OBJECT)
ubj/ubjw.c:214:			if (ch->flags & CONTAINER_EXPECTS_KEY)
ubj/ubjw.c:219:			ch->flags |= CONTAINER_EXPECTS_KEY; //set key expected next time in this context
ubj/ubjw.c:226:		if (ch->flags & CONTAINER_IS_SIZED)
ubj/ubjw.c:228:			ch->elements_remaining--; //todo: error if elements remaining is 0;
ubj/ubjw.c:231:		if ((ch->flags & CONTAINER_IS_TYPED) && ch->type == tid)
ubj/ubjw.c:244:	ctx->ignore_container_flags = 1; 
ubj/ubjw.c:246:	ctx->ignore_container_flags = 0;
ubj/ubjw.c:487:	cnt->flags=0;
ubj/ubjw.c:488:	cnt->elements_remaining = *count;
ubj/ubjw.c:489:	cnt->type = typ;
ubj/ubjw.c:505:		cnt->flags |= CONTAINER_IS_TYPED;
ubj/ubjw.c:513:		ctx->ignore_container_flags = 1;
ubj/ubjw.c:528:		ctx->ignore_container_flags = 0;
ubj/ubjw.c:530:		cnt->flags |= CONTAINER_IS_SIZED;
ubj/ubjw.c:531:		cnt->elements_remaining = *count;
ubj/ubjw.c:562:	if (ctx->head->flags & CONTAINER_EXPECTS_KEY && ctx->head->flags & CONTAINER_IS_UBJ_OBJECT)
ubj/ubjw.c:566:		ctx->head->flags ^= CONTAINER_EXPECTS_KEY; //turn off container 
ubj/ubjw.c:593:		size_t npass = min(nbytes - i, BUFFER_OUT_SIZE);
ubj/ubjw.c:622:	else if (typesz > 1) //and not big-endian
ubj/ubj.h:90://Proposal for N-D arrays
ubj/ubj.h:193:	reinterpret_cast<std::ostream*>(userdata)->write(data, n);
ubj/ubj.h:198:	reinterpret_cast<std::ostream*>(userdata)->close();
ubj/ubj.h:204:	reinterpret_cast<std::istream*>(userdata)->read(data, n);
ubj/ubj.h:209:	return reinterpret_cast<std::istream*>(userdata)->peek();
ubj/ubj.h:213:	reinterpret_cast<std::istream*>(userdata)->close();
ubj/ubj_internal.h:16:	{ -1,	 //MIXED
ubj/ubj_internal.h:23:	sizeof(const char*), //high-precision
ubj/ubj_internal.h:31:	-1,					//array
ubj/ubj_internal.h:32:	-1					//object
ubj/ubj_internal.h:44:	sizeof(ubjr_string_t), //high-precision
ubj/ubj_internal.h:58:	*outbuffer++ = (input >> 8); // Get top order byte (guaranteed endian-independent since machine registers)
ubj/ubj_internal.h:110://warning...null-terminated strings are assumed...when this is not necessarily valid. FIXED: we don't use null-terminated strings in the reader (NOT FIXED...string type is awkward)
mmc_cl_utils.h:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_cl_utils.h:5:**  \copyright Qianqian Fang, 2010-2021
mmc_cl_utils.h:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_cl_utils.h:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_cl_utils.h:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_cl_utils.h:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_cl_utils.h:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_cl_utils.h:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_cl_utils.h:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_cl_utils.h:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_cl_utils.h:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_cl_utils.h:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_cl_utils.h:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_cl_utils.h:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_cl_utils.h:51:#define ABS(a)  ((a)<0?-(a):(a))
zmat/Makefile:26:INCLUDEDIRS=-Ieasylzma -Ieasylzma/pavlov -Ilz4
zmat/Makefile:30:ARCH = $(shell uname -m)
zmat/Makefile:31:PLATFORM = $(shell uname -s)
zmat/Makefile:33:DLLFLAG=-fPIC
zmat/Makefile:34:OMP=-fopenmp
zmat/Makefile:36:CPPOPT=-g -Wall -O3 -fPIC
zmat/Makefile:38:OUTPUTFLAG:=-o
zmat/Makefile:49:  #CUOMPLINK=-Xcompiler
zmat/Makefile:51:      LINKOPT=-L"$(CUDA_PATH)/lib/x64" $(CUDART)
zmat/Makefile:53:      LINKOPT=-L"$(CUDA_PATH)/lib/Win32" $(CUDART)
zmat/Makefile:55:  INCLUDEDIRS +=-I"$(CUDA_PATH)/lib/include"
zmat/Makefile:56:  CPPOPT =-c -DWIN32 -g -Wall -O3 -fPIC
zmat/Makefile:60:  OMP=-fopenmp
zmat/Makefile:62:  #CPPOPT+=-Xcompiler $(OMP)
zmat/Makefile:68:  CUCCOPT+=-Xcompiler $(OMP)
zmat/Makefile:71:     CUCCOPT +=-m64
zmat/Makefile:74:           LINKOPT=-L/usr/local/cuda/lib64 $(CUDART) -lm -lstdc++
zmat/Makefile:76:           LINKOPT=-L/usr/local/cuda/lib64 $(CUDART) -lm -static-libgcc -static-libstdc++
zmat/Makefile:92:dll:   ARFLAGS    :=-shared -Wl,-soname,$(BINARY).1
zmat/Makefile:94:dll:   AROUTPUT   :=-o
zmat/Makefile:98:oct:   AR= CXXFLAGS='-O3' LFLAGS='$(-lz)' LDFLAGS='$(LFLAGS)' mkoctfile zmat.cpp
zmat/Makefile:101:oct:   LINKOPT+=--mex $(INCLUDEDIRS)
zmat/Makefile:105:mex:   OUTPUTFLAG:=-output
zmat/Makefile:107:mex:   LINKOPT+= -cxx CXXLIBS='$$CXXLIBS -lz' -outdir $(ZMATDIR)
zmat/Makefile:117:        ARFLAGS+= -shared -Wl,-soname,$(BINARY).1 
zmat/Makefile:128:	@if test ! -d $(OUTPUT_DIR); then $(MKDIR) $(OUTPUT_DIR); fi
zmat/Makefile:131:	@if test ! -d $(DOCDIR); then $(MKDIR) $(DOCDIR); fi
zmat/Makefile:139:	$(CXX) $(INCLUDEDIRS) $(CPPOPT) -c -o $@ $<
zmat/Makefile:143:	$(CC) $(INCLUDEDIRS) $(CPPOPT) -c -o $@ $<
zmat/Makefile:147:	$(CUDACC) -c $(CUCCOPT) -o $@  $<
zmat/Makefile:150:	-rm -f $(OBJS) $(OUTPUT_DIR)/$(BINARY)$(EXESUFFIX) $(OUTPUT_DIR)/libzmat.*
Binary file zmat/zmatlib.o matches
zmat/zmat.cpp:8:**  \copyright 2005-2011, Jouni Malinen <j@w1.fi>
zmat/zmat.cpp:35:/** @brief Mex function for the zmat - an interface to compress/decompress binary data
zmat/zmat.cpp:67:             mexErrMsgTxt("the 'method' field must be a non-empty string");
zmat/zmat.cpp:74:	       int ret=-1;
zmat/zmat.cpp:121:	           mexErrMsgTxt(zmat_error(-errcode));
zmat/zmat.cpp:124:	      mexErrMsgTxt("the input must be a char, non-complex numerical or logical array");
zmat/easylzma/README:1:pavlov/ - contains original lzma compress/decompress source from Igor Pavlov
zmat/easylzma/README:2:easylzma/ - contains the public api of this library
zmat/easylzma/README:3:./ - contains the implementation of this wrapper library
zmat/easylzma/compress.c:38:    LzmaEncProps_Init(&(hand->props));
zmat/easylzma/compress.c:39:    hand->props.lc = 3;
zmat/easylzma/compress.c:40:    hand->props.lp = 0;    
zmat/easylzma/compress.c:41:    hand->props.pb = 2;    
zmat/easylzma/compress.c:42:    hand->props.level = 5;
zmat/easylzma/compress.c:43:    hand->props.algo = 1;
zmat/easylzma/compress.c:44:    hand->props.fb = 32;
zmat/easylzma/compress.c:45:    hand->props.dictSize = 1 << 24;
zmat/easylzma/compress.c:46:    hand->props.btMode = 1;
zmat/easylzma/compress.c:47:    hand->props.numHashBytes = 4;
zmat/easylzma/compress.c:48:    hand->props.mc = 32;
zmat/easylzma/compress.c:49:    hand->props.numThreads = 1;
zmat/easylzma/compress.c:50:    hand->props.writeEndMark = 1;
zmat/easylzma/compress.c:52:    init_alloc_struct(&(hand->allocStruct), NULL, NULL, NULL, NULL);
zmat/easylzma/compress.c:54:    /* default format is LZMA-Alone */
zmat/easylzma/compress.c:55:    initializeLZMAFormatHandler(&(hand->formatHandler));
zmat/easylzma/compress.c:64:        if ((*hand)->encHand) {
zmat/easylzma/compress.c:65:            LzmaEnc_Destroy((*hand)->encHand,
zmat/easylzma/compress.c:66:                            (ISzAlloc *) &((*hand)->allocStruct),
zmat/easylzma/compress.c:67:                            (ISzAlloc *) &((*hand)->allocStruct));
zmat/easylzma/compress.c:86:    hand->props.lc = lc;
zmat/easylzma/compress.c:87:    hand->props.lp = lp;    
zmat/easylzma/compress.c:88:    hand->props.pb = pb;
zmat/easylzma/compress.c:89:    hand->props.level = level;
zmat/easylzma/compress.c:90:    hand->props.dictSize = dictionarySize;
zmat/easylzma/compress.c:91:    hand->uncompressedSize = uncompressedSize;
zmat/easylzma/compress.c:92:    hand->format = format;
zmat/easylzma/compress.c:94:    /* default of LZMA-Alone is set at alloc time, and there are only
zmat/easylzma/compress.c:97:        initializeLZIPFormatHandler(&(hand->formatHandler));
zmat/easylzma/compress.c:120:    rv = is->inputStream(is->inputContext, buf, size);
zmat/easylzma/compress.c:121:    if (rv == 0 && *size > 0 && is->calculateCRC) {
zmat/easylzma/compress.c:122:        is->crc32 = CrcUpdate(is->crc32, buf, *size);
zmat/easylzma/compress.c:136:    return os->outputStream(os->outputContext, buf, size);
zmat/easylzma/compress.c:153:    if (ps->progressCallback) {
zmat/easylzma/compress.c:154:        ps->progressCallback(ps->progressContext, inSize,
zmat/easylzma/compress.c:155:                             ps->uncompressedSize);
zmat/easylzma/compress.c:166:        init_alloc_struct(&(hand->allocStruct),
zmat/easylzma/compress.c:194:        (hand->formatHandler.serialize_footer != NULL);
zmat/easylzma/compress.c:201:    progressStruct.uncompressedSize = hand->uncompressedSize;
zmat/easylzma/compress.c:206:    hand->encHand = LzmaEnc_Create((ISzAlloc *) &(hand->allocStruct));
zmat/easylzma/compress.c:208:    if (hand->encHand == NULL) {
zmat/easylzma/compress.c:213:    if (SZ_OK != LzmaEnc_SetProps(hand->encHand, &(hand->props)))
zmat/easylzma/compress.c:219:    if (ELZMA_lzma != hand->format && ELZMA_lzip != hand->format) {
zmat/easylzma/compress.c:226:            hand->allocStruct.Alloc(&(hand->allocStruct),
zmat/easylzma/compress.c:227:                                    hand->formatHandler.header_size);
zmat/easylzma/compress.c:232:        hand->formatHandler.init_header(&h);
zmat/easylzma/compress.c:233:        h.pb = (unsigned char) hand->props.pb;
zmat/easylzma/compress.c:234:        h.lp = (unsigned char) hand->props.lp;
zmat/easylzma/compress.c:235:        h.lc = (unsigned char) hand->props.lc;
zmat/easylzma/compress.c:236:        h.dictSize = hand->props.dictSize;
zmat/easylzma/compress.c:237:        h.isStreamed = (unsigned char) (hand->uncompressedSize == 0);
zmat/easylzma/compress.c:238:        h.uncompressedSize = hand->uncompressedSize;
zmat/easylzma/compress.c:240:        hand->formatHandler.serialize_header(hdr, &h);
zmat/easylzma/compress.c:243:                          hand->formatHandler.header_size);
zmat/easylzma/compress.c:245:        hand->allocStruct.Free(&(hand->allocStruct), hdr);
zmat/easylzma/compress.c:247:        if (wt != hand->formatHandler.header_size) {
zmat/easylzma/compress.c:254:    r = LzmaEnc_Encode(hand->encHand,
zmat/easylzma/compress.c:258:                       (ISzAlloc *) &(hand->allocStruct),
zmat/easylzma/compress.c:259:                       (ISzAlloc *) &(hand->allocStruct));
zmat/easylzma/compress.c:264:    if (hand->formatHandler.serialize_footer != NULL &&
zmat/easylzma/compress.c:265:        hand->formatHandler.footer_size > 0)
zmat/easylzma/compress.c:269:            hand->allocStruct.Alloc(&(hand->allocStruct),
zmat/easylzma/compress.c:270:                                    hand->formatHandler.footer_size);
zmat/easylzma/compress.c:273:        ftr.uncompressedSize = hand->uncompressedSize;
zmat/easylzma/compress.c:275:        hand->formatHandler.serialize_footer(&ftr, ftrBuf);
zmat/easylzma/compress.c:278:                          hand->formatHandler.footer_size);
zmat/easylzma/compress.c:280:        hand->allocStruct.Free(&(hand->allocStruct), ftrBuf);
zmat/easylzma/compress.c:282:        if (wt != hand->formatHandler.footer_size) {
zmat/easylzma/compress.c:305:    /* now 1 << i is greater than size, let's return either 1<<i or 1<<(i-1),
zmat/easylzma/compress.c:307:    return 1 << ((((1 << i) - size) > (size - (1 << (i-1)))) ? i-1 : i);
zmat/easylzma/lzip_header.c:20:    hdr->pb = 2;
zmat/easylzma/lzip_header.c:21:    hdr->lp = 0;    
zmat/easylzma/lzip_header.c:22:    hdr->lc = 3;        
zmat/easylzma/lzip_header.c:24:    hdr->isStreamed = 1;
zmat/easylzma/lzip_header.c:25:    hdr->uncompressedSize = 0;    
zmat/easylzma/lzip_header.c:26:    hdr->dictSize = 1 << (hdrBuf[5] & 0x1F);
zmat/easylzma/lzip_header.c:41:        while ((hdr->dictSize >> r) != 0) r++;
zmat/easylzma/lzip_header.c:42:        hdrBuf[5] = (unsigned char) (r-1) & 0x1F;
zmat/easylzma/lzip_header.c:55:        *(ftrBuf++) = (unsigned char) (ftr->crc32 >> (i * 8)); 
zmat/easylzma/lzip_header.c:60:        *(ftrBuf++) = (unsigned char) (ftr->uncompressedSize >> (i * 8)); 
zmat/easylzma/lzip_header.c:73:    ftr->crc32 = 0;
zmat/easylzma/lzip_header.c:74:    ftr->uncompressedSize = 0;    
zmat/easylzma/lzip_header.c:79:        ftr->crc32 += ((unsigned int) *(ftrBuf++) << (i * 8)); 
zmat/easylzma/lzip_header.c:84:        ftr->uncompressedSize +=
zmat/easylzma/lzip_header.c:95:    hand->header_size = ELZMA_LZIP_HEADER_SIZE;
zmat/easylzma/lzip_header.c:96:    hand->init_header = initLzipHeader;
zmat/easylzma/lzip_header.c:97:    hand->parse_header = parseLzipHeader;    
zmat/easylzma/lzip_header.c:98:    hand->serialize_header = serializeLzipHeader;    
zmat/easylzma/lzip_header.c:99:    hand->footer_size = ELZMA_LZIP_FOOTER_SIZE;    
zmat/easylzma/lzip_header.c:100:    hand->serialize_footer = serializeLzipFooter;
zmat/easylzma/lzip_header.c:101:    hand->parse_footer = parseLzipFooter;
zmat/easylzma/Makefile:9:# Allow only one "make -f Makefile2" at a time, but pass parallelism.
zmat/easylzma/Makefile:45:RM = /usr/bin/cmake -E remove -f
zmat/easylzma/Makefile:50:# The top-level source directory on which CMake was run.
zmat/easylzma/Makefile:53:# The top-level build directory on which CMake was run.
zmat/easylzma/Makefile:61:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Running CMake to regenerate build system..."
zmat/easylzma/Makefile:62:	/usr/bin/cmake -H$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR)
zmat/easylzma/Makefile:72:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "No interactive CMake dialog available..."
zmat/easylzma/Makefile:73:	/usr/bin/cmake -E echo No\ interactive\ CMake\ dialog\ available.
zmat/easylzma/Makefile:83:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(CMAKE_COMMAND) -E cmake_progress_start /home/fangq/space/git/Project/github/zmat/src/easylzma/CMakeFiles /home/fangq/space/git/Project/github/zmat/src/easylzma/src/CMakeFiles/progress.marks
zmat/easylzma/Makefile:84:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f CMakeFiles/Makefile2 src/all
zmat/easylzma/Makefile:85:	$(CMAKE_COMMAND) -E cmake_progress_start /home/fangq/space/git/Project/github/zmat/src/easylzma/CMakeFiles 0
zmat/easylzma/Makefile:90:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f CMakeFiles/Makefile2 src/clean
zmat/easylzma/Makefile:100:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f CMakeFiles/Makefile2 src/preinstall
zmat/easylzma/Makefile:105:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f CMakeFiles/Makefile2 src/preinstall
zmat/easylzma/Makefile:110:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(CMAKE_COMMAND) -H$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR) --check-build-system CMakeFiles/Makefile.cmake 1
zmat/easylzma/Makefile:115:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f CMakeFiles/Makefile2 src/CMakeFiles/easylzma_s.dir/rule
zmat/easylzma/Makefile:125:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/build
zmat/easylzma/Makefile:130:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f CMakeFiles/Makefile2 src/CMakeFiles/easylzma.dir/rule
zmat/easylzma/Makefile:140:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/build
zmat/easylzma/Makefile:149:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/common_internal.c.o
zmat/easylzma/Makefile:150:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/common_internal.c.o
zmat/easylzma/Makefile:159:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/common_internal.c.i
zmat/easylzma/Makefile:160:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/common_internal.c.i
zmat/easylzma/Makefile:169:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/common_internal.c.s
zmat/easylzma/Makefile:170:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/common_internal.c.s
zmat/easylzma/Makefile:179:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/compress.c.o
zmat/easylzma/Makefile:180:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/compress.c.o
zmat/easylzma/Makefile:189:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/compress.c.i
zmat/easylzma/Makefile:190:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/compress.c.i
zmat/easylzma/Makefile:199:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/compress.c.s
zmat/easylzma/Makefile:200:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/compress.c.s
zmat/easylzma/Makefile:209:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/decompress.c.o
zmat/easylzma/Makefile:210:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/decompress.c.o
zmat/easylzma/Makefile:219:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/decompress.c.i
zmat/easylzma/Makefile:220:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/decompress.c.i
zmat/easylzma/Makefile:229:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/decompress.c.s
zmat/easylzma/Makefile:230:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/decompress.c.s
zmat/easylzma/Makefile:239:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/lzip_header.c.o
zmat/easylzma/Makefile:240:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/lzip_header.c.o
zmat/easylzma/Makefile:249:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/lzip_header.c.i
zmat/easylzma/Makefile:250:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/lzip_header.c.i
zmat/easylzma/Makefile:259:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/lzip_header.c.s
zmat/easylzma/Makefile:260:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/lzip_header.c.s
zmat/easylzma/Makefile:269:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/lzma_header.c.o
zmat/easylzma/Makefile:270:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/lzma_header.c.o
zmat/easylzma/Makefile:279:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/lzma_header.c.i
zmat/easylzma/Makefile:280:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/lzma_header.c.i
zmat/easylzma/Makefile:289:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/lzma_header.c.s
zmat/easylzma/Makefile:290:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/lzma_header.c.s
zmat/easylzma/Makefile:299:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/7zBuf.c.o
zmat/easylzma/Makefile:300:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/7zBuf.c.o
zmat/easylzma/Makefile:309:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/7zBuf.c.i
zmat/easylzma/Makefile:310:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/7zBuf.c.i
zmat/easylzma/Makefile:319:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/7zBuf.c.s
zmat/easylzma/Makefile:320:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/7zBuf.c.s
zmat/easylzma/Makefile:329:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/7zBuf2.c.o
zmat/easylzma/Makefile:330:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/7zBuf2.c.o
zmat/easylzma/Makefile:339:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/7zBuf2.c.i
zmat/easylzma/Makefile:340:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/7zBuf2.c.i
zmat/easylzma/Makefile:349:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/7zBuf2.c.s
zmat/easylzma/Makefile:350:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/7zBuf2.c.s
zmat/easylzma/Makefile:359:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/7zCrc.c.o
zmat/easylzma/Makefile:360:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/7zCrc.c.o
zmat/easylzma/Makefile:369:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/7zCrc.c.i
zmat/easylzma/Makefile:370:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/7zCrc.c.i
zmat/easylzma/Makefile:379:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/7zCrc.c.s
zmat/easylzma/Makefile:380:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/7zCrc.c.s
zmat/easylzma/Makefile:389:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/7zFile.c.o
zmat/easylzma/Makefile:390:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/7zFile.c.o
zmat/easylzma/Makefile:399:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/7zFile.c.i
zmat/easylzma/Makefile:400:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/7zFile.c.i
zmat/easylzma/Makefile:409:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/7zFile.c.s
zmat/easylzma/Makefile:410:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/7zFile.c.s
zmat/easylzma/Makefile:419:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/7zStream.c.o
zmat/easylzma/Makefile:420:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/7zStream.c.o
zmat/easylzma/Makefile:429:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/7zStream.c.i
zmat/easylzma/Makefile:430:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/7zStream.c.i
zmat/easylzma/Makefile:439:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/7zStream.c.s
zmat/easylzma/Makefile:440:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/7zStream.c.s
zmat/easylzma/Makefile:449:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/Alloc.c.o
zmat/easylzma/Makefile:450:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/Alloc.c.o
zmat/easylzma/Makefile:459:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/Alloc.c.i
zmat/easylzma/Makefile:460:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/Alloc.c.i
zmat/easylzma/Makefile:469:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/Alloc.c.s
zmat/easylzma/Makefile:470:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/Alloc.c.s
zmat/easylzma/Makefile:479:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/Bcj2.c.o
zmat/easylzma/Makefile:480:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/Bcj2.c.o
zmat/easylzma/Makefile:489:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/Bcj2.c.i
zmat/easylzma/Makefile:490:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/Bcj2.c.i
zmat/easylzma/Makefile:499:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/Bcj2.c.s
zmat/easylzma/Makefile:500:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/Bcj2.c.s
zmat/easylzma/Makefile:509:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/Bra.c.o
zmat/easylzma/Makefile:510:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/Bra.c.o
zmat/easylzma/Makefile:519:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/Bra.c.i
zmat/easylzma/Makefile:520:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/Bra.c.i
zmat/easylzma/Makefile:529:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/Bra.c.s
zmat/easylzma/Makefile:530:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/Bra.c.s
zmat/easylzma/Makefile:539:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/Bra86.c.o
zmat/easylzma/Makefile:540:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/Bra86.c.o
zmat/easylzma/Makefile:549:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/Bra86.c.i
zmat/easylzma/Makefile:550:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/Bra86.c.i
zmat/easylzma/Makefile:559:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/Bra86.c.s
zmat/easylzma/Makefile:560:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/Bra86.c.s
zmat/easylzma/Makefile:569:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/BraIA64.c.o
zmat/easylzma/Makefile:570:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/BraIA64.c.o
zmat/easylzma/Makefile:579:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/BraIA64.c.i
zmat/easylzma/Makefile:580:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/BraIA64.c.i
zmat/easylzma/Makefile:589:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/BraIA64.c.s
zmat/easylzma/Makefile:590:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/BraIA64.c.s
zmat/easylzma/Makefile:599:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/LzFind.c.o
zmat/easylzma/Makefile:600:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/LzFind.c.o
zmat/easylzma/Makefile:609:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/LzFind.c.i
zmat/easylzma/Makefile:610:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/LzFind.c.i
zmat/easylzma/Makefile:619:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/LzFind.c.s
zmat/easylzma/Makefile:620:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/LzFind.c.s
zmat/easylzma/Makefile:629:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/LzmaDec.c.o
zmat/easylzma/Makefile:630:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/LzmaDec.c.o
zmat/easylzma/Makefile:639:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/LzmaDec.c.i
zmat/easylzma/Makefile:640:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/LzmaDec.c.i
zmat/easylzma/Makefile:649:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/LzmaDec.c.s
zmat/easylzma/Makefile:650:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/LzmaDec.c.s
zmat/easylzma/Makefile:659:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/LzmaEnc.c.o
zmat/easylzma/Makefile:660:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/LzmaEnc.c.o
zmat/easylzma/Makefile:669:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/LzmaEnc.c.i
zmat/easylzma/Makefile:670:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/LzmaEnc.c.i
zmat/easylzma/Makefile:679:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/LzmaEnc.c.s
zmat/easylzma/Makefile:680:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/LzmaEnc.c.s
zmat/easylzma/Makefile:689:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/LzmaLib.c.o
zmat/easylzma/Makefile:690:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/LzmaLib.c.o
zmat/easylzma/Makefile:699:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/LzmaLib.c.i
zmat/easylzma/Makefile:700:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/LzmaLib.c.i
zmat/easylzma/Makefile:709:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma_s.dir/build.make src/CMakeFiles/easylzma_s.dir/pavlov/LzmaLib.c.s
zmat/easylzma/Makefile:710:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(MAKE) -f src/CMakeFiles/easylzma.dir/build.make src/CMakeFiles/easylzma.dir/pavlov/LzmaLib.c.s
zmat/easylzma/Makefile:791:	cd /home/fangq/space/git/Project/github/zmat/src/easylzma && $(CMAKE_COMMAND) -H$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR) --check-build-system CMakeFiles/Makefile.cmake 0
zmat/easylzma/lzma_header.h:6:/* LZMA-Alone header format gleaned from reading Igor's code */
Binary file zmat/easylzma/lzma_header.o matches
zmat/easylzma/lzip_header.h:7: * http://download.savannah.gnu.org/releases-noredirect/lzip/manual/ */
Binary file zmat/easylzma/decompress.o matches
zmat/easylzma/decompress.c:37:    init_alloc_struct(&(hand->allocStruct), NULL, NULL, NULL, NULL);
zmat/easylzma/decompress.c:47:        init_alloc_struct(&(hand->allocStruct),
zmat/easylzma/decompress.c:96:            hand->allocStruct.Alloc(&(hand->allocStruct),
zmat/easylzma/decompress.c:106:            hand->allocStruct.Free(&(hand->allocStruct), hdr);
zmat/easylzma/decompress.c:111:            hand->allocStruct.Free(&(hand->allocStruct), hdr);
zmat/easylzma/decompress.c:132:                             (ISzAlloc *) &(hand->allocStruct));
zmat/easylzma/decompress.c:135:        hand->allocStruct.Free(&(hand->allocStruct), hdr);
zmat/easylzma/decompress.c:147:        if (0 != inputStream(inputContext, hand->inbuf, &srcLen))
zmat/easylzma/decompress.c:167:            SRes r = LzmaDec_DecodeToBuf(&dec, (Byte *) hand->outbuf, &dstLen,
zmat/easylzma/decompress.c:168:                                         ((Byte *) hand->inbuf + bufOff), &amt,
zmat/easylzma/decompress.c:183:                    crc32 = CrcUpdate(crc32, hand->outbuf, dstLen);
zmat/easylzma/decompress.c:188:                wt = outputStream(outputContext, hand->outbuf, dstLen);
zmat/easylzma/decompress.c:199:            amt = srcLen - bufOff;
zmat/easylzma/decompress.c:216:                    (unsigned char *) hand->inbuf + bufOff, &f);
zmat/easylzma/decompress.c:251:    LzmaDec_Free(&dec, (ISzAlloc *) &(hand->allocStruct));
zmat/easylzma/lzma_header.c:26:#define UINT64_MAX ((unsigned long long) -1)
zmat/easylzma/lzma_header.c:36:		return -1;
zmat/easylzma/lzma_header.c:56:		return -1;
zmat/easylzma/lzma_header.c:91:    if (lzmadec_header_properties(&(hdr->pb), &(hdr->lp), &(hdr->lc),
zmat/easylzma/lzma_header.c:93:        lzmadec_header_dictionary(&(hdr->dictSize), hdrBuf + 1))
zmat/easylzma/lzma_header.c:97:    lzmadec_header_uncompressed(&(hdr->uncompressedSize),
zmat/easylzma/lzma_header.c:98:                                &(hdr->isStreamed),
zmat/easylzma/lzma_header.c:113:    *hdrBuf++ = hdr->lc + (hdr->pb * 45) + (hdr->lp * 45 * 9);
zmat/easylzma/lzma_header.c:117:        *(hdrBuf++) = (unsigned char) (hdr->dictSize >> (i * 8)); 
zmat/easylzma/lzma_header.c:122:        if (hdr->isStreamed) {
zmat/easylzma/lzma_header.c:125:            *(hdrBuf++) = (unsigned char) (hdr->uncompressedSize >> (i * 8)); 
zmat/easylzma/lzma_header.c:135:    hand->header_size = ELZMA_LZMA_HEADER_SIZE;
zmat/easylzma/lzma_header.c:136:    hand->init_header = initLzmaHeader;
zmat/easylzma/lzma_header.c:137:    hand->parse_header = parseLzmaHeader;    
zmat/easylzma/lzma_header.c:138:    hand->serialize_header = serializeLzmaHeader;    
zmat/easylzma/lzma_header.c:139:    hand->footer_size = 0;    
zmat/easylzma/lzma_header.c:140:    hand->serialize_footer = NULL;
zmat/easylzma/easylzma/compress.h:10: * easylzma/compress.h - the API for LZMA compression using easylzma
zmat/easylzma/easylzma/common.h:10: * easylzma/common.h - definitions common to both compression and
zmat/easylzma/easylzma/common.h:70:    ELZMA_lzma  /**< the LZMA-Alone format, originally designed by
zmat/easylzma/easylzma/decompress.h:10: * easylzma/decompress.h - The API for LZMA decompression using easylzma
Binary file zmat/easylzma/lzip_header.o matches
Binary file zmat/easylzma/compress.o matches
Binary file zmat/easylzma/common_internal.o matches
zmat/easylzma/common_internal.c:15:    if (as->clientMallocFunc) {
zmat/easylzma/common_internal.c:16:        return as->clientMallocFunc(as->clientMallocContext, size);
zmat/easylzma/common_internal.c:23:    if (as->clientFreeFunc) {
zmat/easylzma/common_internal.c:24:        as->clientFreeFunc(as->clientMallocContext, address);
zmat/easylzma/common_internal.c:37:    as->Alloc = elzmaAlloc;
zmat/easylzma/common_internal.c:38:    as->Free = elzmaFree;    
zmat/easylzma/common_internal.c:39:    as->clientMallocFunc = clientMallocFunc;
zmat/easylzma/common_internal.c:40:    as->clientMallocContext = clientMallocContext;    
zmat/easylzma/common_internal.c:41:    as->clientFreeFunc = clientFreeFunc;
zmat/easylzma/common_internal.c:42:    as->clientFreeContext = clientFreeContext;    
zmat/easylzma/pavlov/LzmaDec.h:1:/* LzmaDec.h -- LZMA Decoder
zmat/easylzma/pavlov/LzmaDec.h:2:2008-10-04 : Igor Pavlov : Public domain */
zmat/easylzma/pavlov/LzmaDec.h:20:/* ---------- LZMA Properties ---------- */
zmat/easylzma/pavlov/LzmaDec.h:30:/* LzmaProps_Decode - decodes properties
zmat/easylzma/pavlov/LzmaDec.h:33:  SZ_ERROR_UNSUPPORTED - Unsupported properties
zmat/easylzma/pavlov/LzmaDec.h:39:/* ---------- LZMA Decoder state ---------- */
zmat/easylzma/pavlov/LzmaDec.h:67:#define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }
zmat/easylzma/pavlov/LzmaDec.h:108:/* ---------- Interfaces ---------- */
zmat/easylzma/pavlov/LzmaDec.h:126:  SZ_ERROR_MEM         - Memory allocation error
zmat/easylzma/pavlov/LzmaDec.h:127:  SZ_ERROR_UNSUPPORTED - Unsupported properties
zmat/easylzma/pavlov/LzmaDec.h:136:/* ---------- Dictionary Interface ---------- */
zmat/easylzma/pavlov/LzmaDec.h:164:  LZMA_FINISH_ANY - Decode just dicLimit bytes.
zmat/easylzma/pavlov/LzmaDec.h:165:  LZMA_FINISH_END - Stream must be finished after dicLimit.
zmat/easylzma/pavlov/LzmaDec.h:174:  SZ_ERROR_DATA - Data error
zmat/easylzma/pavlov/LzmaDec.h:181:/* ---------- Buffer Interface ---------- */
zmat/easylzma/pavlov/LzmaDec.h:183:/* It's zlib-like interface.
zmat/easylzma/pavlov/LzmaDec.h:190:  LZMA_FINISH_ANY - Decode just destLen bytes.
zmat/easylzma/pavlov/LzmaDec.h:191:  LZMA_FINISH_END - Stream must be finished after (*destLen).
zmat/easylzma/pavlov/LzmaDec.h:198:/* ---------- One Call Interface ---------- */
zmat/easylzma/pavlov/LzmaDec.h:204:  LZMA_FINISH_ANY - Decode just destLen bytes.
zmat/easylzma/pavlov/LzmaDec.h:205:  LZMA_FINISH_END - Stream must be finished after (*destLen).
zmat/easylzma/pavlov/LzmaDec.h:213:  SZ_ERROR_DATA - Data error
zmat/easylzma/pavlov/LzmaDec.h:214:  SZ_ERROR_MEM  - Memory allocation error
zmat/easylzma/pavlov/LzmaDec.h:215:  SZ_ERROR_UNSUPPORTED - Unsupported properties
zmat/easylzma/pavlov/LzmaDec.h:216:  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
zmat/easylzma/pavlov/Types.h:1:/* Types.h -- Basic types
zmat/easylzma/pavlov/Types.h:2:2008-11-23 : Igor Pavlov : Public domain */
zmat/easylzma/pavlov/Types.h:57:/* define _SZ_NO_INT_64, if your compiler doesn't support 64-bit integers.
zmat/easylzma/pavlov/Types.h:124:    /* Returns: result - the number of actually written bytes.
zmat/easylzma/pavlov/Types.h:196:       Value (UInt64)(Int64)-1 for size means unknown value. */
zmat/easylzma/pavlov/Types.h:205:#define IAlloc_Alloc(p, size) (p)->Alloc((p), size)
zmat/easylzma/pavlov/Types.h:206:#define IAlloc_Free(p, a) (p)->Free((p), a)
zmat/easylzma/pavlov/LzFind.h:1:/* LzFind.h -- Match finder for LZ algorithms
zmat/easylzma/pavlov/LzFind.h:2:2008-10-04 : Igor Pavlov : Public domain */
zmat/easylzma/pavlov/LzFind.h:49:#define Inline_MatchFinder_GetPointerToCurrentPos(p) ((p)->buffer)
zmat/easylzma/pavlov/LzFind.h:50:#define Inline_MatchFinder_GetIndexByte(p, index) ((p)->buffer[(Int32)(index)])
zmat/easylzma/pavlov/LzFind.h:52:#define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)
zmat/easylzma/pavlov/7zFile.c:1:/* 7zFile.c -- File IO
zmat/easylzma/pavlov/7zFile.c:2:2008-11-22 : Igor Pavlov : Public domain */
zmat/easylzma/pavlov/7zFile.c:16:   If you Read or Write 64MB or more (probably min_failure_size = 64MB - 32KB + 1)
zmat/easylzma/pavlov/7zFile.c:31:  p->handle = INVALID_HANDLE_VALUE;
zmat/easylzma/pavlov/7zFile.c:33:  p->file = NULL;
zmat/easylzma/pavlov/7zFile.c:40:  p->handle = CreateFileA(name,
zmat/easylzma/pavlov/7zFile.c:45:  return (p->handle != INVALID_HANDLE_VALUE) ? 0 : GetLastError();
zmat/easylzma/pavlov/7zFile.c:47:  p->file = fopen(name, writeMode ? "wb+" : "rb");
zmat/easylzma/pavlov/7zFile.c:48:  return (p->file != 0) ? 0 : errno;
zmat/easylzma/pavlov/7zFile.c:58:  if (p->handle != INVALID_HANDLE_VALUE)
zmat/easylzma/pavlov/7zFile.c:60:    if (!CloseHandle(p->handle))
zmat/easylzma/pavlov/7zFile.c:62:    p->handle = INVALID_HANDLE_VALUE;
zmat/easylzma/pavlov/7zFile.c:65:  if (p->file != NULL)
zmat/easylzma/pavlov/7zFile.c:67:    int res = fclose(p->file);
zmat/easylzma/pavlov/7zFile.c:70:    p->file = NULL;
zmat/easylzma/pavlov/7zFile.c:89:    BOOL res = ReadFile(p->handle, data, curSize, &processed, NULL);
zmat/easylzma/pavlov/7zFile.c:91:    originalSize -= processed;
zmat/easylzma/pavlov/7zFile.c:103:  *size = fread(data, 1, originalSize, p->file);
zmat/easylzma/pavlov/7zFile.c:106:  return ferror(p->file);
zmat/easylzma/pavlov/7zFile.c:124:    BOOL res = WriteFile(p->handle, data, curSize, &processed, NULL);
zmat/easylzma/pavlov/7zFile.c:126:    originalSize -= processed;
zmat/easylzma/pavlov/7zFile.c:138:  *size = fwrite(data, 1, originalSize, p->file);
zmat/easylzma/pavlov/7zFile.c:141:  return ferror(p->file);
zmat/easylzma/pavlov/7zFile.c:153:  value.HighPart = (LONG)((UInt64)*pos >> 16 >> 16); /* for case when UInt64 is 32-bit only */
zmat/easylzma/pavlov/7zFile.c:161:  value.LowPart = SetFilePointer(p->handle, value.LowPart, &value.HighPart, moveMethod);
zmat/easylzma/pavlov/7zFile.c:182:  res = fseek(p->file, (long)*pos, moveMethod);
zmat/easylzma/pavlov/7zFile.c:183:  *pos = ftell(p->file);
zmat/easylzma/pavlov/7zFile.c:194:  DWORD sizeLow = GetFileSize(p->handle, &sizeHigh);
zmat/easylzma/pavlov/7zFile.c:206:  long pos = ftell(p->file);
zmat/easylzma/pavlov/7zFile.c:207:  int res = fseek(p->file, 0, SEEK_END);
zmat/easylzma/pavlov/7zFile.c:208:  *length = ftell(p->file);
zmat/easylzma/pavlov/7zFile.c:209:  fseek(p->file, pos, SEEK_SET);
zmat/easylzma/pavlov/7zFile.c:216:/* ---------- FileSeqInStream ---------- */
zmat/easylzma/pavlov/7zFile.c:221:  return File_Read(&p->file, buf, size) == 0 ? SZ_OK : SZ_ERROR_READ;
zmat/easylzma/pavlov/7zFile.c:226:  p->s.Read = FileSeqInStream_Read;
zmat/easylzma/pavlov/7zFile.c:230:/* ---------- FileInStream ---------- */
zmat/easylzma/pavlov/7zFile.c:235:  return (File_Read(&p->file, buf, size) == 0) ? SZ_OK : SZ_ERROR_READ;
zmat/easylzma/pavlov/7zFile.c:241:  return File_Seek(&p->file, pos, origin);
zmat/easylzma/pavlov/7zFile.c:246:  p->s.Read = FileInStream_Read;
zmat/easylzma/pavlov/7zFile.c:247:  p->s.Seek = FileInStream_Seek;
zmat/easylzma/pavlov/7zFile.c:251:/* ---------- FileOutStream ---------- */
zmat/easylzma/pavlov/7zFile.c:256:  File_Write(&p->file, data, &size);
zmat/easylzma/pavlov/7zFile.c:262:  p->s.Write = FileOutStream_Write;
zmat/easylzma/pavlov/LzmaLib.h:1:/* LzmaLib.h -- LZMA library interface
zmat/easylzma/pavlov/LzmaLib.h:2:2008-08-05
zmat/easylzma/pavlov/LzmaLib.h:36:------------
zmat/easylzma/pavlov/LzmaLib.h:38:outPropsSize -
zmat/easylzma/pavlov/LzmaLib.h:43:  -1  for any from: level, loc, lp, pb, fb, numThreads
zmat/easylzma/pavlov/LzmaLib.h:46:level - compression level: 0 <= level <= 9;
zmat/easylzma/pavlov/LzmaLib.h:63:dictSize - The dictionary size in bytes. The maximum value is
zmat/easylzma/pavlov/LzmaLib.h:64:        128 MB = (1 << 27) bytes for 32-bit version
zmat/easylzma/pavlov/LzmaLib.h:65:          1 GB = (1 << 30) bytes for 64-bit version
zmat/easylzma/pavlov/LzmaLib.h:70:lc - The number of literal context bits (high bits of previous literal).
zmat/easylzma/pavlov/LzmaLib.h:74:lp - The number of literal pos bits (low bits of current position for literals).
zmat/easylzma/pavlov/LzmaLib.h:77:     For example, for 32-bit (4 bytes) periodical data you can use lp=2. Often it's
zmat/easylzma/pavlov/LzmaLib.h:80:pb - The number of pos bits (low bits of current position).
zmat/easylzma/pavlov/LzmaLib.h:84:fb - Word size (the number of fast bytes).
zmat/easylzma/pavlov/LzmaLib.h:89:numThreads - The number of thereads. 1 or 2. The default value is 2.
zmat/easylzma/pavlov/LzmaLib.h:93:  destLen  - processed output size
zmat/easylzma/pavlov/LzmaLib.h:95:  SZ_OK               - OK
zmat/easylzma/pavlov/LzmaLib.h:96:  SZ_ERROR_MEM        - Memory allocation error
zmat/easylzma/pavlov/LzmaLib.h:97:  SZ_ERROR_PARAM      - Incorrect paramater
zmat/easylzma/pavlov/LzmaLib.h:98:  SZ_ERROR_OUTPUT_EOF - output buffer overflow
zmat/easylzma/pavlov/LzmaLib.h:99:  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
zmat/easylzma/pavlov/LzmaLib.h:115:--------------
zmat/easylzma/pavlov/LzmaLib.h:117:  dest     - output data
zmat/easylzma/pavlov/LzmaLib.h:118:  destLen  - output data size
zmat/easylzma/pavlov/LzmaLib.h:119:  src      - input data
zmat/easylzma/pavlov/LzmaLib.h:120:  srcLen   - input data size
zmat/easylzma/pavlov/LzmaLib.h:122:  destLen  - processed output size
zmat/easylzma/pavlov/LzmaLib.h:123:  srcLen   - processed input size
zmat/easylzma/pavlov/LzmaLib.h:125:  SZ_OK                - OK
zmat/easylzma/pavlov/LzmaLib.h:126:  SZ_ERROR_DATA        - Data error
zmat/easylzma/pavlov/LzmaLib.h:127:  SZ_ERROR_MEM         - Memory allocation arror
zmat/easylzma/pavlov/LzmaLib.h:128:  SZ_ERROR_UNSUPPORTED - Unsupported properties
zmat/easylzma/pavlov/LzmaLib.h:129:  SZ_ERROR_INPUT_EOF   - it needs more bytes in input buffer (src)
zmat/easylzma/pavlov/LzmaEnc.h:1:/*  LzmaEnc.h -- LZMA Encoder
zmat/easylzma/pavlov/LzmaEnc.h:2:2008-10-04 : Igor Pavlov : Public domain */
zmat/easylzma/pavlov/LzmaEnc.h:14:  UInt32 dictSize; /* (1 << 12) <= dictSize <= (1 << 27) for 32-bit version
zmat/easylzma/pavlov/LzmaEnc.h:15:                      (1 << 12) <= dictSize <= (1 << 30) for 64-bit version
zmat/easylzma/pavlov/LzmaEnc.h:20:  int algo;        /* 0 - fast, 1 - normal, default = 1 */
zmat/easylzma/pavlov/LzmaEnc.h:22:  int btMode;      /* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 */
zmat/easylzma/pavlov/LzmaEnc.h:25:  unsigned writeEndMark;  /* 0 - do not write EOPM, 1 - write EOPM, default = 0 */
zmat/easylzma/pavlov/LzmaEnc.h:34:/* ---------- CLzmaEncHandle Interface ---------- */
zmat/easylzma/pavlov/LzmaEnc.h:38:  SZ_OK           - OK
zmat/easylzma/pavlov/LzmaEnc.h:39:  SZ_ERROR_MEM    - Memory allocation error
zmat/easylzma/pavlov/LzmaEnc.h:40:  SZ_ERROR_PARAM  - Incorrect paramater in props
zmat/easylzma/pavlov/LzmaEnc.h:41:  SZ_ERROR_WRITE  - Write callback error.
zmat/easylzma/pavlov/LzmaEnc.h:42:  SZ_ERROR_PROGRESS - some break from progress callback
zmat/easylzma/pavlov/LzmaEnc.h:43:  SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)
zmat/easylzma/pavlov/LzmaEnc.h:57:/* ---------- One Call Interface ---------- */
zmat/easylzma/pavlov/LzmaEnc.h:61:  SZ_OK               - OK
zmat/easylzma/pavlov/LzmaEnc.h:62:  SZ_ERROR_MEM        - Memory allocation error
zmat/easylzma/pavlov/LzmaEnc.h:63:  SZ_ERROR_PARAM      - Incorrect paramater
zmat/easylzma/pavlov/LzmaEnc.h:64:  SZ_ERROR_OUTPUT_EOF - output buffer overflow
zmat/easylzma/pavlov/LzmaEnc.h:65:  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
zmat/easylzma/pavlov/7zFile.h:1:/* 7zFile.h -- File IO
zmat/easylzma/pavlov/7zFile.h:2:2008-11-22 : Igor Pavlov : Public domain */
zmat/easylzma/pavlov/7zFile.h:20:/* ---------- File ---------- */
zmat/easylzma/pavlov/7zFile.h:46:/* ---------- FileInStream ---------- */
Binary file zmat/easylzma/pavlov/Bra.o matches
Binary file zmat/easylzma/pavlov/7zCrc.o matches
zmat/easylzma/pavlov/7zVersion.h:5:#define MY_DATE "2008-12-31"
zmat/easylzma/pavlov/7zStream.c:1:/* 7zStream.c -- 7z Stream functions
zmat/easylzma/pavlov/7zStream.c:2:2008-11-23 : Igor Pavlov : Public domain */
zmat/easylzma/pavlov/7zStream.c:13:    RINOK(stream->Read(stream, buf, &processed));
zmat/easylzma/pavlov/7zStream.c:17:    size -= processed;
zmat/easylzma/pavlov/7zStream.c:30:  RINOK(stream->Read(stream, buf, &processed));
zmat/easylzma/pavlov/7zStream.c:37:  return stream->Seek(stream, &t, SZ_SEEK_SET);
zmat/easylzma/pavlov/7zStream.c:45:  RINOK(stream->Look(stream, &lookBuf, size));
zmat/easylzma/pavlov/7zStream.c:47:  return stream->Skip(stream, *size);
zmat/easylzma/pavlov/7zStream.c:55:    RINOK(stream->Read(stream, buf, &processed));
zmat/easylzma/pavlov/7zStream.c:59:    size -= processed;
zmat/easylzma/pavlov/7zStream.c:73:  size_t size2 = p->size - p->pos;
zmat/easylzma/pavlov/7zStream.c:76:    p->pos = 0;
zmat/easylzma/pavlov/7zStream.c:78:    res = p->realStream->Read(p->realStream, p->buf, &size2);
zmat/easylzma/pavlov/7zStream.c:79:    p->size = size2;
zmat/easylzma/pavlov/7zStream.c:83:  *buf = p->buf + p->pos;
zmat/easylzma/pavlov/7zStream.c:91:  size_t size2 = p->size - p->pos;
zmat/easylzma/pavlov/7zStream.c:94:    p->pos = 0;
zmat/easylzma/pavlov/7zStream.c:97:    res = p->realStream->Read(p->realStream, p->buf, size);
zmat/easylzma/pavlov/7zStream.c:98:    size2 = p->size = *size;
zmat/easylzma/pavlov/7zStream.c:102:  *buf = p->buf + p->pos;
zmat/easylzma/pavlov/7zStream.c:109:  p->pos += offset;
zmat/easylzma/pavlov/7zStream.c:116:  size_t rem = p->size - p->pos;
zmat/easylzma/pavlov/7zStream.c:118:    return p->realStream->Read(p->realStream, buf, size);
zmat/easylzma/pavlov/7zStream.c:121:  memcpy(buf, p->buf + p->pos, rem);
zmat/easylzma/pavlov/7zStream.c:122:  p->pos += rem;
zmat/easylzma/pavlov/7zStream.c:130:  p->pos = p->size = 0;
zmat/easylzma/pavlov/7zStream.c:131:  return p->realStream->Seek(p->realStream, pos, origin);
zmat/easylzma/pavlov/7zStream.c:136:  p->s.Look = lookahead ?
zmat/easylzma/pavlov/7zStream.c:139:  p->s.Skip = LookToRead_Skip;
zmat/easylzma/pavlov/7zStream.c:140:  p->s.Read = LookToRead_Read;
zmat/easylzma/pavlov/7zStream.c:141:  p->s.Seek = LookToRead_Seek;
zmat/easylzma/pavlov/7zStream.c:146:  p->pos = p->size = 0;
zmat/easylzma/pavlov/7zStream.c:152:  return LookInStream_LookRead(p->realStream, buf, size);
zmat/easylzma/pavlov/7zStream.c:157:  p->s.Read = SecToLook_Read;
zmat/easylzma/pavlov/7zStream.c:163:  return p->realStream->Read(p->realStream, buf, size);
zmat/easylzma/pavlov/7zStream.c:168:  p->s.Read = SecToRead_Read;
zmat/easylzma/pavlov/Bra86.c:1:/* Bra86.c -- Converter for x86 code (BCJ)
zmat/easylzma/pavlov/Bra86.c:2:2008-10-04 : Igor Pavlov : Public domain */
zmat/easylzma/pavlov/Bra86.c:18:  prevPosT = (SizeT)0 - 1;
zmat/easylzma/pavlov/Bra86.c:23:    Byte *limit = data + size - 4;
zmat/easylzma/pavlov/Bra86.c:27:    bufferPos = (SizeT)(p - data);
zmat/easylzma/pavlov/Bra86.c:30:    prevPosT = bufferPos - prevPosT;
zmat/easylzma/pavlov/Bra86.c:35:      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;
zmat/easylzma/pavlov/Bra86.c:38:        Byte b = p[4 - kMaskToBitNumber[prevMask]];
zmat/easylzma/pavlov/Bra86.c:61:          dest = src - (ip + (UInt32)bufferPos);
zmat/easylzma/pavlov/Bra86.c:65:        b = (Byte)(dest >> (24 - index));
zmat/easylzma/pavlov/Bra86.c:68:        src = dest ^ ((1 << (32 - index)) - 1);
zmat/easylzma/pavlov/Bra86.c:70:      p[4] = (Byte)(~(((dest >> 24) & 1) - 1));
zmat/easylzma/pavlov/Bra86.c:82:  prevPosT = bufferPos - prevPosT;
zmat/easylzma/pavlov/Bra86.c:83:  *state = ((prevPosT > 3) ? 0 : ((prevMask << ((int)prevPosT - 1)) & 0x7));
zmat/easylzma/pavlov/7zBuf.c:1:/* 7zBuf.c -- Byte Buffer
zmat/easylzma/pavlov/7zBuf.c:2:2008-03-28
zmat/easylzma/pavlov/7zBuf.c:10:  p->data = 0;
zmat/easylzma/pavlov/7zBuf.c:11:  p->size = 0;
zmat/easylzma/pavlov/7zBuf.c:16:  p->size = 0;
zmat/easylzma/pavlov/7zBuf.c:19:    p->data = 0;
zmat/easylzma/pavlov/7zBuf.c:22:  p->data = (Byte *)alloc->Alloc(alloc, size);
zmat/easylzma/pavlov/7zBuf.c:23:  if (p->data != 0)
zmat/easylzma/pavlov/7zBuf.c:25:    p->size = size;
zmat/easylzma/pavlov/7zBuf.c:33:  alloc->Free(alloc, p->data);
zmat/easylzma/pavlov/7zBuf.c:34:  p->data = 0;
zmat/easylzma/pavlov/7zBuf.c:35:  p->size = 0;
Binary file zmat/easylzma/pavlov/Alloc.o matches
zmat/easylzma/pavlov/Bra.h:1:/* Bra.h -- Branch converters for executables
zmat/easylzma/pavlov/Bra.h:2:2008-10-04 : Igor Pavlov : Public domain */
zmat/easylzma/pavlov/Bra.h:14:    data     - data buffer
zmat/easylzma/pavlov/Bra.h:15:    size     - size of data
zmat/easylzma/pavlov/Bra.h:16:    ip       - current virtual Instruction Pinter (IP) value
zmat/easylzma/pavlov/Bra.h:17:    state    - state variable for x86 converter
zmat/easylzma/pavlov/Bra.h:18:    encoding - 0 (for decoding), 1 (for encoding)
zmat/easylzma/pavlov/Bra.h:21:    state    - state variable for x86 converter
zmat/easylzma/pavlov/Bra.h:47:      size -= processed;
zmat/easylzma/pavlov/7zBuf2.c:1:/* 7zBuf2.c -- Byte Buffer
zmat/easylzma/pavlov/7zBuf2.c:2:2008-10-04 : Igor Pavlov : Public domain */
zmat/easylzma/pavlov/7zBuf2.c:9:  p->data = 0;
zmat/easylzma/pavlov/7zBuf2.c:10:  p->size = 0;
zmat/easylzma/pavlov/7zBuf2.c:11:  p->pos = 0;
zmat/easylzma/pavlov/7zBuf2.c:16:  p->pos = 0;
zmat/easylzma/pavlov/7zBuf2.c:21:  if (size > p->size - p->pos)
zmat/easylzma/pavlov/7zBuf2.c:23:    size_t newSize = p->pos + size;
zmat/easylzma/pavlov/7zBuf2.c:26:    data = (Byte *)alloc->Alloc(alloc, newSize);
zmat/easylzma/pavlov/7zBuf2.c:29:    p->size = newSize;
zmat/easylzma/pavlov/7zBuf2.c:30:    memcpy(data, p->data, p->pos);
zmat/easylzma/pavlov/7zBuf2.c:31:    alloc->Free(alloc, p->data);
zmat/easylzma/pavlov/7zBuf2.c:32:    p->data = data;
zmat/easylzma/pavlov/7zBuf2.c:34:  memcpy(p->data + p->pos, buf, size);
zmat/easylzma/pavlov/7zBuf2.c:35:  p->pos += size;
zmat/easylzma/pavlov/7zBuf2.c:41:  alloc->Free(alloc, p->data);
zmat/easylzma/pavlov/7zBuf2.c:42:  p->data = 0;
zmat/easylzma/pavlov/7zBuf2.c:43:  p->size = 0;
zmat/easylzma/pavlov/7zBuf2.c:44:  p->pos = 0;
zmat/easylzma/pavlov/LzmaLib.c:1:/* LzmaLib.c -- LZMA library wrapper
zmat/easylzma/pavlov/LzmaLib.c:2:2008-08-05
zmat/easylzma/pavlov/Alloc.h:1:/* Alloc.h -- Memory allocation functions
zmat/easylzma/pavlov/Alloc.h:2:2008-03-13
Binary file zmat/easylzma/pavlov/LzmaLib.o matches
zmat/easylzma/pavlov/7zCrc.h:1:/* 7zCrc.h -- CRC32 calculation
zmat/easylzma/pavlov/7zCrc.h:2:2008-03-13
zmat/easylzma/pavlov/Bcj2.h:1:/* Bcj2.h -- Converter for x86 code (BCJ2)
zmat/easylzma/pavlov/Bcj2.h:2:2008-10-04 : Igor Pavlov : Public domain */
zmat/easylzma/pavlov/Bcj2.h:20:  SZ_ERROR_DATA - Data error
Binary file zmat/easylzma/pavlov/BraIA64.o matches
zmat/easylzma/pavlov/Bcj2.c:1:/* Bcj2.c -- Converter for x86 code (BCJ2)
zmat/easylzma/pavlov/Bcj2.c:2:2008-10-04 : Igor Pavlov : Public domain */
zmat/easylzma/pavlov/Bcj2.c:30:#define UPDATE_0(p) range = bound; *(p) = (CProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits)); NORMALIZE;
zmat/easylzma/pavlov/Bcj2.c:31:#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CProb)(ttt - (ttt >> kNumMoveBits)); NORMALIZE;
zmat/easylzma/pavlov/Bcj2.c:65:    SizeT limit = size0 - inPos;
zmat/easylzma/pavlov/Bcj2.c:66:    if (outSize - outPos < limit)
zmat/easylzma/pavlov/Bcj2.c:67:      limit = outSize - outPos;
zmat/easylzma/pavlov/Bcj2.c:76:      limit--;
zmat/easylzma/pavlov/Bcj2.c:107:        size1 -= 4;
zmat/easylzma/pavlov/Bcj2.c:115:        size2 -= 4;
zmat/easylzma/pavlov/Bcj2.c:118:          ((UInt32)v[2] << 8) | ((UInt32)v[3])) - ((UInt32)outPos + 4);
Binary file zmat/easylzma/pavlov/LzmaEnc.o matches
zmat/easylzma/pavlov/Bra.c:1:/* Bra.c -- Converters for RISC code
zmat/easylzma/pavlov/Bra.c:2:2008-10-04 : Igor Pavlov : Public domain */
zmat/easylzma/pavlov/Bra.c:11:  size -= 4;
zmat/easylzma/pavlov/Bra.c:23:        dest = src - (ip + (UInt32)i);
zmat/easylzma/pavlov/Bra.c:38:  size -= 4;
zmat/easylzma/pavlov/Bra.c:56:        dest = src - (ip + (UInt32)i);
zmat/easylzma/pavlov/Bra.c:74:  size -= 4;
zmat/easylzma/pavlov/Bra.c:88:        dest = src - (ip + (UInt32)i);
zmat/easylzma/pavlov/Bra.c:104:  size -= 4;
zmat/easylzma/pavlov/Bra.c:121:        dest = src - (ip + i);
zmat/easylzma/pavlov/Bra.c:124:      dest = (((0 - ((dest >> 22) & 1)) << 22) & 0x3FFFFFFF) | (dest & 0x3FFFFF) | 0x40000000;
zmat/easylzma/pavlov/LzHash.h:1:/* LzHash.h -- HASH functions for LZ algorithms
zmat/easylzma/pavlov/LzHash.h:2:2008-10-04 : Igor Pavlov : Public domain */
zmat/easylzma/pavlov/LzHash.h:18:  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
zmat/easylzma/pavlov/LzHash.h:19:  hash2Value = temp & (kHash2Size - 1); \
zmat/easylzma/pavlov/LzHash.h:20:  hashValue = (temp ^ ((UInt32)cur[2] << 8)) & p->hashMask; }
zmat/easylzma/pavlov/LzHash.h:23:  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
zmat/easylzma/pavlov/LzHash.h:24:  hash2Value = temp & (kHash2Size - 1); \
zmat/easylzma/pavlov/LzHash.h:25:  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
zmat/easylzma/pavlov/LzHash.h:26:  hashValue = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & p->hashMask; }
zmat/easylzma/pavlov/LzHash.h:29:  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
zmat/easylzma/pavlov/LzHash.h:30:  hash2Value = temp & (kHash2Size - 1); \
zmat/easylzma/pavlov/LzHash.h:31:  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
zmat/easylzma/pavlov/LzHash.h:32:  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)); \
zmat/easylzma/pavlov/LzHash.h:33:  hashValue = (hash4Value ^ (p->crc[cur[4]] << 3)) & p->hashMask; \
zmat/easylzma/pavlov/LzHash.h:34:  hash4Value &= (kHash4Size - 1); }
zmat/easylzma/pavlov/LzHash.h:36:/* #define HASH_ZIP_CALC hashValue = ((cur[0] | ((UInt32)cur[1] << 8)) ^ p->crc[cur[2]]) & 0xFFFF; */
zmat/easylzma/pavlov/LzHash.h:37:#define HASH_ZIP_CALC hashValue = ((cur[2] | ((UInt32)cur[0] << 8)) ^ p->crc[cur[1]]) & 0xFFFF;
zmat/easylzma/pavlov/LzHash.h:41:  hash2Value = (p->crc[cur[0]] ^ cur[1]) & (kHash2Size - 1);
zmat/easylzma/pavlov/LzHash.h:44:  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
zmat/easylzma/pavlov/LzHash.h:45:  hash2Value = temp & (kHash2Size - 1); \
zmat/easylzma/pavlov/LzHash.h:46:  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); }
zmat/easylzma/pavlov/LzHash.h:49:  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
zmat/easylzma/pavlov/LzHash.h:50:  hash2Value = temp & (kHash2Size - 1); \
zmat/easylzma/pavlov/LzHash.h:51:  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
zmat/easylzma/pavlov/LzHash.h:52:  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & (kHash4Size - 1); }
zmat/easylzma/pavlov/7zBuf.h:1:/* 7zBuf.h -- Byte Buffer
zmat/easylzma/pavlov/7zBuf.h:2:2008-10-04 : Igor Pavlov : Public domain */
Binary file zmat/easylzma/pavlov/LzmaDec.o matches
zmat/easylzma/pavlov/LzmaDec.c:1:/* LzmaDec.c -- LZMA Decoder
zmat/easylzma/pavlov/LzmaDec.c:2:2008-11-06 : Igor Pavlov : Public domain */
zmat/easylzma/pavlov/LzmaDec.c:20:#define UPDATE_0(p) range = bound; *(p) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));
zmat/easylzma/pavlov/LzmaDec.c:21:#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CLzmaProb)(ttt - (ttt >> kNumMoveBits));
zmat/easylzma/pavlov/LzmaDec.c:29:  { i = 1; do { TREE_GET_BIT(probs, i); } while (i < limit); i -= limit; }
zmat/easylzma/pavlov/LzmaDec.c:44:  i -= 0x40; }
zmat/easylzma/pavlov/LzmaDec.c:51:#define UPDATE_1_CHECK range -= bound; code -= bound;
zmat/easylzma/pavlov/LzmaDec.c:57:  { i = 1; do { GET_BIT_CHECK(probs + i, i) } while (i < limit); i -= limit; }
zmat/easylzma/pavlov/LzmaDec.c:102:#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
zmat/easylzma/pavlov/LzmaDec.c:110:#define LzmaProps_GetNumProbs(p) ((UInt32)LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((p)->lc + (p)->lp)))
zmat/easylzma/pavlov/LzmaDec.c:124:/* First LZMA-symbol is always decoded.
zmat/easylzma/pavlov/LzmaDec.c:125:And it decodes new LZMA-symbols while (buf < bufLimit), but "buf" is without last normalization
zmat/easylzma/pavlov/LzmaDec.c:128:    SZ_OK - OK
zmat/easylzma/pavlov/LzmaDec.c:129:    SZ_ERROR_DATA - Error
zmat/easylzma/pavlov/LzmaDec.c:130:  p->remainLen:
zmat/easylzma/pavlov/LzmaDec.c:139:  CLzmaProb *probs = p->probs;
zmat/easylzma/pavlov/LzmaDec.c:141:  unsigned state = p->state;
zmat/easylzma/pavlov/LzmaDec.c:142:  UInt32 rep0 = p->reps[0], rep1 = p->reps[1], rep2 = p->reps[2], rep3 = p->reps[3];
zmat/easylzma/pavlov/LzmaDec.c:143:  unsigned pbMask = ((unsigned)1 << (p->prop.pb)) - 1;
zmat/easylzma/pavlov/LzmaDec.c:144:  unsigned lpMask = ((unsigned)1 << (p->prop.lp)) - 1;
zmat/easylzma/pavlov/LzmaDec.c:145:  unsigned lc = p->prop.lc;
zmat/easylzma/pavlov/LzmaDec.c:147:  Byte *dic = p->dic;
zmat/easylzma/pavlov/LzmaDec.c:148:  SizeT dicBufSize = p->dicBufSize;
zmat/easylzma/pavlov/LzmaDec.c:149:  SizeT dicPos = p->dicPos;
zmat/easylzma/pavlov/LzmaDec.c:151:  UInt32 processedPos = p->processedPos;
zmat/easylzma/pavlov/LzmaDec.c:152:  UInt32 checkDicSize = p->checkDicSize;
zmat/easylzma/pavlov/LzmaDec.c:155:  const Byte *buf = p->buf;
zmat/easylzma/pavlov/LzmaDec.c:156:  UInt32 range = p->range;
zmat/easylzma/pavlov/LzmaDec.c:157:  UInt32 code = p->code;
zmat/easylzma/pavlov/LzmaDec.c:174:        (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));
zmat/easylzma/pavlov/LzmaDec.c:183:        unsigned matchByte = p->dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
zmat/easylzma/pavlov/LzmaDec.c:201:      /* if (state < 4) state = 0; else if (state < 10) state -= 3; else state -= 6; */
zmat/easylzma/pavlov/LzmaDec.c:227:            dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
zmat/easylzma/pavlov/LzmaDec.c:305:            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);
zmat/easylzma/pavlov/LzmaDec.c:310:          int numDirectBits = (int)(((distance >> 1) - 1));
zmat/easylzma/pavlov/LzmaDec.c:315:            prob = probs + SpecPos + distance - posSlot - 1;
zmat/easylzma/pavlov/LzmaDec.c:324:              while (--numDirectBits != 0);
zmat/easylzma/pavlov/LzmaDec.c:329:            numDirectBits -= kNumAlignBits;
zmat/easylzma/pavlov/LzmaDec.c:337:                code -= range;
zmat/easylzma/pavlov/LzmaDec.c:338:                t = (0 - ((UInt32)code >> 31)); /* (UInt32)((Int32)code >> 31) */
zmat/easylzma/pavlov/LzmaDec.c:346:                code -= range;
zmat/easylzma/pavlov/LzmaDec.c:351:            while (--numDirectBits != 0);
zmat/easylzma/pavlov/LzmaDec.c:364:              state -= kNumStates;
zmat/easylzma/pavlov/LzmaDec.c:389:        SizeT rem = limit - dicPos;
zmat/easylzma/pavlov/LzmaDec.c:391:        SizeT pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);
zmat/easylzma/pavlov/LzmaDec.c:395:        len -= curLen;
zmat/easylzma/pavlov/LzmaDec.c:399:          ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
zmat/easylzma/pavlov/LzmaDec.c:414:          while (--curLen != 0);
zmat/easylzma/pavlov/LzmaDec.c:421:  p->buf = buf;
zmat/easylzma/pavlov/LzmaDec.c:422:  p->range = range;
zmat/easylzma/pavlov/LzmaDec.c:423:  p->code = code;
zmat/easylzma/pavlov/LzmaDec.c:424:  p->remainLen = len;
zmat/easylzma/pavlov/LzmaDec.c:425:  p->dicPos = dicPos;
zmat/easylzma/pavlov/LzmaDec.c:426:  p->processedPos = processedPos;
zmat/easylzma/pavlov/LzmaDec.c:427:  p->reps[0] = rep0;
zmat/easylzma/pavlov/LzmaDec.c:428:  p->reps[1] = rep1;
zmat/easylzma/pavlov/LzmaDec.c:429:  p->reps[2] = rep2;
zmat/easylzma/pavlov/LzmaDec.c:430:  p->reps[3] = rep3;
zmat/easylzma/pavlov/LzmaDec.c:431:  p->state = state;
zmat/easylzma/pavlov/LzmaDec.c:438:  if (p->remainLen != 0 && p->remainLen < kMatchSpecLenStart)
zmat/easylzma/pavlov/LzmaDec.c:440:    Byte *dic = p->dic;
zmat/easylzma/pavlov/LzmaDec.c:441:    SizeT dicPos = p->dicPos;
zmat/easylzma/pavlov/LzmaDec.c:442:    SizeT dicBufSize = p->dicBufSize;
zmat/easylzma/pavlov/LzmaDec.c:443:    unsigned len = p->remainLen;
zmat/easylzma/pavlov/LzmaDec.c:444:    UInt32 rep0 = p->reps[0];
zmat/easylzma/pavlov/LzmaDec.c:445:    if (limit - dicPos < len)
zmat/easylzma/pavlov/LzmaDec.c:446:      len = (unsigned)(limit - dicPos);
zmat/easylzma/pavlov/LzmaDec.c:448:    if (p->checkDicSize == 0 && p->prop.dicSize - p->processedPos <= len)
zmat/easylzma/pavlov/LzmaDec.c:449:      p->checkDicSize = p->prop.dicSize;
zmat/easylzma/pavlov/LzmaDec.c:451:    p->processedPos += len;
zmat/easylzma/pavlov/LzmaDec.c:452:    p->remainLen -= len;
zmat/easylzma/pavlov/LzmaDec.c:453:    while (len-- != 0)
zmat/easylzma/pavlov/LzmaDec.c:455:      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
zmat/easylzma/pavlov/LzmaDec.c:458:    p->dicPos = dicPos;
zmat/easylzma/pavlov/LzmaDec.c:467:    if (p->checkDicSize == 0)
zmat/easylzma/pavlov/LzmaDec.c:469:      UInt32 rem = p->prop.dicSize - p->processedPos;
zmat/easylzma/pavlov/LzmaDec.c:470:      if (limit - p->dicPos > rem)
zmat/easylzma/pavlov/LzmaDec.c:471:        limit2 = p->dicPos + rem;
zmat/easylzma/pavlov/LzmaDec.c:474:    if (p->processedPos >= p->prop.dicSize)
zmat/easylzma/pavlov/LzmaDec.c:475:      p->checkDicSize = p->prop.dicSize;
zmat/easylzma/pavlov/LzmaDec.c:478:  while (p->dicPos < limit && p->buf < bufLimit && p->remainLen < kMatchSpecLenStart);
zmat/easylzma/pavlov/LzmaDec.c:480:  if (p->remainLen > kMatchSpecLenStart)
zmat/easylzma/pavlov/LzmaDec.c:482:    p->remainLen = kMatchSpecLenStart;
zmat/easylzma/pavlov/LzmaDec.c:497:  UInt32 range = p->range;
zmat/easylzma/pavlov/LzmaDec.c:498:  UInt32 code = p->code;
zmat/easylzma/pavlov/LzmaDec.c:500:  CLzmaProb *probs = p->probs;
zmat/easylzma/pavlov/LzmaDec.c:501:  unsigned state = p->state;
zmat/easylzma/pavlov/LzmaDec.c:508:    unsigned posState = (p->processedPos) & ((1 << p->prop.pb) - 1);
zmat/easylzma/pavlov/LzmaDec.c:515:      /* if (bufLimit - buf >= 7) return DUMMY_LIT; */
zmat/easylzma/pavlov/LzmaDec.c:518:      if (p->checkDicSize != 0 || p->processedPos != 0)
zmat/easylzma/pavlov/LzmaDec.c:520:          ((((p->processedPos) & ((1 << (p->prop.lp)) - 1)) << p->prop.lc) +
zmat/easylzma/pavlov/LzmaDec.c:521:          (p->dic[(p->dicPos == 0 ? p->dicBufSize : p->dicPos) - 1] >> (8 - p->prop.lc))));
zmat/easylzma/pavlov/LzmaDec.c:530:        unsigned matchByte = p->dic[p->dicPos - p->reps[0] +
zmat/easylzma/pavlov/LzmaDec.c:531:            ((p->dicPos < p->reps[0]) ? p->dicBufSize : 0)];
zmat/easylzma/pavlov/LzmaDec.c:642:            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) <<
zmat/easylzma/pavlov/LzmaDec.c:647:          int numDirectBits = ((posSlot >> 1) - 1);
zmat/easylzma/pavlov/LzmaDec.c:649:          /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */
zmat/easylzma/pavlov/LzmaDec.c:653:            prob = probs + SpecPos + ((2 | (posSlot & 1)) << numDirectBits) - posSlot - 1;
zmat/easylzma/pavlov/LzmaDec.c:657:            numDirectBits -= kNumAlignBits;
zmat/easylzma/pavlov/LzmaDec.c:662:              code -= range & (((code - range) >> 31) - 1);
zmat/easylzma/pavlov/LzmaDec.c:663:              /* if (code >= range) code -= range; */
zmat/easylzma/pavlov/LzmaDec.c:665:            while (--numDirectBits != 0);
zmat/easylzma/pavlov/LzmaDec.c:675:            while (--numDirectBits != 0);
zmat/easylzma/pavlov/LzmaDec.c:688:  p->code = ((UInt32)data[1] << 24) | ((UInt32)data[2] << 16) | ((UInt32)data[3] << 8) | ((UInt32)data[4]);
zmat/easylzma/pavlov/LzmaDec.c:689:  p->range = 0xFFFFFFFF;
zmat/easylzma/pavlov/LzmaDec.c:690:  p->needFlush = 0;
zmat/easylzma/pavlov/LzmaDec.c:695:  p->needFlush = 1;
zmat/easylzma/pavlov/LzmaDec.c:696:  p->remainLen = 0;
zmat/easylzma/pavlov/LzmaDec.c:697:  p->tempBufSize = 0;
zmat/easylzma/pavlov/LzmaDec.c:701:    p->processedPos = 0;
zmat/easylzma/pavlov/LzmaDec.c:702:    p->checkDicSize = 0;
zmat/easylzma/pavlov/LzmaDec.c:703:    p->needInitState = 1;
zmat/easylzma/pavlov/LzmaDec.c:706:    p->needInitState = 1;
zmat/easylzma/pavlov/LzmaDec.c:711:  p->dicPos = 0;
zmat/easylzma/pavlov/LzmaDec.c:717:  UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (p->prop.lc + p->prop.lp));
zmat/easylzma/pavlov/LzmaDec.c:719:  CLzmaProb *probs = p->probs;
zmat/easylzma/pavlov/LzmaDec.c:722:  p->reps[0] = p->reps[1] = p->reps[2] = p->reps[3] = 1;
zmat/easylzma/pavlov/LzmaDec.c:723:  p->state = 0;
zmat/easylzma/pavlov/LzmaDec.c:724:  p->needInitState = 0;
zmat/easylzma/pavlov/LzmaDec.c:736:  while (p->remainLen != kMatchSpecLenStart)
zmat/easylzma/pavlov/LzmaDec.c:740:      if (p->needFlush != 0)
zmat/easylzma/pavlov/LzmaDec.c:742:        for (; inSize > 0 && p->tempBufSize < RC_INIT_SIZE; (*srcLen)++, inSize--)
zmat/easylzma/pavlov/LzmaDec.c:743:          p->tempBuf[p->tempBufSize++] = *src++;
zmat/easylzma/pavlov/LzmaDec.c:744:        if (p->tempBufSize < RC_INIT_SIZE)
zmat/easylzma/pavlov/LzmaDec.c:749:        if (p->tempBuf[0] != 0)
zmat/easylzma/pavlov/LzmaDec.c:752:        LzmaDec_InitRc(p, p->tempBuf);
zmat/easylzma/pavlov/LzmaDec.c:753:        p->tempBufSize = 0;
zmat/easylzma/pavlov/LzmaDec.c:757:      if (p->dicPos >= dicLimit)
zmat/easylzma/pavlov/LzmaDec.c:759:        if (p->remainLen == 0 && p->code == 0)
zmat/easylzma/pavlov/LzmaDec.c:769:        if (p->remainLen != 0)
zmat/easylzma/pavlov/LzmaDec.c:777:      if (p->needInitState)
zmat/easylzma/pavlov/LzmaDec.c:780:      if (p->tempBufSize == 0)
zmat/easylzma/pavlov/LzmaDec.c:789:            memcpy(p->tempBuf, src, inSize);
zmat/easylzma/pavlov/LzmaDec.c:790:            p->tempBufSize = (unsigned)inSize;
zmat/easylzma/pavlov/LzmaDec.c:803:          bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;
zmat/easylzma/pavlov/LzmaDec.c:804:        p->buf = src;
zmat/easylzma/pavlov/LzmaDec.c:807:        processed = (SizeT)(p->buf - src);
zmat/easylzma/pavlov/LzmaDec.c:810:        inSize -= processed;
zmat/easylzma/pavlov/LzmaDec.c:814:        unsigned rem = p->tempBufSize, lookAhead = 0;
zmat/easylzma/pavlov/LzmaDec.c:816:          p->tempBuf[rem++] = src[lookAhead++];
zmat/easylzma/pavlov/LzmaDec.c:817:        p->tempBufSize = rem;
zmat/easylzma/pavlov/LzmaDec.c:820:          int dummyRes = LzmaDec_TryDummy(p, p->tempBuf, rem);
zmat/easylzma/pavlov/LzmaDec.c:833:        p->buf = p->tempBuf;
zmat/easylzma/pavlov/LzmaDec.c:834:        if (LzmaDec_DecodeReal2(p, dicLimit, p->buf) != 0)
zmat/easylzma/pavlov/LzmaDec.c:836:        lookAhead -= (rem - (unsigned)(p->buf - p->tempBuf));
zmat/easylzma/pavlov/LzmaDec.c:839:        inSize -= lookAhead;
zmat/easylzma/pavlov/LzmaDec.c:840:        p->tempBufSize = 0;
zmat/easylzma/pavlov/LzmaDec.c:843:  if (p->code == 0)
zmat/easylzma/pavlov/LzmaDec.c:845:  return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
zmat/easylzma/pavlov/LzmaDec.c:858:    if (p->dicPos == p->dicBufSize)
zmat/easylzma/pavlov/LzmaDec.c:859:      p->dicPos = 0;
zmat/easylzma/pavlov/LzmaDec.c:860:    dicPos = p->dicPos;
zmat/easylzma/pavlov/LzmaDec.c:861:    if (outSize > p->dicBufSize - dicPos)
zmat/easylzma/pavlov/LzmaDec.c:863:      outSizeCur = p->dicBufSize;
zmat/easylzma/pavlov/LzmaDec.c:874:    inSize -= inSizeCur;
zmat/easylzma/pavlov/LzmaDec.c:876:    outSizeCur = p->dicPos - dicPos;
zmat/easylzma/pavlov/LzmaDec.c:877:    memcpy(dest, p->dic + dicPos, outSizeCur);
zmat/easylzma/pavlov/LzmaDec.c:879:    outSize -= outSizeCur;
zmat/easylzma/pavlov/LzmaDec.c:890:  alloc->Free(alloc, p->probs);
zmat/easylzma/pavlov/LzmaDec.c:891:  p->probs = 0;
zmat/easylzma/pavlov/LzmaDec.c:896:  alloc->Free(alloc, p->dic);
zmat/easylzma/pavlov/LzmaDec.c:897:  p->dic = 0;
zmat/easylzma/pavlov/LzmaDec.c:918:  p->dicSize = dicSize;
zmat/easylzma/pavlov/LzmaDec.c:924:  p->lc = d % 9;
zmat/easylzma/pavlov/LzmaDec.c:926:  p->pb = d / 5;
zmat/easylzma/pavlov/LzmaDec.c:927:  p->lp = d % 5;
zmat/easylzma/pavlov/LzmaDec.c:935:  if (p->probs == 0 || numProbs != p->numProbs)
zmat/easylzma/pavlov/LzmaDec.c:938:    p->probs = (CLzmaProb *)alloc->Alloc(alloc, numProbs * sizeof(CLzmaProb));
zmat/easylzma/pavlov/LzmaDec.c:939:    p->numProbs = numProbs;
zmat/easylzma/pavlov/LzmaDec.c:940:    if (p->probs == 0)
zmat/easylzma/pavlov/LzmaDec.c:951:  p->prop = propNew;
zmat/easylzma/pavlov/LzmaDec.c:962:  if (p->dic == 0 || dicBufSize != p->dicBufSize)
zmat/easylzma/pavlov/LzmaDec.c:965:    p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
zmat/easylzma/pavlov/LzmaDec.c:966:    if (p->dic == 0)
zmat/easylzma/pavlov/LzmaDec.c:972:  p->dicBufSize = dicBufSize;
zmat/easylzma/pavlov/LzmaDec.c:973:  p->prop = propNew;
zmat/easylzma/pavlov/LzFind.c:1:/* LzFind.c -- Match finder for LZ algorithms
zmat/easylzma/pavlov/LzFind.c:2:2008-10-04 : Igor Pavlov : Public domain */
zmat/easylzma/pavlov/LzFind.c:12:#define kNormalizeMask (~(kNormalizeStepMin - 1))
zmat/easylzma/pavlov/LzFind.c:19:  if (!p->directInput)
zmat/easylzma/pavlov/LzFind.c:21:    alloc->Free(alloc, p->bufferBase);
zmat/easylzma/pavlov/LzFind.c:22:    p->bufferBase = 0;
zmat/easylzma/pavlov/LzFind.c:30:  UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;
zmat/easylzma/pavlov/LzFind.c:31:  if (p->directInput)
zmat/easylzma/pavlov/LzFind.c:33:    p->blockSize = blockSize;
zmat/easylzma/pavlov/LzFind.c:36:  if (p->bufferBase == 0 || p->blockSize != blockSize)
zmat/easylzma/pavlov/LzFind.c:39:    p->blockSize = blockSize;
zmat/easylzma/pavlov/LzFind.c:40:    p->bufferBase = (Byte *)alloc->Alloc(alloc, (size_t)blockSize);
zmat/easylzma/pavlov/LzFind.c:42:  return (p->bufferBase != 0);
zmat/easylzma/pavlov/LzFind.c:45:Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
zmat/easylzma/pavlov/LzFind.c:46:Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
zmat/easylzma/pavlov/LzFind.c:48:UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
zmat/easylzma/pavlov/LzFind.c:52:  p->posLimit -= subValue;
zmat/easylzma/pavlov/LzFind.c:53:  p->pos -= subValue;
zmat/easylzma/pavlov/LzFind.c:54:  p->streamPos -= subValue;
zmat/easylzma/pavlov/LzFind.c:59:  if (p->streamEndWasReached || p->result != SZ_OK)
zmat/easylzma/pavlov/LzFind.c:63:    Byte *dest = p->buffer + (p->streamPos - p->pos);
zmat/easylzma/pavlov/LzFind.c:64:    size_t size = (p->bufferBase + p->blockSize - dest);
zmat/easylzma/pavlov/LzFind.c:67:    p->result = p->stream->Read(p->stream, dest, &size);
zmat/easylzma/pavlov/LzFind.c:68:    if (p->result != SZ_OK)
zmat/easylzma/pavlov/LzFind.c:72:      p->streamEndWasReached = 1;
zmat/easylzma/pavlov/LzFind.c:75:    p->streamPos += (UInt32)size;
zmat/easylzma/pavlov/LzFind.c:76:    if (p->streamPos - p->pos > p->keepSizeAfter)
zmat/easylzma/pavlov/LzFind.c:83:  memmove(p->bufferBase,
zmat/easylzma/pavlov/LzFind.c:84:    p->buffer - p->keepSizeBefore,
zmat/easylzma/pavlov/LzFind.c:85:    (size_t)(p->streamPos - p->pos + p->keepSizeBefore));
zmat/easylzma/pavlov/LzFind.c:86:  p->buffer = p->bufferBase + p->keepSizeBefore;
zmat/easylzma/pavlov/LzFind.c:91:  /* if (p->streamEndWasReached) return 0; */
zmat/easylzma/pavlov/LzFind.c:92:  return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);
zmat/easylzma/pavlov/LzFind.c:97:  if (p->streamEndWasReached)
zmat/easylzma/pavlov/LzFind.c:99:  if (p->keepSizeAfter >= p->streamPos - p->pos)
zmat/easylzma/pavlov/LzFind.c:112:  p->cutValue = 32;
zmat/easylzma/pavlov/LzFind.c:113:  p->btMode = 1;
zmat/easylzma/pavlov/LzFind.c:114:  p->numHashBytes = 4;
zmat/easylzma/pavlov/LzFind.c:115:  /* p->skipModeBits = 0; */
zmat/easylzma/pavlov/LzFind.c:116:  p->directInput = 0;
zmat/easylzma/pavlov/LzFind.c:117:  p->bigHash = 0;
zmat/easylzma/pavlov/LzFind.c:125:  p->bufferBase = 0;
zmat/easylzma/pavlov/LzFind.c:126:  p->directInput = 0;
zmat/easylzma/pavlov/LzFind.c:127:  p->hash = 0;
zmat/easylzma/pavlov/LzFind.c:135:      r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));
zmat/easylzma/pavlov/LzFind.c:136:    p->crc[i] = r;
zmat/easylzma/pavlov/LzFind.c:142:  alloc->Free(alloc, p->hash);
zmat/easylzma/pavlov/LzFind.c:143:  p->hash = 0;
zmat/easylzma/pavlov/LzFind.c:157:  return (CLzRef *)alloc->Alloc(alloc, sizeInBytes);
zmat/easylzma/pavlov/LzFind.c:175:  p->keepSizeBefore = historySize + keepAddBufferBefore + 1;
zmat/easylzma/pavlov/LzFind.c:176:  p->keepSizeAfter = matchMaxLen + keepAddBufferAfter;
zmat/easylzma/pavlov/LzFind.c:180:    UInt32 newCyclicBufferSize = (historySize /* >> p->skipModeBits */) + 1;
zmat/easylzma/pavlov/LzFind.c:182:    p->matchMaxLen = matchMaxLen;
zmat/easylzma/pavlov/LzFind.c:184:      p->fixedHashSize = 0;
zmat/easylzma/pavlov/LzFind.c:185:      if (p->numHashBytes == 2)
zmat/easylzma/pavlov/LzFind.c:186:        hs = (1 << 16) - 1;
zmat/easylzma/pavlov/LzFind.c:189:        hs = historySize - 1;
zmat/easylzma/pavlov/LzFind.c:195:        /* hs >>= p->skipModeBits; */
zmat/easylzma/pavlov/LzFind.c:199:          if (p->numHashBytes == 3)
zmat/easylzma/pavlov/LzFind.c:200:            hs = (1 << 24) - 1;
zmat/easylzma/pavlov/LzFind.c:205:      p->hashMask = hs;
zmat/easylzma/pavlov/LzFind.c:207:      if (p->numHashBytes > 2) p->fixedHashSize += kHash2Size;
zmat/easylzma/pavlov/LzFind.c:208:      if (p->numHashBytes > 3) p->fixedHashSize += kHash3Size;
zmat/easylzma/pavlov/LzFind.c:209:      if (p->numHashBytes > 4) p->fixedHashSize += kHash4Size;
zmat/easylzma/pavlov/LzFind.c:210:      hs += p->fixedHashSize;
zmat/easylzma/pavlov/LzFind.c:214:      UInt32 prevSize = p->hashSizeSum + p->numSons;
zmat/easylzma/pavlov/LzFind.c:216:      p->historySize = historySize;
zmat/easylzma/pavlov/LzFind.c:217:      p->hashSizeSum = hs;
zmat/easylzma/pavlov/LzFind.c:218:      p->cyclicBufferSize = newCyclicBufferSize;
zmat/easylzma/pavlov/LzFind.c:219:      p->numSons = (p->btMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);
zmat/easylzma/pavlov/LzFind.c:220:      newSize = p->hashSizeSum + p->numSons;
zmat/easylzma/pavlov/LzFind.c:221:      if (p->hash != 0 && prevSize == newSize)
zmat/easylzma/pavlov/LzFind.c:224:      p->hash = AllocRefs(newSize, alloc);
zmat/easylzma/pavlov/LzFind.c:225:      if (p->hash != 0)
zmat/easylzma/pavlov/LzFind.c:227:        p->son = p->hash + p->hashSizeSum;
zmat/easylzma/pavlov/LzFind.c:238:  UInt32 limit = kMaxValForNormalize - p->pos;
zmat/easylzma/pavlov/LzFind.c:239:  UInt32 limit2 = p->cyclicBufferSize - p->cyclicBufferPos;
zmat/easylzma/pavlov/LzFind.c:242:  limit2 = p->streamPos - p->pos;
zmat/easylzma/pavlov/LzFind.c:243:  if (limit2 <= p->keepSizeAfter)
zmat/easylzma/pavlov/LzFind.c:249:    limit2 -= p->keepSizeAfter;
zmat/easylzma/pavlov/LzFind.c:253:    UInt32 lenLimit = p->streamPos - p->pos;
zmat/easylzma/pavlov/LzFind.c:254:    if (lenLimit > p->matchMaxLen)
zmat/easylzma/pavlov/LzFind.c:255:      lenLimit = p->matchMaxLen;
zmat/easylzma/pavlov/LzFind.c:256:    p->lenLimit = lenLimit;
zmat/easylzma/pavlov/LzFind.c:258:  p->posLimit = p->pos + limit;
zmat/easylzma/pavlov/LzFind.c:264:  for (i = 0; i < p->hashSizeSum; i++)
zmat/easylzma/pavlov/LzFind.c:265:    p->hash[i] = kEmptyHashValue;
zmat/easylzma/pavlov/LzFind.c:266:  p->cyclicBufferPos = 0;
zmat/easylzma/pavlov/LzFind.c:267:  p->buffer = p->bufferBase;
zmat/easylzma/pavlov/LzFind.c:268:  p->pos = p->streamPos = p->cyclicBufferSize;
zmat/easylzma/pavlov/LzFind.c:269:  p->result = SZ_OK;
zmat/easylzma/pavlov/LzFind.c:270:  p->streamEndWasReached = 0;
zmat/easylzma/pavlov/LzFind.c:277:  return (p->pos - p->historySize - 1) & kNormalizeMask;
zmat/easylzma/pavlov/LzFind.c:289:      value -= subValue;
zmat/easylzma/pavlov/LzFind.c:297:  MatchFinder_Normalize3(subValue, p->hash, p->hashSizeSum + p->numSons);
zmat/easylzma/pavlov/LzFind.c:303:  if (p->pos == kMaxValForNormalize)
zmat/easylzma/pavlov/LzFind.c:305:  if (!p->streamEndWasReached && p->keepSizeAfter == p->streamPos - p->pos)
zmat/easylzma/pavlov/LzFind.c:307:  if (p->cyclicBufferPos == p->cyclicBufferSize)
zmat/easylzma/pavlov/LzFind.c:308:    p->cyclicBufferPos = 0;
zmat/easylzma/pavlov/LzFind.c:319:    UInt32 delta = pos - curMatch;
zmat/easylzma/pavlov/LzFind.c:320:    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
zmat/easylzma/pavlov/LzFind.c:323:      const Byte *pb = cur - delta;
zmat/easylzma/pavlov/LzFind.c:324:      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
zmat/easylzma/pavlov/LzFind.c:334:          *distances++ = delta - 1;
zmat/easylzma/pavlov/LzFind.c:352:    UInt32 delta = pos - curMatch;
zmat/easylzma/pavlov/LzFind.c:353:    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
zmat/easylzma/pavlov/LzFind.c:359:      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
zmat/easylzma/pavlov/LzFind.c:360:      const Byte *pb = cur - delta;
zmat/easylzma/pavlov/LzFind.c:371:          *distances++ = delta - 1;
zmat/easylzma/pavlov/LzFind.c:406:    UInt32 delta = pos - curMatch;
zmat/easylzma/pavlov/LzFind.c:407:    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
zmat/easylzma/pavlov/LzFind.c:413:      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
zmat/easylzma/pavlov/LzFind.c:414:      const Byte *pb = cur - delta;
zmat/easylzma/pavlov/LzFind.c:449:  ++p->cyclicBufferPos; \
zmat/easylzma/pavlov/LzFind.c:450:  p->buffer++; \
zmat/easylzma/pavlov/LzFind.c:451:  if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);
zmat/easylzma/pavlov/LzFind.c:459:  lenLimit = p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} \
zmat/easylzma/pavlov/LzFind.c:460:  cur = p->buffer;
zmat/easylzma/pavlov/LzFind.c:465:#define MF_PARAMS(p) p->pos, p->buffer, p->son, p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue
zmat/easylzma/pavlov/LzFind.c:469:  distances + offset, maxLen) - distances); MOVE_POS_RET;
zmat/easylzma/pavlov/LzFind.c:479:  curMatch = p->hash[hashValue];
zmat/easylzma/pavlov/LzFind.c:480:  p->hash[hashValue] = p->pos;
zmat/easylzma/pavlov/LzFind.c:490:  curMatch = p->hash[hashValue];
zmat/easylzma/pavlov/LzFind.c:491:  p->hash[hashValue] = p->pos;
zmat/easylzma/pavlov/LzFind.c:503:  delta2 = p->pos - p->hash[hash2Value];
zmat/easylzma/pavlov/LzFind.c:504:  curMatch = p->hash[kFix3HashSize + hashValue];
zmat/easylzma/pavlov/LzFind.c:506:  p->hash[hash2Value] =
zmat/easylzma/pavlov/LzFind.c:507:  p->hash[kFix3HashSize + hashValue] = p->pos;
zmat/easylzma/pavlov/LzFind.c:512:  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
zmat/easylzma/pavlov/LzFind.c:515:      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
zmat/easylzma/pavlov/LzFind.c:518:    distances[1] = delta2 - 1;
zmat/easylzma/pavlov/LzFind.c:536:  delta2 = p->pos - p->hash[                hash2Value];
zmat/easylzma/pavlov/LzFind.c:537:  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
zmat/easylzma/pavlov/LzFind.c:538:  curMatch = p->hash[kFix4HashSize + hashValue];
zmat/easylzma/pavlov/LzFind.c:540:  p->hash[                hash2Value] =
zmat/easylzma/pavlov/LzFind.c:541:  p->hash[kFix3HashSize + hash3Value] =
zmat/easylzma/pavlov/LzFind.c:542:  p->hash[kFix4HashSize + hashValue] = p->pos;
zmat/easylzma/pavlov/LzFind.c:546:  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
zmat/easylzma/pavlov/LzFind.c:549:    distances[1] = delta2 - 1;
zmat/easylzma/pavlov/LzFind.c:552:  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
zmat/easylzma/pavlov/LzFind.c:555:    distances[offset + 1] = delta3 - 1;
zmat/easylzma/pavlov/LzFind.c:562:      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
zmat/easylzma/pavlov/LzFind.c:564:    distances[offset - 2] = maxLen;
zmat/easylzma/pavlov/LzFind.c:583:  delta2 = p->pos - p->hash[                hash2Value];
zmat/easylzma/pavlov/LzFind.c:584:  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
zmat/easylzma/pavlov/LzFind.c:585:  curMatch = p->hash[kFix4HashSize + hashValue];
zmat/easylzma/pavlov/LzFind.c:587:  p->hash[                hash2Value] =
zmat/easylzma/pavlov/LzFind.c:588:  p->hash[kFix3HashSize + hash3Value] =
zmat/easylzma/pavlov/LzFind.c:589:  p->hash[kFix4HashSize + hashValue] = p->pos;
zmat/easylzma/pavlov/LzFind.c:593:  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
zmat/easylzma/pavlov/LzFind.c:596:    distances[1] = delta2 - 1;
zmat/easylzma/pavlov/LzFind.c:599:  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
zmat/easylzma/pavlov/LzFind.c:602:    distances[offset + 1] = delta3 - 1;
zmat/easylzma/pavlov/LzFind.c:609:      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
zmat/easylzma/pavlov/LzFind.c:611:    distances[offset - 2] = maxLen;
zmat/easylzma/pavlov/LzFind.c:614:      p->son[p->cyclicBufferPos] = curMatch;
zmat/easylzma/pavlov/LzFind.c:621:    distances + offset, maxLen) - (distances));
zmat/easylzma/pavlov/LzFind.c:630:  curMatch = p->hash[hashValue];
zmat/easylzma/pavlov/LzFind.c:631:  p->hash[hashValue] = p->pos;
zmat/easylzma/pavlov/LzFind.c:633:    distances, 2) - (distances));
zmat/easylzma/pavlov/LzFind.c:643:    curMatch = p->hash[hashValue];
zmat/easylzma/pavlov/LzFind.c:644:    p->hash[hashValue] = p->pos;
zmat/easylzma/pavlov/LzFind.c:647:  while (--num != 0);
zmat/easylzma/pavlov/LzFind.c:656:    curMatch = p->hash[hashValue];
zmat/easylzma/pavlov/LzFind.c:657:    p->hash[hashValue] = p->pos;
zmat/easylzma/pavlov/LzFind.c:660:  while (--num != 0);
zmat/easylzma/pavlov/LzFind.c:670:    curMatch = p->hash[kFix3HashSize + hashValue];
zmat/easylzma/pavlov/LzFind.c:671:    p->hash[hash2Value] =
zmat/easylzma/pavlov/LzFind.c:672:    p->hash[kFix3HashSize + hashValue] = p->pos;
zmat/easylzma/pavlov/LzFind.c:675:  while (--num != 0);
zmat/easylzma/pavlov/LzFind.c:685:    curMatch = p->hash[kFix4HashSize + hashValue];
zmat/easylzma/pavlov/LzFind.c:686:    p->hash[                hash2Value] =
zmat/easylzma/pavlov/LzFind.c:687:    p->hash[kFix3HashSize + hash3Value] = p->pos;
zmat/easylzma/pavlov/LzFind.c:688:    p->hash[kFix4HashSize + hashValue] = p->pos;
zmat/easylzma/pavlov/LzFind.c:691:  while (--num != 0);
zmat/easylzma/pavlov/LzFind.c:701:    curMatch = p->hash[kFix4HashSize + hashValue];
zmat/easylzma/pavlov/LzFind.c:702:    p->hash[                hash2Value] =
zmat/easylzma/pavlov/LzFind.c:703:    p->hash[kFix3HashSize + hash3Value] =
zmat/easylzma/pavlov/LzFind.c:704:    p->hash[kFix4HashSize + hashValue] = p->pos;
zmat/easylzma/pavlov/LzFind.c:705:    p->son[p->cyclicBufferPos] = curMatch;
zmat/easylzma/pavlov/LzFind.c:708:  while (--num != 0);
zmat/easylzma/pavlov/LzFind.c:717:    curMatch = p->hash[hashValue];
zmat/easylzma/pavlov/LzFind.c:718:    p->hash[hashValue] = p->pos;
zmat/easylzma/pavlov/LzFind.c:719:    p->son[p->cyclicBufferPos] = curMatch;
zmat/easylzma/pavlov/LzFind.c:722:  while (--num != 0);
zmat/easylzma/pavlov/LzFind.c:727:  vTable->Init = (Mf_Init_Func)MatchFinder_Init;
zmat/easylzma/pavlov/LzFind.c:728:  vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
zmat/easylzma/pavlov/LzFind.c:729:  vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
zmat/easylzma/pavlov/LzFind.c:730:  vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
zmat/easylzma/pavlov/LzFind.c:731:  if (!p->btMode)
zmat/easylzma/pavlov/LzFind.c:733:    vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
zmat/easylzma/pavlov/LzFind.c:734:    vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
zmat/easylzma/pavlov/LzFind.c:736:  else if (p->numHashBytes == 2)
zmat/easylzma/pavlov/LzFind.c:738:    vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
zmat/easylzma/pavlov/LzFind.c:739:    vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
zmat/easylzma/pavlov/LzFind.c:741:  else if (p->numHashBytes == 3)
zmat/easylzma/pavlov/LzFind.c:743:    vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
zmat/easylzma/pavlov/LzFind.c:744:    vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
zmat/easylzma/pavlov/LzFind.c:748:    vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
zmat/easylzma/pavlov/LzFind.c:749:    vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
zmat/easylzma/pavlov/7zCrc.c:1:/* 7zCrc.c -- CRC32 calculation
zmat/easylzma/pavlov/7zCrc.c:2:2008-08-05
zmat/easylzma/pavlov/7zCrc.c:19:      r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));
zmat/easylzma/pavlov/7zCrc.c:27:  for (; size > 0 ; size--, p++)
zmat/easylzma/pavlov/LzmaEnc.c:1:/* LzmaEnc.c -- LZMA Encoder
zmat/easylzma/pavlov/LzmaEnc.c:2:2008-10-04 : Igor Pavlov : Public domain */
zmat/easylzma/pavlov/LzmaEnc.c:24:#define kBlockSizeMax ((1 << LZMA_NUM_BLOCK_SIZE_BITS) - 1)
zmat/easylzma/pavlov/LzmaEnc.c:47:  p->level = 5;
zmat/easylzma/pavlov/LzmaEnc.c:48:  p->dictSize = p->mc = 0;
zmat/easylzma/pavlov/LzmaEnc.c:49:  p->lc = p->lp = p->pb = p->algo = p->fb = p->btMode = p->numHashBytes = p->numThreads = -1;
zmat/easylzma/pavlov/LzmaEnc.c:50:  p->writeEndMark = 0;
zmat/easylzma/pavlov/LzmaEnc.c:55:  int level = p->level;
zmat/easylzma/pavlov/LzmaEnc.c:57:  p->level = level;
zmat/easylzma/pavlov/LzmaEnc.c:58:  if (p->dictSize == 0) p->dictSize = (level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 25) : (1 << 26)));
zmat/easylzma/pavlov/LzmaEnc.c:59:  if (p->lc < 0) p->lc = 3;
zmat/easylzma/pavlov/LzmaEnc.c:60:  if (p->lp < 0) p->lp = 0;
zmat/easylzma/pavlov/LzmaEnc.c:61:  if (p->pb < 0) p->pb = 2;
zmat/easylzma/pavlov/LzmaEnc.c:62:  if (p->algo < 0) p->algo = (level < 5 ? 0 : 1);
zmat/easylzma/pavlov/LzmaEnc.c:63:  if (p->fb < 0) p->fb = (level < 7 ? 32 : 64);
zmat/easylzma/pavlov/LzmaEnc.c:64:  if (p->btMode < 0) p->btMode = (p->algo == 0 ? 0 : 1);
zmat/easylzma/pavlov/LzmaEnc.c:65:  if (p->numHashBytes < 0) p->numHashBytes = 4;
zmat/easylzma/pavlov/LzmaEnc.c:66:  if (p->mc == 0)  p->mc = (16 + (p->fb >> 1)) >> (p->btMode ? 0 : 1);
zmat/easylzma/pavlov/LzmaEnc.c:67:  if (p->numThreads < 0) p->numThreads = ((p->btMode && p->algo) ? 2 : 1);
zmat/easylzma/pavlov/LzmaEnc.c:85:#define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&i, (pos)); res = (i + i) + ((pos >> (i - 1)) & 1); }
zmat/easylzma/pavlov/LzmaEnc.c:99:#define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
zmat/easylzma/pavlov/LzmaEnc.c:109:    UInt32 k = (1 << ((slotFast >> 1) - 1));
zmat/easylzma/pavlov/LzmaEnc.c:116:#define BSR2_RET(pos, res) { UInt32 i = 6 + ((kNumLogBits - 1) & \
zmat/easylzma/pavlov/LzmaEnc.c:117:  (0 - (((((UInt32)1 << (kNumLogBits + 6)) - 1) - pos) >> 31))); \
zmat/easylzma/pavlov/LzmaEnc.c:118:  res = p->g_FastPos[pos >> i] + (i * 2); }
zmat/easylzma/pavlov/LzmaEnc.c:121:  p->g_FastPos[pos >> 6] + 12 : \
zmat/easylzma/pavlov/LzmaEnc.c:122:  p->g_FastPos[pos >> (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2; }
zmat/easylzma/pavlov/LzmaEnc.c:125:#define GetPosSlot1(pos) p->g_FastPos[pos]
zmat/easylzma/pavlov/LzmaEnc.c:127:#define GetPosSlot(pos, res) { if (pos < kNumFullDistances) res = p->g_FastPos[pos]; else BSR2_RET(pos, res); }
zmat/easylzma/pavlov/LzmaEnc.c:163:#define kAlignMask (kAlignTableSize - 1)
zmat/easylzma/pavlov/LzmaEnc.c:167:#define kNumPosModels (kEndPosModelIndex - kStartPosModelIndex)
zmat/easylzma/pavlov/LzmaEnc.c:194:#define LZMA_MATCH_LEN_MAX (LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1)
zmat/easylzma/pavlov/LzmaEnc.c:240:  if (p->rem < curSize)
zmat/easylzma/pavlov/LzmaEnc.c:241:    curSize = p->rem;
zmat/easylzma/pavlov/LzmaEnc.c:242:  memcpy(data, p->data, curSize);
zmat/easylzma/pavlov/LzmaEnc.c:243:  p->rem -= curSize;
zmat/easylzma/pavlov/LzmaEnc.c:244:  p->data += curSize;
zmat/easylzma/pavlov/LzmaEnc.c:261:  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
zmat/easylzma/pavlov/LzmaEnc.c:326:  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
zmat/easylzma/pavlov/LzmaEnc.c:357:  CSaveState *dest = &p->saveState;
zmat/easylzma/pavlov/LzmaEnc.c:359:  dest->lenEnc = p->lenEnc;
zmat/easylzma/pavlov/LzmaEnc.c:360:  dest->repLenEnc = p->repLenEnc;
zmat/easylzma/pavlov/LzmaEnc.c:361:  dest->state = p->state;
zmat/easylzma/pavlov/LzmaEnc.c:365:    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
zmat/easylzma/pavlov/LzmaEnc.c:366:    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
zmat/easylzma/pavlov/LzmaEnc.c:369:    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
zmat/easylzma/pavlov/LzmaEnc.c:370:  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
zmat/easylzma/pavlov/LzmaEnc.c:371:  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
zmat/easylzma/pavlov/LzmaEnc.c:372:  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
zmat/easylzma/pavlov/LzmaEnc.c:373:  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
zmat/easylzma/pavlov/LzmaEnc.c:374:  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
zmat/easylzma/pavlov/LzmaEnc.c:375:  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
zmat/easylzma/pavlov/LzmaEnc.c:376:  memcpy(dest->reps, p->reps, sizeof(p->reps));
zmat/easylzma/pavlov/LzmaEnc.c:377:  memcpy(dest->litProbs, p->litProbs, (0x300 << p->lclp) * sizeof(CLzmaProb));
zmat/easylzma/pavlov/LzmaEnc.c:383:  const CSaveState *p = &dest->saveState;
zmat/easylzma/pavlov/LzmaEnc.c:385:  dest->lenEnc = p->lenEnc;
zmat/easylzma/pavlov/LzmaEnc.c:386:  dest->repLenEnc = p->repLenEnc;
zmat/easylzma/pavlov/LzmaEnc.c:387:  dest->state = p->state;
zmat/easylzma/pavlov/LzmaEnc.c:391:    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
zmat/easylzma/pavlov/LzmaEnc.c:392:    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
zmat/easylzma/pavlov/LzmaEnc.c:395:    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
zmat/easylzma/pavlov/LzmaEnc.c:396:  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
zmat/easylzma/pavlov/LzmaEnc.c:397:  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
zmat/easylzma/pavlov/LzmaEnc.c:398:  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
zmat/easylzma/pavlov/LzmaEnc.c:399:  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
zmat/easylzma/pavlov/LzmaEnc.c:400:  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
zmat/easylzma/pavlov/LzmaEnc.c:401:  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
zmat/easylzma/pavlov/LzmaEnc.c:402:  memcpy(dest->reps, p->reps, sizeof(p->reps));
zmat/easylzma/pavlov/LzmaEnc.c:403:  memcpy(dest->litProbs, p->litProbs, (0x300 << dest->lclp) * sizeof(CLzmaProb));
zmat/easylzma/pavlov/LzmaEnc.c:415:  p->dictSize = props.dictSize;
zmat/easylzma/pavlov/LzmaEnc.c:416:  p->matchFinderCycles = props.mc;
zmat/easylzma/pavlov/LzmaEnc.c:423:    p->numFastBytes = fb;
zmat/easylzma/pavlov/LzmaEnc.c:425:  p->lc = props.lc;
zmat/easylzma/pavlov/LzmaEnc.c:426:  p->lp = props.lp;
zmat/easylzma/pavlov/LzmaEnc.c:427:  p->pb = props.pb;
zmat/easylzma/pavlov/LzmaEnc.c:428:  p->fastMode = (props.algo == 0);
zmat/easylzma/pavlov/LzmaEnc.c:429:  p->matchFinderBase.btMode = props.btMode;
zmat/easylzma/pavlov/LzmaEnc.c:439:    p->matchFinderBase.numHashBytes = numHashBytes;
zmat/easylzma/pavlov/LzmaEnc.c:442:  p->matchFinderBase.cutValue = props.mc;
zmat/easylzma/pavlov/LzmaEnc.c:444:  p->writeEndMark = props.writeEndMark;
zmat/easylzma/pavlov/LzmaEnc.c:454:  p->multiThread = (props.numThreads > 1);
zmat/easylzma/pavlov/LzmaEnc.c:467:#define GetLenToPosState(len) (((len) < kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1)
zmat/easylzma/pavlov/LzmaEnc.c:473:  p->outStream = 0;
zmat/easylzma/pavlov/LzmaEnc.c:474:  p->bufBase = 0;
zmat/easylzma/pavlov/LzmaEnc.c:477:#define RangeEnc_GetProcessed(p) ((p)->processed + ((p)->buf - (p)->bufBase) + (p)->cacheSize)
zmat/easylzma/pavlov/LzmaEnc.c:482:  if (p->bufBase == 0)
zmat/easylzma/pavlov/LzmaEnc.c:484:    p->bufBase = (Byte *)alloc->Alloc(alloc, RC_BUF_SIZE);
zmat/easylzma/pavlov/LzmaEnc.c:485:    if (p->bufBase == 0)
zmat/easylzma/pavlov/LzmaEnc.c:487:    p->bufLim = p->bufBase + RC_BUF_SIZE;
zmat/easylzma/pavlov/LzmaEnc.c:494:  alloc->Free(alloc, p->bufBase);
zmat/easylzma/pavlov/LzmaEnc.c:495:  p->bufBase = 0;
zmat/easylzma/pavlov/LzmaEnc.c:501:  p->low = 0;
zmat/easylzma/pavlov/LzmaEnc.c:502:  p->range = 0xFFFFFFFF;
zmat/easylzma/pavlov/LzmaEnc.c:503:  p->cacheSize = 1;
zmat/easylzma/pavlov/LzmaEnc.c:504:  p->cache = 0;
zmat/easylzma/pavlov/LzmaEnc.c:506:  p->buf = p->bufBase;
zmat/easylzma/pavlov/LzmaEnc.c:508:  p->processed = 0;
zmat/easylzma/pavlov/LzmaEnc.c:509:  p->res = SZ_OK;
zmat/easylzma/pavlov/LzmaEnc.c:515:  if (p->res != SZ_OK)
zmat/easylzma/pavlov/LzmaEnc.c:517:  num = p->buf - p->bufBase;
zmat/easylzma/pavlov/LzmaEnc.c:518:  if (num != p->outStream->Write(p->outStream, p->bufBase, num))
zmat/easylzma/pavlov/LzmaEnc.c:519:    p->res = SZ_ERROR_WRITE;
zmat/easylzma/pavlov/LzmaEnc.c:520:  p->processed += num;
zmat/easylzma/pavlov/LzmaEnc.c:521:  p->buf = p->bufBase;
zmat/easylzma/pavlov/LzmaEnc.c:526:  if ((UInt32)p->low < (UInt32)0xFF000000 || (int)(p->low >> 32) != 0)
zmat/easylzma/pavlov/LzmaEnc.c:528:    Byte temp = p->cache;
zmat/easylzma/pavlov/LzmaEnc.c:531:      Byte *buf = p->buf;
zmat/easylzma/pavlov/LzmaEnc.c:532:      *buf++ = (Byte)(temp + (Byte)(p->low >> 32));
zmat/easylzma/pavlov/LzmaEnc.c:533:      p->buf = buf;
zmat/easylzma/pavlov/LzmaEnc.c:534:      if (buf == p->bufLim)
zmat/easylzma/pavlov/LzmaEnc.c:538:    while (--p->cacheSize != 0);
zmat/easylzma/pavlov/LzmaEnc.c:539:    p->cache = (Byte)((UInt32)p->low >> 24);
zmat/easylzma/pavlov/LzmaEnc.c:541:  p->cacheSize++;
zmat/easylzma/pavlov/LzmaEnc.c:542:  p->low = (UInt32)p->low << 8;
zmat/easylzma/pavlov/LzmaEnc.c:556:    p->range >>= 1;
zmat/easylzma/pavlov/LzmaEnc.c:557:    p->low += p->range & (0 - ((value >> --numBits) & 1));
zmat/easylzma/pavlov/LzmaEnc.c:558:    if (p->range < kTopValue)
zmat/easylzma/pavlov/LzmaEnc.c:560:      p->range <<= 8;
zmat/easylzma/pavlov/LzmaEnc.c:570:  UInt32 newBound = (p->range >> kNumBitModelTotalBits) * ttt;
zmat/easylzma/pavlov/LzmaEnc.c:573:    p->range = newBound;
zmat/easylzma/pavlov/LzmaEnc.c:574:    ttt += (kBitModelTotal - ttt) >> kNumMoveBits;
zmat/easylzma/pavlov/LzmaEnc.c:578:    p->low += newBound;
zmat/easylzma/pavlov/LzmaEnc.c:579:    p->range -= newBound;
zmat/easylzma/pavlov/LzmaEnc.c:580:    ttt -= ttt >> kNumMoveBits;
zmat/easylzma/pavlov/LzmaEnc.c:583:  if (p->range < kTopValue)
zmat/easylzma/pavlov/LzmaEnc.c:585:    p->range <<= 8;
zmat/easylzma/pavlov/LzmaEnc.c:634:    ProbPrices[i >> kNumMoveReducingBits] = ((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);
zmat/easylzma/pavlov/LzmaEnc.c:640:  p->ProbPrices[((prob) ^ (((-(int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
zmat/easylzma/pavlov/LzmaEnc.c:643:  ProbPrices[((prob) ^ ((-((int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
zmat/easylzma/pavlov/LzmaEnc.c:645:#define GET_PRICE_0(prob) p->ProbPrices[(prob) >> kNumMoveReducingBits]
zmat/easylzma/pavlov/LzmaEnc.c:646:#define GET_PRICE_1(prob) p->ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
zmat/easylzma/pavlov/LzmaEnc.c:649:#define GET_PRICE_1a(prob) ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
zmat/easylzma/pavlov/LzmaEnc.c:688:    i--;
zmat/easylzma/pavlov/LzmaEnc.c:725:  for (i = numBitLevels; i != 0; i--)
zmat/easylzma/pavlov/LzmaEnc.c:739:  p->choice = p->choice2 = kProbInitValue;
zmat/easylzma/pavlov/LzmaEnc.c:741:    p->low[i] = kProbInitValue;
zmat/easylzma/pavlov/LzmaEnc.c:743:    p->mid[i] = kProbInitValue;
zmat/easylzma/pavlov/LzmaEnc.c:745:    p->high[i] = kProbInitValue;
zmat/easylzma/pavlov/LzmaEnc.c:752:    RangeEnc_EncodeBit(rc, &p->choice, 0);
zmat/easylzma/pavlov/LzmaEnc.c:753:    RcTree_Encode(rc, p->low + (posState << kLenNumLowBits), kLenNumLowBits, symbol);
zmat/easylzma/pavlov/LzmaEnc.c:757:    RangeEnc_EncodeBit(rc, &p->choice, 1);
zmat/easylzma/pavlov/LzmaEnc.c:760:      RangeEnc_EncodeBit(rc, &p->choice2, 0);
zmat/easylzma/pavlov/LzmaEnc.c:761:      RcTree_Encode(rc, p->mid + (posState << kLenNumMidBits), kLenNumMidBits, symbol - kLenNumLowSymbols);
zmat/easylzma/pavlov/LzmaEnc.c:765:      RangeEnc_EncodeBit(rc, &p->choice2, 1);
zmat/easylzma/pavlov/LzmaEnc.c:766:      RcTree_Encode(rc, p->high, kLenNumHighBits, symbol - kLenNumLowSymbols - kLenNumMidSymbols);
zmat/easylzma/pavlov/LzmaEnc.c:773:  UInt32 a0 = GET_PRICE_0a(p->choice);
zmat/easylzma/pavlov/LzmaEnc.c:774:  UInt32 a1 = GET_PRICE_1a(p->choice);
zmat/easylzma/pavlov/LzmaEnc.c:775:  UInt32 b0 = a1 + GET_PRICE_0a(p->choice2);
zmat/easylzma/pavlov/LzmaEnc.c:776:  UInt32 b1 = a1 + GET_PRICE_1a(p->choice2);
zmat/easylzma/pavlov/LzmaEnc.c:782:    prices[i] = a0 + RcTree_GetPrice(p->low + (posState << kLenNumLowBits), kLenNumLowBits, i, ProbPrices);
zmat/easylzma/pavlov/LzmaEnc.c:788:    prices[i] = b0 + RcTree_GetPrice(p->mid + (posState << kLenNumMidBits), kLenNumMidBits, i - kLenNumLowSymbols, ProbPrices);
zmat/easylzma/pavlov/LzmaEnc.c:791:    prices[i] = b1 + RcTree_GetPrice(p->high, kLenNumHighBits, i - kLenNumLowSymbols - kLenNumMidSymbols, ProbPrices);
zmat/easylzma/pavlov/LzmaEnc.c:796:  LenEnc_SetPrices(&p->p, posState, p->tableSize, p->prices[posState], ProbPrices);
zmat/easylzma/pavlov/LzmaEnc.c:797:  p->counters[posState] = p->tableSize;
zmat/easylzma/pavlov/LzmaEnc.c:809:  LenEnc_Encode(&p->p, rc, symbol, posState);
zmat/easylzma/pavlov/LzmaEnc.c:811:    if (--p->counters[posState] == 0)
zmat/easylzma/pavlov/LzmaEnc.c:826:    p->additionalOffset += num;
zmat/easylzma/pavlov/LzmaEnc.c:827:    p->matchFinder.Skip(p->matchFinderObj, num);
zmat/easylzma/pavlov/LzmaEnc.c:834:  p->numAvail = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
zmat/easylzma/pavlov/LzmaEnc.c:835:  numPairs = p->matchFinder.GetMatches(p->matchFinderObj, p->matches);
zmat/easylzma/pavlov/LzmaEnc.c:842:      printf("%2d %6d   | ", p->matches[i], p->matches[i + 1]);
zmat/easylzma/pavlov/LzmaEnc.c:847:    lenRes = p->matches[numPairs - 2];
zmat/easylzma/pavlov/LzmaEnc.c:848:    if (lenRes == p->numFastBytes)
zmat/easylzma/pavlov/LzmaEnc.c:850:      const Byte *pby = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
zmat/easylzma/pavlov/LzmaEnc.c:851:      UInt32 distance = p->matches[numPairs - 1] + 1;
zmat/easylzma/pavlov/LzmaEnc.c:852:      UInt32 numAvail = p->numAvail;
zmat/easylzma/pavlov/LzmaEnc.c:856:        const Byte *pby2 = pby - distance;
zmat/easylzma/pavlov/LzmaEnc.c:861:  p->additionalOffset++;
zmat/easylzma/pavlov/LzmaEnc.c:867:#define MakeAsChar(p) (p)->backPrev = (UInt32)(-1); (p)->prev1IsChar = False;
zmat/easylzma/pavlov/LzmaEnc.c:868:#define MakeAsShortRep(p) (p)->backPrev = 0; (p)->prev1IsChar = False;
zmat/easylzma/pavlov/LzmaEnc.c:869:#define IsShortRep(p) ((p)->backPrev == 0)
zmat/easylzma/pavlov/LzmaEnc.c:874:    GET_PRICE_0(p->isRepG0[state]) +
zmat/easylzma/pavlov/LzmaEnc.c:875:    GET_PRICE_0(p->isRep0Long[state][posState]);
zmat/easylzma/pavlov/LzmaEnc.c:883:    price = GET_PRICE_0(p->isRepG0[state]);
zmat/easylzma/pavlov/LzmaEnc.c:884:    price += GET_PRICE_1(p->isRep0Long[state][posState]);
zmat/easylzma/pavlov/LzmaEnc.c:888:    price = GET_PRICE_1(p->isRepG0[state]);
zmat/easylzma/pavlov/LzmaEnc.c:890:      price += GET_PRICE_0(p->isRepG1[state]);
zmat/easylzma/pavlov/LzmaEnc.c:893:      price += GET_PRICE_1(p->isRepG1[state]);
zmat/easylzma/pavlov/LzmaEnc.c:894:      price += GET_PRICE(p->isRepG2[state], repIndex - 2);
zmat/easylzma/pavlov/LzmaEnc.c:902:  return p->repLenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN] +
zmat/easylzma/pavlov/LzmaEnc.c:908:  UInt32 posMem = p->opt[cur].posPrev;
zmat/easylzma/pavlov/LzmaEnc.c:909:  UInt32 backMem = p->opt[cur].backPrev;
zmat/easylzma/pavlov/LzmaEnc.c:910:  p->optimumEndIndex = cur;
zmat/easylzma/pavlov/LzmaEnc.c:913:    if (p->opt[cur].prev1IsChar)
zmat/easylzma/pavlov/LzmaEnc.c:915:      MakeAsChar(&p->opt[posMem])
zmat/easylzma/pavlov/LzmaEnc.c:916:      p->opt[posMem].posPrev = posMem - 1;
zmat/easylzma/pavlov/LzmaEnc.c:917:      if (p->opt[cur].prev2)
zmat/easylzma/pavlov/LzmaEnc.c:919:        p->opt[posMem - 1].prev1IsChar = False;
zmat/easylzma/pavlov/LzmaEnc.c:920:        p->opt[posMem - 1].posPrev = p->opt[cur].posPrev2;
zmat/easylzma/pavlov/LzmaEnc.c:921:        p->opt[posMem - 1].backPrev = p->opt[cur].backPrev2;
zmat/easylzma/pavlov/LzmaEnc.c:928:      backMem = p->opt[posPrev].backPrev;
zmat/easylzma/pavlov/LzmaEnc.c:929:      posMem = p->opt[posPrev].posPrev;
zmat/easylzma/pavlov/LzmaEnc.c:931:      p->opt[posPrev].backPrev = backCur;
zmat/easylzma/pavlov/LzmaEnc.c:932:      p->opt[posPrev].posPrev = cur;
zmat/easylzma/pavlov/LzmaEnc.c:937:  *backRes = p->opt[0].backPrev;
zmat/easylzma/pavlov/LzmaEnc.c:938:  p->optimumCurrentIndex  = p->opt[0].posPrev;
zmat/easylzma/pavlov/LzmaEnc.c:939:  return p->optimumCurrentIndex;
zmat/easylzma/pavlov/LzmaEnc.c:942:#define LIT_PROBS(pos, prevByte) (p->litProbs + ((((pos) & p->lpMask) << p->lc) + ((prevByte) >> (8 - p->lc))) * 0x300)
zmat/easylzma/pavlov/LzmaEnc.c:952:  if (p->optimumEndIndex != p->optimumCurrentIndex)
zmat/easylzma/pavlov/LzmaEnc.c:954:    const COptimal *opt = &p->opt[p->optimumCurrentIndex];
zmat/easylzma/pavlov/LzmaEnc.c:955:    UInt32 lenRes = opt->posPrev - p->optimumCurrentIndex;
zmat/easylzma/pavlov/LzmaEnc.c:956:    *backRes = opt->backPrev;
zmat/easylzma/pavlov/LzmaEnc.c:957:    p->optimumCurrentIndex = opt->posPrev;
zmat/easylzma/pavlov/LzmaEnc.c:960:  p->optimumCurrentIndex = p->optimumEndIndex = 0;
zmat/easylzma/pavlov/LzmaEnc.c:962:  if (p->additionalOffset == 0)
zmat/easylzma/pavlov/LzmaEnc.c:966:    mainLen = p->longestMatchLength;
zmat/easylzma/pavlov/LzmaEnc.c:967:    numPairs = p->numPairs;
zmat/easylzma/pavlov/LzmaEnc.c:970:  numAvail = p->numAvail;
zmat/easylzma/pavlov/LzmaEnc.c:973:    *backRes = (UInt32)(-1);
zmat/easylzma/pavlov/LzmaEnc.c:979:  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
zmat/easylzma/pavlov/LzmaEnc.c:985:    reps[i] = p->reps[i];
zmat/easylzma/pavlov/LzmaEnc.c:986:    data2 = data - (reps[i] + 1);
zmat/easylzma/pavlov/LzmaEnc.c:997:  if (repLens[repMaxIndex] >= p->numFastBytes)
zmat/easylzma/pavlov/LzmaEnc.c:1002:    MovePos(p, lenRes - 1);
zmat/easylzma/pavlov/LzmaEnc.c:1006:  matches = p->matches;
zmat/easylzma/pavlov/LzmaEnc.c:1007:  if (mainLen >= p->numFastBytes)
zmat/easylzma/pavlov/LzmaEnc.c:1009:    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
zmat/easylzma/pavlov/LzmaEnc.c:1010:    MovePos(p, mainLen - 1);
zmat/easylzma/pavlov/LzmaEnc.c:1014:  matchByte = *(data - (reps[0] + 1));
zmat/easylzma/pavlov/LzmaEnc.c:1018:    *backRes = (UInt32)-1;
zmat/easylzma/pavlov/LzmaEnc.c:1022:  p->opt[0].state = (CState)p->state;
zmat/easylzma/pavlov/LzmaEnc.c:1024:  posState = (position & p->pbMask);
zmat/easylzma/pavlov/LzmaEnc.c:1027:    const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
zmat/easylzma/pavlov/LzmaEnc.c:1028:    p->opt[1].price = GET_PRICE_0(p->isMatch[p->state][posState]) +
zmat/easylzma/pavlov/LzmaEnc.c:1029:        (!IsCharState(p->state) ?
zmat/easylzma/pavlov/LzmaEnc.c:1030:          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
zmat/easylzma/pavlov/LzmaEnc.c:1031:          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
zmat/easylzma/pavlov/LzmaEnc.c:1034:  MakeAsChar(&p->opt[1]);
zmat/easylzma/pavlov/LzmaEnc.c:1036:  matchPrice = GET_PRICE_1(p->isMatch[p->state][posState]);
zmat/easylzma/pavlov/LzmaEnc.c:1037:  repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[p->state]);
zmat/easylzma/pavlov/LzmaEnc.c:1041:    UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, p->state, posState);
zmat/easylzma/pavlov/LzmaEnc.c:1042:    if (shortRepPrice < p->opt[1].price)
zmat/easylzma/pavlov/LzmaEnc.c:1044:      p->opt[1].price = shortRepPrice;
zmat/easylzma/pavlov/LzmaEnc.c:1045:      MakeAsShortRep(&p->opt[1]);
zmat/easylzma/pavlov/LzmaEnc.c:1052:    *backRes = p->opt[1].backPrev;
zmat/easylzma/pavlov/LzmaEnc.c:1056:  p->opt[1].posPrev = 0;
zmat/easylzma/pavlov/LzmaEnc.c:1058:    p->opt[0].backs[i] = reps[i];
zmat/easylzma/pavlov/LzmaEnc.c:1062:    p->opt[len--].price = kInfinityPrice;
zmat/easylzma/pavlov/LzmaEnc.c:1071:    price = repMatchPrice + GetPureRepPrice(p, i, p->state, posState);
zmat/easylzma/pavlov/LzmaEnc.c:1074:      UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][repLen - 2];
zmat/easylzma/pavlov/LzmaEnc.c:1075:      COptimal *opt = &p->opt[repLen];
zmat/easylzma/pavlov/LzmaEnc.c:1076:      if (curAndLenPrice < opt->price)
zmat/easylzma/pavlov/LzmaEnc.c:1078:        opt->price = curAndLenPrice;
zmat/easylzma/pavlov/LzmaEnc.c:1079:        opt->posPrev = 0;
zmat/easylzma/pavlov/LzmaEnc.c:1080:        opt->backPrev = i;
zmat/easylzma/pavlov/LzmaEnc.c:1081:        opt->prev1IsChar = False;
zmat/easylzma/pavlov/LzmaEnc.c:1084:    while (--repLen >= 2);
zmat/easylzma/pavlov/LzmaEnc.c:1087:  normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[p->state]);
zmat/easylzma/pavlov/LzmaEnc.c:1100:      UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN];
zmat/easylzma/pavlov/LzmaEnc.c:1103:        curAndLenPrice += p->distancesPrices[lenToPosState][distance];
zmat/easylzma/pavlov/LzmaEnc.c:1108:        curAndLenPrice += p->alignPrices[distance & kAlignMask] + p->posSlotPrices[lenToPosState][slot];
zmat/easylzma/pavlov/LzmaEnc.c:1110:      opt = &p->opt[len];
zmat/easylzma/pavlov/LzmaEnc.c:1111:      if (curAndLenPrice < opt->price)
zmat/easylzma/pavlov/LzmaEnc.c:1113:        opt->price = curAndLenPrice;
zmat/easylzma/pavlov/LzmaEnc.c:1114:        opt->posPrev = 0;
zmat/easylzma/pavlov/LzmaEnc.c:1115:        opt->backPrev = distance + LZMA_NUM_REPS;
zmat/easylzma/pavlov/LzmaEnc.c:1116:        opt->prev1IsChar = False;
zmat/easylzma/pavlov/LzmaEnc.c:1135:      printf("\nprice[%4X] = %d", position - cur + i, p->opt[i].price);
zmat/easylzma/pavlov/LzmaEnc.c:1154:    if (newLen >= p->numFastBytes)
zmat/easylzma/pavlov/LzmaEnc.c:1156:      p->numPairs = numPairs;
zmat/easylzma/pavlov/LzmaEnc.c:1157:      p->longestMatchLength = newLen;
zmat/easylzma/pavlov/LzmaEnc.c:1161:    curOpt = &p->opt[cur];
zmat/easylzma/pavlov/LzmaEnc.c:1162:    posPrev = curOpt->posPrev;
zmat/easylzma/pavlov/LzmaEnc.c:1163:    if (curOpt->prev1IsChar)
zmat/easylzma/pavlov/LzmaEnc.c:1165:      posPrev--;
zmat/easylzma/pavlov/LzmaEnc.c:1166:      if (curOpt->prev2)
zmat/easylzma/pavlov/LzmaEnc.c:1168:        state = p->opt[curOpt->posPrev2].state;
zmat/easylzma/pavlov/LzmaEnc.c:1169:        if (curOpt->backPrev2 < LZMA_NUM_REPS)
zmat/easylzma/pavlov/LzmaEnc.c:1175:        state = p->opt[posPrev].state;
zmat/easylzma/pavlov/LzmaEnc.c:1179:      state = p->opt[posPrev].state;
zmat/easylzma/pavlov/LzmaEnc.c:1180:    if (posPrev == cur - 1)
zmat/easylzma/pavlov/LzmaEnc.c:1191:      if (curOpt->prev1IsChar && curOpt->prev2)
zmat/easylzma/pavlov/LzmaEnc.c:1193:        posPrev = curOpt->posPrev2;
zmat/easylzma/pavlov/LzmaEnc.c:1194:        pos = curOpt->backPrev2;
zmat/easylzma/pavlov/LzmaEnc.c:1199:        pos = curOpt->backPrev;
zmat/easylzma/pavlov/LzmaEnc.c:1205:      prevOpt = &p->opt[posPrev];
zmat/easylzma/pavlov/LzmaEnc.c:1209:        reps[0] = prevOpt->backs[pos];
zmat/easylzma/pavlov/LzmaEnc.c:1211:          reps[i] = prevOpt->backs[i - 1];
zmat/easylzma/pavlov/LzmaEnc.c:1213:          reps[i] = prevOpt->backs[i];
zmat/easylzma/pavlov/LzmaEnc.c:1218:        reps[0] = (pos - LZMA_NUM_REPS);
zmat/easylzma/pavlov/LzmaEnc.c:1220:          reps[i] = prevOpt->backs[i - 1];
zmat/easylzma/pavlov/LzmaEnc.c:1223:    curOpt->state = (CState)state;
zmat/easylzma/pavlov/LzmaEnc.c:1225:    curOpt->backs[0] = reps[0];
zmat/easylzma/pavlov/LzmaEnc.c:1226:    curOpt->backs[1] = reps[1];
zmat/easylzma/pavlov/LzmaEnc.c:1227:    curOpt->backs[2] = reps[2];
zmat/easylzma/pavlov/LzmaEnc.c:1228:    curOpt->backs[3] = reps[3];
zmat/easylzma/pavlov/LzmaEnc.c:1230:    curPrice = curOpt->price;
zmat/easylzma/pavlov/LzmaEnc.c:1232:    data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
zmat/easylzma/pavlov/LzmaEnc.c:1234:    matchByte = *(data - (reps[0] + 1));
zmat/easylzma/pavlov/LzmaEnc.c:1236:    posState = (position & p->pbMask);
zmat/easylzma/pavlov/LzmaEnc.c:1238:    curAnd1Price = curPrice + GET_PRICE_0(p->isMatch[state][posState]);
zmat/easylzma/pavlov/LzmaEnc.c:1240:      const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
zmat/easylzma/pavlov/LzmaEnc.c:1243:          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
zmat/easylzma/pavlov/LzmaEnc.c:1244:          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
zmat/easylzma/pavlov/LzmaEnc.c:1247:    nextOpt = &p->opt[cur + 1];
zmat/easylzma/pavlov/LzmaEnc.c:1249:    if (curAnd1Price < nextOpt->price)
zmat/easylzma/pavlov/LzmaEnc.c:1251:      nextOpt->price = curAnd1Price;
zmat/easylzma/pavlov/LzmaEnc.c:1252:      nextOpt->posPrev = cur;
zmat/easylzma/pavlov/LzmaEnc.c:1257:    matchPrice = curPrice + GET_PRICE_1(p->isMatch[state][posState]);
zmat/easylzma/pavlov/LzmaEnc.c:1258:    repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[state]);
zmat/easylzma/pavlov/LzmaEnc.c:1260:    if (matchByte == curByte && !(nextOpt->posPrev < cur && nextOpt->backPrev == 0))
zmat/easylzma/pavlov/LzmaEnc.c:1263:      if (shortRepPrice <= nextOpt->price)
zmat/easylzma/pavlov/LzmaEnc.c:1265:        nextOpt->price = shortRepPrice;
zmat/easylzma/pavlov/LzmaEnc.c:1266:        nextOpt->posPrev = cur;
zmat/easylzma/pavlov/LzmaEnc.c:1271:    numAvailFull = p->numAvail;
zmat/easylzma/pavlov/LzmaEnc.c:1273:      UInt32 temp = kNumOpts - 1 - cur;
zmat/easylzma/pavlov/LzmaEnc.c:1280:    numAvail = (numAvailFull <= p->numFastBytes ? numAvailFull : p->numFastBytes);
zmat/easylzma/pavlov/LzmaEnc.c:1287:      const Byte *data2 = data - (reps[0] + 1);
zmat/easylzma/pavlov/LzmaEnc.c:1288:      UInt32 limit = p->numFastBytes + 1;
zmat/easylzma/pavlov/LzmaEnc.c:1293:      lenTest2 = temp - 1;
zmat/easylzma/pavlov/LzmaEnc.c:1297:        UInt32 posStateNext = (position + 1) & p->pbMask;
zmat/easylzma/pavlov/LzmaEnc.c:1299:            GET_PRICE_1(p->isMatch[state2][posStateNext]) +
zmat/easylzma/pavlov/LzmaEnc.c:1300:            GET_PRICE_1(p->isRep[state2]);
zmat/easylzma/pavlov/LzmaEnc.c:1301:        /* for (; lenTest2 >= 2; lenTest2--) */
zmat/easylzma/pavlov/LzmaEnc.c:1307:            p->opt[++lenEnd].price = kInfinityPrice;
zmat/easylzma/pavlov/LzmaEnc.c:1309:          opt = &p->opt[offset];
zmat/easylzma/pavlov/LzmaEnc.c:1310:          if (curAndLenPrice < opt->price)
zmat/easylzma/pavlov/LzmaEnc.c:1312:            opt->price = curAndLenPrice;
zmat/easylzma/pavlov/LzmaEnc.c:1313:            opt->posPrev = cur + 1;
zmat/easylzma/pavlov/LzmaEnc.c:1314:            opt->backPrev = 0;
zmat/easylzma/pavlov/LzmaEnc.c:1315:            opt->prev1IsChar = True;
zmat/easylzma/pavlov/LzmaEnc.c:1316:            opt->prev2 = False;
zmat/easylzma/pavlov/LzmaEnc.c:1330:      const Byte *data2 = data - (reps[repIndex] + 1);
zmat/easylzma/pavlov/LzmaEnc.c:1335:        p->opt[++lenEnd].price = kInfinityPrice;
zmat/easylzma/pavlov/LzmaEnc.c:1340:        UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][lenTest - 2];
zmat/easylzma/pavlov/LzmaEnc.c:1341:        COptimal *opt = &p->opt[cur + lenTest];
zmat/easylzma/pavlov/LzmaEnc.c:1342:        if (curAndLenPrice < opt->price)
zmat/easylzma/pavlov/LzmaEnc.c:1344:          opt->price = curAndLenPrice;
zmat/easylzma/pavlov/LzmaEnc.c:1345:          opt->posPrev = cur;
zmat/easylzma/pavlov/LzmaEnc.c:1346:          opt->backPrev = repIndex;
zmat/easylzma/pavlov/LzmaEnc.c:1347:          opt->prev1IsChar = False;
zmat/easylzma/pavlov/LzmaEnc.c:1350:      while (--lenTest >= 2);
zmat/easylzma/pavlov/LzmaEnc.c:1359:          UInt32 limit = lenTest2 + p->numFastBytes;
zmat/easylzma/pavlov/LzmaEnc.c:1364:          lenTest2 -= lenTest + 1;
zmat/easylzma/pavlov/LzmaEnc.c:1368:            UInt32 posStateNext = (position + lenTest) & p->pbMask;
zmat/easylzma/pavlov/LzmaEnc.c:1370:                price + p->repLenEnc.prices[posState][lenTest - 2] +
zmat/easylzma/pavlov/LzmaEnc.c:1371:                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
zmat/easylzma/pavlov/LzmaEnc.c:1372:                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
zmat/easylzma/pavlov/LzmaEnc.c:1373:                    data[lenTest], data2[lenTest], p->ProbPrices);
zmat/easylzma/pavlov/LzmaEnc.c:1375:            posStateNext = (position + lenTest + 1) & p->pbMask;
zmat/easylzma/pavlov/LzmaEnc.c:1377:                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
zmat/easylzma/pavlov/LzmaEnc.c:1378:                GET_PRICE_1(p->isRep[state2]);
zmat/easylzma/pavlov/LzmaEnc.c:1380:            /* for (; lenTest2 >= 2; lenTest2--) */
zmat/easylzma/pavlov/LzmaEnc.c:1386:                p->opt[++lenEnd].price = kInfinityPrice;
zmat/easylzma/pavlov/LzmaEnc.c:1388:              opt = &p->opt[offset];
zmat/easylzma/pavlov/LzmaEnc.c:1389:              if (curAndLenPrice < opt->price)
zmat/easylzma/pavlov/LzmaEnc.c:1391:                opt->price = curAndLenPrice;
zmat/easylzma/pavlov/LzmaEnc.c:1392:                opt->posPrev = cur + lenTest + 1;
zmat/easylzma/pavlov/LzmaEnc.c:1393:                opt->backPrev = 0;
zmat/easylzma/pavlov/LzmaEnc.c:1394:                opt->prev1IsChar = True;
zmat/easylzma/pavlov/LzmaEnc.c:1395:                opt->prev2 = True;
zmat/easylzma/pavlov/LzmaEnc.c:1396:                opt->posPrev2 = cur;
zmat/easylzma/pavlov/LzmaEnc.c:1397:                opt->backPrev2 = repIndex;
zmat/easylzma/pavlov/LzmaEnc.c:1414:      UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[state]);
zmat/easylzma/pavlov/LzmaEnc.c:1418:        p->opt[++lenEnd].price = kInfinityPrice;
zmat/easylzma/pavlov/LzmaEnc.c:1427:        UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][lenTest - LZMA_MATCH_LEN_MIN];
zmat/easylzma/pavlov/LzmaEnc.c:1431:          curAndLenPrice += p->distancesPrices[lenToPosState][curBack];
zmat/easylzma/pavlov/LzmaEnc.c:1433:          curAndLenPrice += p->posSlotPrices[lenToPosState][posSlot] + p->alignPrices[curBack & kAlignMask];
zmat/easylzma/pavlov/LzmaEnc.c:1435:        opt = &p->opt[cur + lenTest];
zmat/easylzma/pavlov/LzmaEnc.c:1436:        if (curAndLenPrice < opt->price)
zmat/easylzma/pavlov/LzmaEnc.c:1438:          opt->price = curAndLenPrice;
zmat/easylzma/pavlov/LzmaEnc.c:1439:          opt->posPrev = cur;
zmat/easylzma/pavlov/LzmaEnc.c:1440:          opt->backPrev = curBack + LZMA_NUM_REPS;
zmat/easylzma/pavlov/LzmaEnc.c:1441:          opt->prev1IsChar = False;
zmat/easylzma/pavlov/LzmaEnc.c:1447:          const Byte *data2 = data - (curBack + 1);
zmat/easylzma/pavlov/LzmaEnc.c:1449:          UInt32 limit = lenTest2 + p->numFastBytes;
zmat/easylzma/pavlov/LzmaEnc.c:1454:          lenTest2 -= lenTest + 1;
zmat/easylzma/pavlov/LzmaEnc.c:1458:            UInt32 posStateNext = (position + lenTest) & p->pbMask;
zmat/easylzma/pavlov/LzmaEnc.c:1460:                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
zmat/easylzma/pavlov/LzmaEnc.c:1461:                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
zmat/easylzma/pavlov/LzmaEnc.c:1462:                    data[lenTest], data2[lenTest], p->ProbPrices);
zmat/easylzma/pavlov/LzmaEnc.c:1464:            posStateNext = (posStateNext + 1) & p->pbMask;
zmat/easylzma/pavlov/LzmaEnc.c:1466:                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
zmat/easylzma/pavlov/LzmaEnc.c:1467:                GET_PRICE_1(p->isRep[state2]);
zmat/easylzma/pavlov/LzmaEnc.c:1469:            /* for (; lenTest2 >= 2; lenTest2--) */
zmat/easylzma/pavlov/LzmaEnc.c:1475:                p->opt[++lenEnd].price = kInfinityPrice;
zmat/easylzma/pavlov/LzmaEnc.c:1477:              opt = &p->opt[offset];
zmat/easylzma/pavlov/LzmaEnc.c:1478:              if (curAndLenPrice < opt->price)
zmat/easylzma/pavlov/LzmaEnc.c:1480:                opt->price = curAndLenPrice;
zmat/easylzma/pavlov/LzmaEnc.c:1481:                opt->posPrev = cur + lenTest + 1;
zmat/easylzma/pavlov/LzmaEnc.c:1482:                opt->backPrev = 0;
zmat/easylzma/pavlov/LzmaEnc.c:1483:                opt->prev1IsChar = True;
zmat/easylzma/pavlov/LzmaEnc.c:1484:                opt->prev2 = True;
zmat/easylzma/pavlov/LzmaEnc.c:1485:                opt->posPrev2 = cur;
zmat/easylzma/pavlov/LzmaEnc.c:1486:                opt->backPrev2 = curBack + LZMA_NUM_REPS;
zmat/easylzma/pavlov/LzmaEnc.c:1510:  if (p->additionalOffset == 0)
zmat/easylzma/pavlov/LzmaEnc.c:1514:    mainLen = p->longestMatchLength;
zmat/easylzma/pavlov/LzmaEnc.c:1515:    numPairs = p->numPairs;
zmat/easylzma/pavlov/LzmaEnc.c:1518:  numAvail = p->numAvail;
zmat/easylzma/pavlov/LzmaEnc.c:1519:  *backRes = (UInt32)-1;
zmat/easylzma/pavlov/LzmaEnc.c:1524:  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
zmat/easylzma/pavlov/LzmaEnc.c:1530:    const Byte *data2 = data - (p->reps[i] + 1);
zmat/easylzma/pavlov/LzmaEnc.c:1534:    if (len >= p->numFastBytes)
zmat/easylzma/pavlov/LzmaEnc.c:1537:      MovePos(p, len - 1);
zmat/easylzma/pavlov/LzmaEnc.c:1547:  matches = p->matches;
zmat/easylzma/pavlov/LzmaEnc.c:1548:  if (mainLen >= p->numFastBytes)
zmat/easylzma/pavlov/LzmaEnc.c:1550:    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
zmat/easylzma/pavlov/LzmaEnc.c:1551:    MovePos(p, mainLen - 1);
zmat/easylzma/pavlov/LzmaEnc.c:1558:    mainDist = matches[numPairs - 1];
zmat/easylzma/pavlov/LzmaEnc.c:1559:    while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)
zmat/easylzma/pavlov/LzmaEnc.c:1561:      if (!ChangePair(matches[numPairs - 3], mainDist))
zmat/easylzma/pavlov/LzmaEnc.c:1563:      numPairs -= 2;
zmat/easylzma/pavlov/LzmaEnc.c:1564:      mainLen = matches[numPairs - 2];
zmat/easylzma/pavlov/LzmaEnc.c:1565:      mainDist = matches[numPairs - 1];
zmat/easylzma/pavlov/LzmaEnc.c:1577:    MovePos(p, repLen - 1);
zmat/easylzma/pavlov/LzmaEnc.c:1584:  p->longestMatchLength = ReadMatchDistances(p, &p->numPairs);
zmat/easylzma/pavlov/LzmaEnc.c:1585:  if (p->longestMatchLength >= 2)
zmat/easylzma/pavlov/LzmaEnc.c:1587:    UInt32 newDistance = matches[p->numPairs - 1];
zmat/easylzma/pavlov/LzmaEnc.c:1588:    if ((p->longestMatchLength >= mainLen && newDistance < mainDist) ||
zmat/easylzma/pavlov/LzmaEnc.c:1589:        (p->longestMatchLength == mainLen + 1 && !ChangePair(mainDist, newDistance)) ||
zmat/easylzma/pavlov/LzmaEnc.c:1590:        (p->longestMatchLength > mainLen + 1) ||
zmat/easylzma/pavlov/LzmaEnc.c:1591:        (p->longestMatchLength + 1 >= mainLen && mainLen >= 3 && ChangePair(newDistance, mainDist)))
zmat/easylzma/pavlov/LzmaEnc.c:1595:  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
zmat/easylzma/pavlov/LzmaEnc.c:1599:    const Byte *data2 = data - (p->reps[i] + 1);
zmat/easylzma/pavlov/LzmaEnc.c:1602:    limit = mainLen - 1;
zmat/easylzma/pavlov/LzmaEnc.c:1608:  MovePos(p, mainLen - 2);
zmat/easylzma/pavlov/LzmaEnc.c:1615:  RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
zmat/easylzma/pavlov/LzmaEnc.c:1616:  RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
zmat/easylzma/pavlov/LzmaEnc.c:1617:  p->state = kMatchNextStates[p->state];
zmat/easylzma/pavlov/LzmaEnc.c:1619:  LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
zmat/easylzma/pavlov/LzmaEnc.c:1620:  RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, (1 << kNumPosSlotBits) - 1);
zmat/easylzma/pavlov/LzmaEnc.c:1621:  RangeEnc_EncodeDirectBits(&p->rc, (((UInt32)1 << 30) - 1) >> kNumAlignBits, 30 - kNumAlignBits);
zmat/easylzma/pavlov/LzmaEnc.c:1622:  RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, kAlignMask);
zmat/easylzma/pavlov/LzmaEnc.c:1627:  if (p->result != SZ_OK)
zmat/easylzma/pavlov/LzmaEnc.c:1628:    return p->result;
zmat/easylzma/pavlov/LzmaEnc.c:1629:  if (p->rc.res != SZ_OK)
zmat/easylzma/pavlov/LzmaEnc.c:1630:    p->result = SZ_ERROR_WRITE;
zmat/easylzma/pavlov/LzmaEnc.c:1631:  if (p->matchFinderBase.result != SZ_OK)
zmat/easylzma/pavlov/LzmaEnc.c:1632:    p->result = SZ_ERROR_READ;
zmat/easylzma/pavlov/LzmaEnc.c:1633:  if (p->result != SZ_OK)
zmat/easylzma/pavlov/LzmaEnc.c:1634:    p->finished = True;
zmat/easylzma/pavlov/LzmaEnc.c:1635:  return p->result;
zmat/easylzma/pavlov/LzmaEnc.c:1641:  p->finished = True;
zmat/easylzma/pavlov/LzmaEnc.c:1642:  if (p->writeEndMark)
zmat/easylzma/pavlov/LzmaEnc.c:1643:    WriteEndMarker(p, nowPos & p->pbMask);
zmat/easylzma/pavlov/LzmaEnc.c:1644:  RangeEnc_FlushData(&p->rc);
zmat/easylzma/pavlov/LzmaEnc.c:1645:  RangeEnc_FlushStream(&p->rc);
zmat/easylzma/pavlov/LzmaEnc.c:1653:    p->alignPrices[i] = RcTree_ReverseGetPrice(p->posAlignEncoder, kNumAlignBits, i, p->ProbPrices);
zmat/easylzma/pavlov/LzmaEnc.c:1654:  p->alignPriceCount = 0;
zmat/easylzma/pavlov/LzmaEnc.c:1664:    UInt32 footerBits = ((posSlot >> 1) - 1);
zmat/easylzma/pavlov/LzmaEnc.c:1666:    tempPrices[i] = RcTree_ReverseGetPrice(p->posEncoders + base - posSlot - 1, footerBits, i - base, p->ProbPrices);
zmat/easylzma/pavlov/LzmaEnc.c:1672:    const CLzmaProb *encoder = p->posSlotEncoder[lenToPosState];
zmat/easylzma/pavlov/LzmaEnc.c:1673:    UInt32 *posSlotPrices = p->posSlotPrices[lenToPosState];
zmat/easylzma/pavlov/LzmaEnc.c:1674:    for (posSlot = 0; posSlot < p->distTableSize; posSlot++)
zmat/easylzma/pavlov/LzmaEnc.c:1675:      posSlotPrices[posSlot] = RcTree_GetPrice(encoder, kNumPosSlotBits, posSlot, p->ProbPrices);
zmat/easylzma/pavlov/LzmaEnc.c:1676:    for (posSlot = kEndPosModelIndex; posSlot < p->distTableSize; posSlot++)
zmat/easylzma/pavlov/LzmaEnc.c:1677:      posSlotPrices[posSlot] += ((((posSlot >> 1) - 1) - kNumAlignBits) << kNumBitPriceShiftBits);
zmat/easylzma/pavlov/LzmaEnc.c:1680:      UInt32 *distancesPrices = p->distancesPrices[lenToPosState];
zmat/easylzma/pavlov/LzmaEnc.c:1688:  p->matchPriceCount = 0;
zmat/easylzma/pavlov/LzmaEnc.c:1693:  RangeEnc_Construct(&p->rc);
zmat/easylzma/pavlov/LzmaEnc.c:1694:  MatchFinder_Construct(&p->matchFinderBase);
zmat/easylzma/pavlov/LzmaEnc.c:1696:  MatchFinderMt_Construct(&p->matchFinderMt);
zmat/easylzma/pavlov/LzmaEnc.c:1697:  p->matchFinderMt.MatchFinder = &p->matchFinderBase;
zmat/easylzma/pavlov/LzmaEnc.c:1707:  LzmaEnc_FastPosInit(p->g_FastPos);
zmat/easylzma/pavlov/LzmaEnc.c:1710:  LzmaEnc_InitPriceTables(p->ProbPrices);
zmat/easylzma/pavlov/LzmaEnc.c:1711:  p->litProbs = 0;
zmat/easylzma/pavlov/LzmaEnc.c:1712:  p->saveState.litProbs = 0;
zmat/easylzma/pavlov/LzmaEnc.c:1718:  p = alloc->Alloc(alloc, sizeof(CLzmaEnc));
zmat/easylzma/pavlov/LzmaEnc.c:1726:  alloc->Free(alloc, p->litProbs);
zmat/easylzma/pavlov/LzmaEnc.c:1727:  alloc->Free(alloc, p->saveState.litProbs);
zmat/easylzma/pavlov/LzmaEnc.c:1728:  p->litProbs = 0;
zmat/easylzma/pavlov/LzmaEnc.c:1729:  p->saveState.litProbs = 0;
zmat/easylzma/pavlov/LzmaEnc.c:1735:  MatchFinderMt_Destruct(&p->matchFinderMt, allocBig);
zmat/easylzma/pavlov/LzmaEnc.c:1737:  MatchFinder_Free(&p->matchFinderBase, allocBig);
zmat/easylzma/pavlov/LzmaEnc.c:1739:  RangeEnc_Free(&p->rc, alloc);
zmat/easylzma/pavlov/LzmaEnc.c:1745:  alloc->Free(alloc, p);
zmat/easylzma/pavlov/LzmaEnc.c:1751:  if (p->inStream != 0)
zmat/easylzma/pavlov/LzmaEnc.c:1753:    p->matchFinderBase.stream = p->inStream;
zmat/easylzma/pavlov/LzmaEnc.c:1754:    p->matchFinder.Init(p->matchFinderObj);
zmat/easylzma/pavlov/LzmaEnc.c:1755:    p->inStream = 0;
zmat/easylzma/pavlov/LzmaEnc.c:1758:  if (p->finished)
zmat/easylzma/pavlov/LzmaEnc.c:1759:    return p->result;
zmat/easylzma/pavlov/LzmaEnc.c:1762:  nowPos32 = (UInt32)p->nowPos64;
zmat/easylzma/pavlov/LzmaEnc.c:1765:  if (p->nowPos64 == 0)
zmat/easylzma/pavlov/LzmaEnc.c:1769:    if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
zmat/easylzma/pavlov/LzmaEnc.c:1772:    RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][0], 0);
zmat/easylzma/pavlov/LzmaEnc.c:1773:    p->state = kLiteralNextStates[p->state];
zmat/easylzma/pavlov/LzmaEnc.c:1774:    curByte = p->matchFinder.GetIndexByte(p->matchFinderObj, 0 - p->additionalOffset);
zmat/easylzma/pavlov/LzmaEnc.c:1775:    LitEnc_Encode(&p->rc, p->litProbs, curByte);
zmat/easylzma/pavlov/LzmaEnc.c:1776:    p->additionalOffset--;
zmat/easylzma/pavlov/LzmaEnc.c:1780:  if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) != 0)
zmat/easylzma/pavlov/LzmaEnc.c:1785:    if (p->fastMode)
zmat/easylzma/pavlov/LzmaEnc.c:1794:    posState = nowPos32 & p->pbMask;
zmat/easylzma/pavlov/LzmaEnc.c:1795:    if (len == 1 && pos == (UInt32)-1)
zmat/easylzma/pavlov/LzmaEnc.c:1801:      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 0);
zmat/easylzma/pavlov/LzmaEnc.c:1802:      data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
zmat/easylzma/pavlov/LzmaEnc.c:1804:      probs = LIT_PROBS(nowPos32, *(data - 1));
zmat/easylzma/pavlov/LzmaEnc.c:1805:      if (IsCharState(p->state))
zmat/easylzma/pavlov/LzmaEnc.c:1806:        LitEnc_Encode(&p->rc, probs, curByte);
zmat/easylzma/pavlov/LzmaEnc.c:1808:        LitEnc_EncodeMatched(&p->rc, probs, curByte, *(data - p->reps[0] - 1));
zmat/easylzma/pavlov/LzmaEnc.c:1809:      p->state = kLiteralNextStates[p->state];
zmat/easylzma/pavlov/LzmaEnc.c:1813:      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
zmat/easylzma/pavlov/LzmaEnc.c:1816:        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 1);
zmat/easylzma/pavlov/LzmaEnc.c:1819:          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 0);
zmat/easylzma/pavlov/LzmaEnc.c:1820:          RangeEnc_EncodeBit(&p->rc, &p->isRep0Long[p->state][posState], ((len == 1) ? 0 : 1));
zmat/easylzma/pavlov/LzmaEnc.c:1824:          UInt32 distance = p->reps[pos];
zmat/easylzma/pavlov/LzmaEnc.c:1825:          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 1);
zmat/easylzma/pavlov/LzmaEnc.c:1827:            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 0);
zmat/easylzma/pavlov/LzmaEnc.c:1830:            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 1);
zmat/easylzma/pavlov/LzmaEnc.c:1831:            RangeEnc_EncodeBit(&p->rc, &p->isRepG2[p->state], pos - 2);
zmat/easylzma/pavlov/LzmaEnc.c:1833:              p->reps[3] = p->reps[2];
zmat/easylzma/pavlov/LzmaEnc.c:1834:            p->reps[2] = p->reps[1];
zmat/easylzma/pavlov/LzmaEnc.c:1836:          p->reps[1] = p->reps[0];
zmat/easylzma/pavlov/LzmaEnc.c:1837:          p->reps[0] = distance;
zmat/easylzma/pavlov/LzmaEnc.c:1840:          p->state = kShortRepNextStates[p->state];
zmat/easylzma/pavlov/LzmaEnc.c:1843:          LenEnc_Encode2(&p->repLenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
zmat/easylzma/pavlov/LzmaEnc.c:1844:          p->state = kRepNextStates[p->state];
zmat/easylzma/pavlov/LzmaEnc.c:1850:        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
zmat/easylzma/pavlov/LzmaEnc.c:1851:        p->state = kMatchNextStates[p->state];
zmat/easylzma/pavlov/LzmaEnc.c:1852:        LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
zmat/easylzma/pavlov/LzmaEnc.c:1853:        pos -= LZMA_NUM_REPS;
zmat/easylzma/pavlov/LzmaEnc.c:1855:        RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, posSlot);
zmat/easylzma/pavlov/LzmaEnc.c:1859:          UInt32 footerBits = ((posSlot >> 1) - 1);
zmat/easylzma/pavlov/LzmaEnc.c:1861:          UInt32 posReduced = pos - base;
zmat/easylzma/pavlov/LzmaEnc.c:1864:            RcTree_ReverseEncode(&p->rc, p->posEncoders + base - posSlot - 1, footerBits, posReduced);
zmat/easylzma/pavlov/LzmaEnc.c:1867:            RangeEnc_EncodeDirectBits(&p->rc, posReduced >> kNumAlignBits, footerBits - kNumAlignBits);
zmat/easylzma/pavlov/LzmaEnc.c:1868:            RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, posReduced & kAlignMask);
zmat/easylzma/pavlov/LzmaEnc.c:1869:            p->alignPriceCount++;
zmat/easylzma/pavlov/LzmaEnc.c:1872:        p->reps[3] = p->reps[2];
zmat/easylzma/pavlov/LzmaEnc.c:1873:        p->reps[2] = p->reps[1];
zmat/easylzma/pavlov/LzmaEnc.c:1874:        p->reps[1] = p->reps[0];
zmat/easylzma/pavlov/LzmaEnc.c:1875:        p->reps[0] = pos;
zmat/easylzma/pavlov/LzmaEnc.c:1876:        p->matchPriceCount++;
zmat/easylzma/pavlov/LzmaEnc.c:1879:    p->additionalOffset -= len;
zmat/easylzma/pavlov/LzmaEnc.c:1881:    if (p->additionalOffset == 0)
zmat/easylzma/pavlov/LzmaEnc.c:1884:      if (!p->fastMode)
zmat/easylzma/pavlov/LzmaEnc.c:1886:        if (p->matchPriceCount >= (1 << 7))
zmat/easylzma/pavlov/LzmaEnc.c:1888:        if (p->alignPriceCount >= kAlignTableSize)
zmat/easylzma/pavlov/LzmaEnc.c:1891:      if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
zmat/easylzma/pavlov/LzmaEnc.c:1893:      processed = nowPos32 - startPos32;
zmat/easylzma/pavlov/LzmaEnc.c:1897:            RangeEnc_GetProcessed(&p->rc) + kNumOpts * 2 >= maxPackSize)
zmat/easylzma/pavlov/LzmaEnc.c:1902:        p->nowPos64 += nowPos32 - startPos32;
zmat/easylzma/pavlov/LzmaEnc.c:1907:  p->nowPos64 += nowPos32 - startPos32;
zmat/easylzma/pavlov/LzmaEnc.c:1917:  if (!RangeEnc_Alloc(&p->rc, alloc))
zmat/easylzma/pavlov/LzmaEnc.c:1919:  btMode = (p->matchFinderBase.btMode != 0);
zmat/easylzma/pavlov/LzmaEnc.c:1921:  p->mtMode = (p->multiThread && !p->fastMode && btMode);
zmat/easylzma/pavlov/LzmaEnc.c:1925:    unsigned lclp = p->lc + p->lp;
zmat/easylzma/pavlov/LzmaEnc.c:1926:    if (p->litProbs == 0 || p->saveState.litProbs == 0 || p->lclp != lclp)
zmat/easylzma/pavlov/LzmaEnc.c:1929:      p->litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
zmat/easylzma/pavlov/LzmaEnc.c:1930:      p->saveState.litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
zmat/easylzma/pavlov/LzmaEnc.c:1931:      if (p->litProbs == 0 || p->saveState.litProbs == 0)
zmat/easylzma/pavlov/LzmaEnc.c:1936:      p->lclp = lclp;
zmat/easylzma/pavlov/LzmaEnc.c:1940:  p->matchFinderBase.bigHash = (p->dictSize > kBigHashDicLimit);
zmat/easylzma/pavlov/LzmaEnc.c:1942:  if (beforeSize + p->dictSize < keepWindowSize)
zmat/easylzma/pavlov/LzmaEnc.c:1943:    beforeSize = keepWindowSize - p->dictSize;
zmat/easylzma/pavlov/LzmaEnc.c:1946:  if (p->mtMode)
zmat/easylzma/pavlov/LzmaEnc.c:1948:    RINOK(MatchFinderMt_Create(&p->matchFinderMt, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig));
zmat/easylzma/pavlov/LzmaEnc.c:1949:    p->matchFinderObj = &p->matchFinderMt;
zmat/easylzma/pavlov/LzmaEnc.c:1950:    MatchFinderMt_CreateVTable(&p->matchFinderMt, &p->matchFinder);
zmat/easylzma/pavlov/LzmaEnc.c:1955:    if (!MatchFinder_Create(&p->matchFinderBase, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig))
zmat/easylzma/pavlov/LzmaEnc.c:1957:    p->matchFinderObj = &p->matchFinderBase;
zmat/easylzma/pavlov/LzmaEnc.c:1958:    MatchFinder_CreateVTable(&p->matchFinderBase, &p->matchFinder);
zmat/easylzma/pavlov/LzmaEnc.c:1966:  p->state = 0;
zmat/easylzma/pavlov/LzmaEnc.c:1968:    p->reps[i] = 0;
zmat/easylzma/pavlov/LzmaEnc.c:1970:  RangeEnc_Init(&p->rc);
zmat/easylzma/pavlov/LzmaEnc.c:1978:      p->isMatch[i][j] = kProbInitValue;
zmat/easylzma/pavlov/LzmaEnc.c:1979:      p->isRep0Long[i][j] = kProbInitValue;
zmat/easylzma/pavlov/LzmaEnc.c:1981:    p->isRep[i] = kProbInitValue;
zmat/easylzma/pavlov/LzmaEnc.c:1982:    p->isRepG0[i] = kProbInitValue;
zmat/easylzma/pavlov/LzmaEnc.c:1983:    p->isRepG1[i] = kProbInitValue;
zmat/easylzma/pavlov/LzmaEnc.c:1984:    p->isRepG2[i] = kProbInitValue;
zmat/easylzma/pavlov/LzmaEnc.c:1988:    UInt32 num = 0x300 << (p->lp + p->lc);
zmat/easylzma/pavlov/LzmaEnc.c:1990:      p->litProbs[i] = kProbInitValue;
zmat/easylzma/pavlov/LzmaEnc.c:1996:      CLzmaProb *probs = p->posSlotEncoder[i];
zmat/easylzma/pavlov/LzmaEnc.c:2003:    for (i = 0; i < kNumFullDistances - kEndPosModelIndex; i++)
zmat/easylzma/pavlov/LzmaEnc.c:2004:      p->posEncoders[i] = kProbInitValue;
zmat/easylzma/pavlov/LzmaEnc.c:2007:  LenEnc_Init(&p->lenEnc.p);
zmat/easylzma/pavlov/LzmaEnc.c:2008:  LenEnc_Init(&p->repLenEnc.p);
zmat/easylzma/pavlov/LzmaEnc.c:2011:    p->posAlignEncoder[i] = kProbInitValue;
zmat/easylzma/pavlov/LzmaEnc.c:2013:  p->optimumEndIndex = 0;
zmat/easylzma/pavlov/LzmaEnc.c:2014:  p->optimumCurrentIndex = 0;
zmat/easylzma/pavlov/LzmaEnc.c:2015:  p->additionalOffset = 0;
zmat/easylzma/pavlov/LzmaEnc.c:2017:  p->pbMask = (1 << p->pb) - 1;
zmat/easylzma/pavlov/LzmaEnc.c:2018:  p->lpMask = (1 << p->lp) - 1;
zmat/easylzma/pavlov/LzmaEnc.c:2023:  if (!p->fastMode)
zmat/easylzma/pavlov/LzmaEnc.c:2029:  p->lenEnc.tableSize =
zmat/easylzma/pavlov/LzmaEnc.c:2030:  p->repLenEnc.tableSize =
zmat/easylzma/pavlov/LzmaEnc.c:2031:      p->numFastBytes + 1 - LZMA_MATCH_LEN_MIN;
zmat/easylzma/pavlov/LzmaEnc.c:2032:  LenPriceEnc_UpdateTables(&p->lenEnc, 1 << p->pb, p->ProbPrices);
zmat/easylzma/pavlov/LzmaEnc.c:2033:  LenPriceEnc_UpdateTables(&p->repLenEnc, 1 << p->pb, p->ProbPrices);
zmat/easylzma/pavlov/LzmaEnc.c:2040:    if (p->dictSize <= ((UInt32)1 << i))
zmat/easylzma/pavlov/LzmaEnc.c:2042:  p->distTableSize = i * 2;
zmat/easylzma/pavlov/LzmaEnc.c:2044:  p->finished = False;
zmat/easylzma/pavlov/LzmaEnc.c:2045:  p->result = SZ_OK;
zmat/easylzma/pavlov/LzmaEnc.c:2049:  p->nowPos64 = 0;
zmat/easylzma/pavlov/LzmaEnc.c:2057:  p->inStream = inStream;
zmat/easylzma/pavlov/LzmaEnc.c:2058:  p->rc.outStream = outStream;
zmat/easylzma/pavlov/LzmaEnc.c:2067:  p->inStream = inStream;
zmat/easylzma/pavlov/LzmaEnc.c:2073:  p->seqBufInStream.funcTable.Read = MyRead;
zmat/easylzma/pavlov/LzmaEnc.c:2074:  p->seqBufInStream.data = src;
zmat/easylzma/pavlov/LzmaEnc.c:2075:  p->seqBufInStream.rem = srcLen;
zmat/easylzma/pavlov/LzmaEnc.c:2083:  p->inStream = &p->seqBufInStream.funcTable;
zmat/easylzma/pavlov/LzmaEnc.c:2091:  if (p->mtMode)
zmat/easylzma/pavlov/LzmaEnc.c:2092:    MatchFinderMt_ReleaseStream(&p->matchFinderMt);
zmat/easylzma/pavlov/LzmaEnc.c:2109:  if (p->rem < size)
zmat/easylzma/pavlov/LzmaEnc.c:2111:    size = p->rem;
zmat/easylzma/pavlov/LzmaEnc.c:2112:    p->overflow = True;
zmat/easylzma/pavlov/LzmaEnc.c:2114:  memcpy(p->data, data, size);
zmat/easylzma/pavlov/LzmaEnc.c:2115:  p->rem -= size;
zmat/easylzma/pavlov/LzmaEnc.c:2116:  p->data += size;
zmat/easylzma/pavlov/LzmaEnc.c:2124:  return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
zmat/easylzma/pavlov/LzmaEnc.c:2130:  return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
zmat/easylzma/pavlov/LzmaEnc.c:2146:  p->writeEndMark = False;
zmat/easylzma/pavlov/LzmaEnc.c:2147:  p->finished = False;
zmat/easylzma/pavlov/LzmaEnc.c:2148:  p->result = SZ_OK;
zmat/easylzma/pavlov/LzmaEnc.c:2153:  nowPos64 = p->nowPos64;
zmat/easylzma/pavlov/LzmaEnc.c:2154:  RangeEnc_Init(&p->rc);
zmat/easylzma/pavlov/LzmaEnc.c:2155:  p->rc.outStream = &outStream.funcTable;
zmat/easylzma/pavlov/LzmaEnc.c:2159:  *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
zmat/easylzma/pavlov/LzmaEnc.c:2160:  *destLen -= outStream.rem;
zmat/easylzma/pavlov/LzmaEnc.c:2185:    if (res != SZ_OK || p->finished != 0)
zmat/easylzma/pavlov/LzmaEnc.c:2189:      res = progress->Progress(progress, p->nowPos64, RangeEnc_GetProcessed(&p->rc));
zmat/easylzma/pavlov/LzmaEnc.c:2205:  UInt32 dictSize = p->dictSize;
zmat/easylzma/pavlov/LzmaEnc.c:2209:  props[0] = (Byte)((p->pb * 5 + p->lp) * 9 + p->lc);
zmat/easylzma/pavlov/LzmaEnc.c:2245:  p->writeEndMark = writeEndMark;
zmat/easylzma/pavlov/LzmaEnc.c:2246:  res = LzmaEnc_Encode(pp, &outStream.funcTable, &p->seqBufInStream.funcTable,
zmat/easylzma/pavlov/LzmaEnc.c:2249:  *destLen -= outStream.rem;
zmat/easylzma/pavlov/CpuArch.h:2:2008-08-05
zmat/easylzma/pavlov/BraIA64.c:1:/* BraIA64.c -- Converter for IA-64 code
zmat/easylzma/pavlov/BraIA64.c:2:2008-10-04 : Igor Pavlov : Public domain */
zmat/easylzma/pavlov/BraIA64.c:19:  size -= 16;
zmat/easylzma/pavlov/BraIA64.c:51:          dest = src - (ip + (UInt32)i);
zmat/easylzma/pavlov/BraIA64.c:57:        instNorm |= ((UInt64)(dest & 0x100000) << (36 - 20));
zmat/easylzma/pavlov/BraIA64.c:59:        instruction &= (1 << bitRes) - 1;
zmat/easylzma/pavlov/Alloc.c:1:/* Alloc.c -- Memory allocation functions
zmat/easylzma/pavlov/Alloc.c:2:2008-09-24
zmat/easylzma/pavlov/Alloc.c:42:    fprintf(stderr, "\nFree; count = %10d,  addr = %8X", --g_allocCount, (unsigned)address);
zmat/easylzma/pavlov/Alloc.c:63:    fprintf(stderr, "\nFree_Mid; count = %10d", --g_allocCountMid);
zmat/easylzma/pavlov/Alloc.c:88:  if (size == 0 || (size & (size - 1)) != 0)
zmat/easylzma/pavlov/Alloc.c:106:    void *res = VirtualAlloc(0, (size + g_LargePageSize - 1) & (~(g_LargePageSize - 1)),
zmat/easylzma/pavlov/Alloc.c:119:    fprintf(stderr, "\nFree_Big; count = %10d", --g_allocCountBig);
Binary file zmat/easylzma/pavlov/LzFind.o matches
zmat/zmatlib.c:5:**  \copyright Qianqian Fang, 2019-2020
zmat/zmatlib.c:58:	    return -1;
zmat/zmatlib.c:66:	        	return -2;
zmat/zmatlib.c:69:	        	return -2;
zmat/zmatlib.c:83:	            return -3;
zmat/zmatlib.c:87:	        *ret = simpleCompress((elzma_file_format)(zipid-3), (unsigned char *)inputstr,
zmat/zmatlib.c:90:		     return -4;
zmat/zmatlib.c:96:                     return -5;
zmat/zmatlib.c:103:		     return -6;
zmat/zmatlib.c:106:		return -7;
zmat/zmatlib.c:115:	        	return -2;
zmat/zmatlib.c:118:	        	return -2;
zmat/zmatlib.c:131:		    zs.next_out =  (Bytef *)(*outputbuf+(buflen[0]<<(count-1)));
zmat/zmatlib.c:132:		    zs.avail_out = (buflen[0]<<(count-1)); /* size of output*/
zmat/zmatlib.c:138:		    return -3;
zmat/zmatlib.c:142:	        *ret = simpleDecompress((elzma_file_format)(zipid-3), (unsigned char *)inputstr,
zmat/zmatlib.c:145:		     return -4;
zmat/zmatlib.c:152:		     *ret=-5;
zmat/zmatlib.c:158:		        *ret=-5;
zmat/zmatlib.c:165:		     return -6;
zmat/zmatlib.c:168:		return -7;
zmat/zmatlib.c:186: * @return if found, return the index of the string in the dictionary, otherwise -1.
zmat/zmatlib.c:206:    return -1;
zmat/zmatlib.c:212: * Copyright (c) 2005-2011, Jouni Malinen <j@w1.fi>
zmat/zmatlib.c:222: * base64_encode - Base64 encode
zmat/zmatlib.c:241:	olen = len * 4 / 3 + 4; /* 3-byte blocks to 4-byte */
zmat/zmatlib.c:254:	while (end - in >= 3) {
zmat/zmatlib.c:267:	if (end - in) {
zmat/zmatlib.c:269:		if (end - in == 1) {
zmat/zmatlib.c:286:		*out_len = pos - out;
zmat/zmatlib.c:292: * base64_decode - Base64 decode
zmat/zmatlib.c:309:	for (i = 0; i < sizeof(base64_table) - 1; i++)
zmat/zmatlib.c:344:					pos--;
zmat/zmatlib.c:346:					pos -= 2;
zmat/zmatlib.c:357:	*out_len = pos - out;
zmat/zmatlib.c:379:    rd = (ds->inLen < *size) ? ds->inLen : *size;
zmat/zmatlib.c:382:        memcpy(buf, (void *) ds->inData, rd);
zmat/zmatlib.c:383:        ds->inData += rd;
zmat/zmatlib.c:384:        ds->inLen -= rd;
zmat/zmatlib.c:399:        ds->outData = (unsigned char *)realloc(ds->outData, ds->outLen + size);
zmat/zmatlib.c:400:        memcpy((void *) (ds->outData + ds->outLen), buf, size);
zmat/zmatlib.c:401:        ds->outLen += size;
Binary file zmat/lz4/lz4.o matches
zmat/lz4/lz4.h:2: *  LZ4 - Fast LZ compression algorithm
zmat/lz4/lz4.h:4: *  Copyright (C) 2011-present, Yann Collet.
zmat/lz4/lz4.h:6:   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
zmat/lz4/lz4.h:32:    - LZ4 homepage : http://www.lz4.org
zmat/lz4/lz4.h:33:    - LZ4 source repository : https://github.com/lz4/lz4
zmat/lz4/lz4.h:42:/* --- Dependency --- */
zmat/lz4/lz4.h:50:  scalable with multi-cores CPU. It features an extremely fast decoder, with speed in
zmat/lz4/lz4.h:51:  multiple GB/s per core, typically reaching RAM speed limits on multi-core systems.
zmat/lz4/lz4.h:53:  The LZ4 compression library provides in-memory compression and decompression functions.
zmat/lz4/lz4.h:56:    - a single step (described as Simple Functions)
zmat/lz4/lz4.h:57:    - a single step, reusing a context (described in Advanced Functions)
zmat/lz4/lz4.h:58:    - unbounded multiple steps (described as Streaming compression)
zmat/lz4/lz4.h:60:  lz4.h generates and decodes LZ4-compressed blocks (doc/lz4_Block_format.md).
zmat/lz4/lz4.h:71:  Embedding metadata is required for compressed data to be self-contained and portable.
zmat/lz4/lz4.h:100:/*------   Version   ------*/
zmat/lz4/lz4.h:102:#define LZ4_VERSION_MINOR    9    /* for new (non-breaking) interface capabilities */
zmat/lz4/lz4.h:103:#define LZ4_VERSION_RELEASE  2    /* for tweaks, bug-fixes, or development */
zmat/lz4/lz4.h:116:/*-************************************
zmat/lz4/lz4.h:121: * Memory usage formula : N->2^N Bytes (examples : 10 -> 1KB; 12 -> 4KB ; 16 -> 64KB; 20 -> 1MB; etc.)
zmat/lz4/lz4.h:131:/*-************************************
zmat/lz4/lz4.h:167:/*-************************************
zmat/lz4/lz4.h:176:    Macro LZ4_COMPRESSBOUND() is also provided for compilation-time evaluation (stack memory allocation for example).
zmat/lz4/lz4.h:187:    It's a trade-off. It can be fine tuned, with each successive value providing roughly +~3% to speed.
zmat/lz4/lz4.h:197: *  and allocate it on 8-bytes boundaries (using `malloc()` typically).
zmat/lz4/lz4.h:246:/*-*********************************************
zmat/lz4/lz4.h:264: *  A same LZ4_stream_t can be re-used multiple times consecutively
zmat/lz4/lz4.h:306: *  Note 3 : When input is structured as a double-buffer, each buffer can have any size, including < 64 KB.
zmat/lz4/lz4.h:310: *  Note 4 : If input buffer is a ring-buffer, it can have any size, including < 64 KB.
zmat/lz4/lz4.h:326:/*-**********************************************
zmat/lz4/lz4.h:334: *  A tracking context can be re-used multiple times.
zmat/lz4/lz4.h:340: *  An LZ4_streamDecode_t context can be allocated once and re-used multiple times.
zmat/lz4/lz4.h:370: *  - Decompression buffer size is _at least_ LZ4_decoderRingBufferSize(maxBlockSize).
zmat/lz4/lz4.h:374: *  - Synchronized mode :
zmat/lz4/lz4.h:379: *  - Decompression buffer is larger than encoding buffer, by a minimum of maxBlockSize more bytes.
zmat/lz4/lz4.h:393: *  They are stand-alone, and don't need an LZ4_streamDecode_t structure.
zmat/lz4/lz4.h:407:/*-****************************************************************************
zmat/lz4/lz4.h:455: *  Rather than re-loading the dictionary buffer into a working context before
zmat/lz4/lz4.h:456: *  each compression, or copying a pre-loaded dictionary's LZ4_stream_t into a
zmat/lz4/lz4.h:457: *  working LZ4_stream_t, this function introduces a no-copy setup mechanism,
zmat/lz4/lz4.h:458: *  in which the working stream references the dictionary stream in-place.
zmat/lz4/lz4.h:467: *  If a dictionary is provided, it replaces any pre-existing stream history.
zmat/lz4/lz4.h:474: *  stream (and source buffer) must remain in-place / accessible / unchanged
zmat/lz4/lz4.h:480:/*! In-place compression and decompression
zmat/lz4/lz4.h:488: * |<------------------------buffer--------------------------------->|
zmat/lz4/lz4.h:489: *                             |<-----------compressed data--------->|
zmat/lz4/lz4.h:490: * |<-----------decompressed size------------------>|
zmat/lz4/lz4.h:491: *                                                  |<----margin---->|
zmat/lz4/lz4.h:497: * In-place decompression will work inside any buffer
zmat/lz4/lz4.h:504: * For in-place compression, margin is larger, as it must be able to cope with both
zmat/lz4/lz4.h:508: * and memory savings offered by in-place compression are more limited.
zmat/lz4/lz4.h:511: * - Reduce history size, by modifying LZ4_DISTANCE_MAX.
zmat/lz4/lz4.h:512: *   Note that it is a compile-time constant, so all compressions will apply this limit.
zmat/lz4/lz4.h:515: * - Require the compressor to deliver a "maximum compressed size".
zmat/lz4/lz4.h:522: * the amount of margin required for in-place compression.
zmat/lz4/lz4.h:524: * In-place compression can work in any buffer
zmat/lz4/lz4.h:534:#ifndef LZ4_DISTANCE_MAX   /* history window size; can be user-defined at compile time */
zmat/lz4/lz4.h:549:/*-************************************************************
zmat/lz4/lz4.h:556:#define LZ4_HASHLOG   (LZ4_MEMORY_USAGE-2)
zmat/lz4/lz4.h:612:#define LZ4_STREAMSIZE_U64 ((1 << (LZ4_MEMORY_USAGE-3)) + 4 + ((sizeof(void*)==16) ? 4 : 0) /*AS-400*/ )
zmat/lz4/lz4.h:643:#define LZ4_STREAMDECODESIZE_U64 (4 + ((sizeof(void*)==16) ? 2 : 0) /*AS-400*/ )
zmat/lz4/lz4.h:652:/*-************************************
zmat/lz4/lz4.h:661: *  typically with -Wno-deprecated-declarations for gcc
zmat/lz4/lz4hc.h:2:   LZ4 HC - High Compression Mode of LZ4
zmat/lz4/lz4hc.h:4:   Copyright (C) 2011-2017, Yann Collet.
zmat/lz4/lz4hc.h:5:   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
zmat/lz4/lz4hc.h:31:   - LZ4 source repository : https://github.com/lz4/lz4
zmat/lz4/lz4hc.h:32:   - LZ4 public forum : https://groups.google.com/forum/#!forum/lz4c
zmat/lz4/lz4hc.h:41:/* --- Dependency --- */
zmat/lz4/lz4hc.h:46:/* --- Useful constants --- */
zmat/lz4/lz4hc.h:53:/*-************************************
zmat/lz4/lz4hc.h:77: *  Memory segment must be aligned on 8-bytes boundaries (which a normal malloc() should do properly).
zmat/lz4/lz4hc.h:97:/*-************************************
zmat/lz4/lz4hc.h:115:  One key assumption is that previous blocks (up to 64 KB) remain read-accessible while compressing next blocks.
zmat/lz4/lz4hc.h:117:  Ring-buffer scenario is automatically detected and handled within LZ4_compress_HC_continue().
zmat/lz4/lz4hc.h:146:  Whenever previous input blocks can't be preserved unmodified in-place during compression of next blocks,
zmat/lz4/lz4hc.h:184:/*-******************************************************************
zmat/lz4/lz4hc.h:194:#define LZ4HC_MAXD_MASK (LZ4HC_MAXD - 1)
zmat/lz4/lz4hc.h:198:#define LZ4HC_HASH_MASK (LZ4HC_HASHTABLESIZE - 1)
zmat/lz4/lz4hc.h:275:/*-************************************
zmat/lz4/lz4hc.h:298: * than preserve a window-sized chunk of history.
zmat/lz4/lz4hc.h:327:/*-**************************************************
zmat/lz4/lz4hc.h:333: * after successfull usage in real-life scenarios.
zmat/lz4/lz4hc.h:369: *  - returned from LZ4_createStreamHC()
zmat/lz4/lz4hc.h:370: *  - reset by LZ4_resetStreamHC()
zmat/lz4/lz4hc.h:371: *  - memset(stream, 0, sizeof(LZ4_streamHC_t))
zmat/lz4/lz4hc.h:372: *  - the stream was in a valid state and was reset by LZ4_resetStreamHC_fast()
zmat/lz4/lz4hc.h:373: *  - the stream was in a valid state and was then used in any compression call
zmat/lz4/lz4hc.h:375: *  - the stream was in an indeterminate state and was used in a compression
zmat/lz4/lz4hc.h:408: *  Rather than re-loading the dictionary buffer into a working context before
zmat/lz4/lz4hc.h:409: *  each compression, or copying a pre-loaded dictionary's LZ4_streamHC_t into a
zmat/lz4/lz4hc.h:410: *  working LZ4_streamHC_t, this function introduces a no-copy setup mechanism,
zmat/lz4/lz4hc.h:411: *  in which the working stream references the dictionary stream in-place.
zmat/lz4/lz4hc.h:426: *  stream (and source buffer) must remain in-place / accessible / unchanged
zmat/lz4/lz4.c:2:   LZ4 - Fast LZ compression algorithm
zmat/lz4/lz4.c:3:   Copyright (C) 2011-present, Yann Collet.
zmat/lz4/lz4.c:5:   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
zmat/lz4/lz4.c:31:    - LZ4 homepage : http://www.lz4.org
zmat/lz4/lz4.c:32:    - LZ4 source repository : https://github.com/lz4/lz4
zmat/lz4/lz4.c:35:/*-************************************
zmat/lz4/lz4.c:54:/*-************************************
zmat/lz4/lz4.c:59: * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.
zmat/lz4/lz4.c:67: * See https://fastcompression.blogspot.fr/2015/08/accessing-unaligned-memory.html for details.
zmat/lz4/lz4.c:90:/*-************************************
zmat/lz4/lz4.c:114:/*-************************************
zmat/lz4/lz4.c:120:#  pragma warning(disable : 4293)        /* disable: C4293: too large shift (32-bits) */
zmat/lz4/lz4.c:141: * together with a simple 8-byte copy loop as a fall-back path.
zmat/lz4/lz4.c:145: * before going to the fall-back path become useless overhead.
zmat/lz4/lz4.c:146: * This optimization happens only with the -O3 flag, and -O2 generates
zmat/lz4/lz4.c:147: * a simple 8-byte copy loop.
zmat/lz4/lz4.c:175:/*-************************************
zmat/lz4/lz4.c:186:/*-************************************
zmat/lz4/lz4.c:192:#define LASTLITERALS   5   /* see ../doc/lz4_Block_format.md#parsing-restrictions */
zmat/lz4/lz4.c:193:#define MFLIMIT       12   /* see ../doc/lz4_Block_format.md#parsing-restrictions */
zmat/lz4/lz4.c:194:#define MATCH_SAFEGUARD_DISTANCE  ((2*WILDCOPYLENGTH) - MINMATCH)   /* ensure it's possible to write 2 x wildcopyLength without overflowing output buffer */
zmat/lz4/lz4.c:208:#define ML_MASK  ((1U<<ML_BITS)-1)
zmat/lz4/lz4.c:209:#define RUN_BITS (8-ML_BITS)
zmat/lz4/lz4.c:210:#define RUN_MASK ((1U<<RUN_BITS)-1)
zmat/lz4/lz4.c:213:/*-************************************
zmat/lz4/lz4.c:240:/*-************************************
zmat/lz4/lz4.c:257:  typedef size_t              uptrval;   /* generally true, except OpenVMS-64 */
zmat/lz4/lz4.c:261:  typedef U64    reg_t;   /* 64-bits in x32 mode */
zmat/lz4/lz4.c:263:  typedef size_t reg_t;   /* 32-bits in x32 mode */
zmat/lz4/lz4.c:273:/*-************************************
zmat/lz4/lz4.c:299:static U16 LZ4_read16(const void* ptr) { return ((const unalign*)ptr)->u16; }
zmat/lz4/lz4.c:300:static U32 LZ4_read32(const void* ptr) { return ((const unalign*)ptr)->u32; }
zmat/lz4/lz4.c:301:static reg_t LZ4_read_ARCH(const void* ptr) { return ((const unalign*)ptr)->uArch; }
zmat/lz4/lz4.c:303:static void LZ4_write16(void* memPtr, U16 value) { ((unalign*)memPtr)->u16 = value; }
zmat/lz4/lz4.c:304:static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
zmat/lz4/lz4.c:369:static const int      dec64table[8] = {0, 0, 0, -1, -4,  1, 2, 3};
zmat/lz4/lz4.c:397:        srcPtr -= dec64table[offset];
zmat/lz4/lz4.c:422: * - dstEnd >= dstPtr + MINMATCH
zmat/lz4/lz4.c:423: * - there is at least 8 bytes available to write after dstEnd */
zmat/lz4/lz4.c:460:/*-************************************
zmat/lz4/lz4.c:482:            return DeBruijnBytePos[((U64)((val & -(long long)val) * 0x0218A392CDABBD3FULL)) >> 58];
zmat/lz4/lz4.c:496:            return DeBruijnBytePos[((U32)((val & -(S32)val) * 0x077CB531U)) >> 27];
zmat/lz4/lz4.c:500:        if (sizeof(val)==8) {   /* 64-bits */
zmat/lz4/lz4.c:509:                Just to avoid some static analyzer complaining about shift by 32 on 32-bits target.
zmat/lz4/lz4.c:510:                Note that this code path is never triggered in 32-bits mode. */
zmat/lz4/lz4.c:540:    if (likely(pIn < pInLimit-(STEPSIZE-1))) {
zmat/lz4/lz4.c:548:    while (likely(pIn < pInLimit-(STEPSIZE-1))) {
zmat/lz4/lz4.c:552:        return (unsigned)(pIn - pStart);
zmat/lz4/lz4.c:555:    if ((STEPSIZE==8) && (pIn<(pInLimit-3)) && (LZ4_read32(pMatch) == LZ4_read32(pIn))) { pIn+=4; pMatch+=4; }
zmat/lz4/lz4.c:556:    if ((pIn<(pInLimit-1)) && (LZ4_read16(pMatch) == LZ4_read16(pIn))) { pIn+=2; pMatch+=2; }
zmat/lz4/lz4.c:558:    return (unsigned)(pIn - pStart);
zmat/lz4/lz4.c:563:/*-************************************
zmat/lz4/lz4.c:566:static const int LZ4_64Klimit = ((64 KB) + (MFLIMIT-1));
zmat/lz4/lz4.c:570:/*-************************************
zmat/lz4/lz4.c:579: * - noDict        : There is no preceding content.
zmat/lz4/lz4.c:580: * - withPrefix64k : Table entries up to ctx->dictSize before the current blob
zmat/lz4/lz4.c:582: *                   content (of length ctx->dictSize), which is available
zmat/lz4/lz4.c:585: * - usingExtDict  : Like withPrefix64k, but the preceding content is somewhere
zmat/lz4/lz4.c:586: *                   else in memory, starting at ctx->dictionary with length
zmat/lz4/lz4.c:587: *                   ctx->dictSize.
zmat/lz4/lz4.c:588: * - usingDictCtx  : Like usingExtDict, but everything concerning the preceding
zmat/lz4/lz4.c:590: *                   ctx->dictCtx. ctx->dictionary, ctx->dictSize, and table
zmat/lz4/lz4.c:593: *                   ignored. Instead, ctx->dictCtx->dictionary and ctx->dictCtx
zmat/lz4/lz4.c:594: *                   ->dictSize describe the location and size of the preceding
zmat/lz4/lz4.c:596: *                   ->dictCtx->hashTable.
zmat/lz4/lz4.c:602:/*-************************************
zmat/lz4/lz4.c:611:/*-************************************
zmat/lz4/lz4.c:628:/*-******************************
zmat/lz4/lz4.c:634:        return ((sequence * 2654435761U) >> ((MINMATCH*8)-(LZ4_HASHLOG+1)));
zmat/lz4/lz4.c:636:        return ((sequence * 2654435761U) >> ((MINMATCH*8)-LZ4_HASHLOG));
zmat/lz4/lz4.c:644:        return (U32)(((sequence << 24) * prime5bytes) >> (64 - hashLog));
zmat/lz4/lz4.c:647:        return (U32)(((sequence >> 24) * prime8bytes) >> (64 - hashLog));
zmat/lz4/lz4.c:689:    case byU32: { U32* hashTable = (U32*) tableBase; hashTable[h] = (U32)(p-srcBase); return; }
zmat/lz4/lz4.c:690:    case byU16: { U16* hashTable = (U16*) tableBase; hashTable[h] = (U16)(p-srcBase); return; }
zmat/lz4/lz4.c:711:        assert(h < (1U << (LZ4_MEMORY_USAGE-2)));
zmat/lz4/lz4.c:716:        assert(h < (1U << (LZ4_MEMORY_USAGE-1)));
zmat/lz4/lz4.c:745:    if (cctx->dirty) {
zmat/lz4/lz4.c:755:    if (cctx->tableType != clearedTable) {
zmat/lz4/lz4.c:757:        if (cctx->tableType != tableType
zmat/lz4/lz4.c:758:          || ((tableType == byU16) && cctx->currentOffset + (unsigned)inputSize >= 0xFFFFU)
zmat/lz4/lz4.c:759:          || ((tableType == byU32) && cctx->currentOffset > 1 GB)
zmat/lz4/lz4.c:764:            MEM_INIT(cctx->hashTable, 0, LZ4_HASHTABLESIZE);
zmat/lz4/lz4.c:765:            cctx->currentOffset = 0;
zmat/lz4/lz4.c:766:            cctx->tableType = clearedTable;
zmat/lz4/lz4.c:768:            DEBUGLOG(4, "LZ4_prepareTable: Re-use hash table (no reset)");
zmat/lz4/lz4.c:776:    if (cctx->currentOffset != 0 && tableType == byU32) {
zmat/lz4/lz4.c:778:        cctx->currentOffset += 64 KB;
zmat/lz4/lz4.c:782:    cctx->dictCtx = NULL;
zmat/lz4/lz4.c:783:    cctx->dictionary = NULL;
zmat/lz4/lz4.c:784:    cctx->dictSize = 0;
zmat/lz4/lz4.c:805:    U32 const startIndex = cctx->currentOffset;
zmat/lz4/lz4.c:806:    const BYTE* base = (const BYTE*) source - startIndex;
zmat/lz4/lz4.c:809:    const LZ4_stream_t_internal* dictCtx = (const LZ4_stream_t_internal*) cctx->dictCtx;
zmat/lz4/lz4.c:811:        dictDirective == usingDictCtx ? dictCtx->dictionary : cctx->dictionary;
zmat/lz4/lz4.c:813:        dictDirective == usingDictCtx ? dictCtx->dictSize : cctx->dictSize;
zmat/lz4/lz4.c:814:    const U32 dictDelta = (dictDirective == usingDictCtx) ? startIndex - dictCtx->currentOffset : 0;   /* make indexes in dictCtx comparable with index in current context */
zmat/lz4/lz4.c:817:    U32 const prefixIdxLimit = startIndex - dictSize;   /* used when dictDirective == dictSmall */
zmat/lz4/lz4.c:821:    const BYTE* const mflimitPlusOne = iend - MFLIMIT + 1;
zmat/lz4/lz4.c:822:    const BYTE* const matchlimit = iend - LASTLITERALS;
zmat/lz4/lz4.c:827:                            dictionary + dictSize - dictCtx->currentOffset :
zmat/lz4/lz4.c:828:                            dictionary + dictSize - startIndex;
zmat/lz4/lz4.c:845:    lowLimit = (const BYTE*)source - (dictDirective == withPrefix64k ? dictSize : 0);
zmat/lz4/lz4.c:851:        cctx->dictCtx = NULL;
zmat/lz4/lz4.c:852:        cctx->dictSize = (U32)inputSize;
zmat/lz4/lz4.c:854:        cctx->dictSize += (U32)inputSize;
zmat/lz4/lz4.c:856:    cctx->currentOffset += (U32)inputSize;
zmat/lz4/lz4.c:857:    cctx->tableType = (U16)tableType;
zmat/lz4/lz4.c:862:    LZ4_putPosition(ip, cctx->hashTable, tableType, base);
zmat/lz4/lz4.c:885:                match = LZ4_getPositionOnHash(h, cctx->hashTable, tableType, base);
zmat/lz4/lz4.c:887:                LZ4_putPositionOnHash(ip, h, cctx->hashTable, tableType, base);
zmat/lz4/lz4.c:899:                U32 const current = (U32)(forwardIp - base);
zmat/lz4/lz4.c:900:                U32 matchIndex = LZ4_getIndexOnHash(h, cctx->hashTable, tableType);
zmat/lz4/lz4.c:902:                assert(forwardIp - base < (ptrdiff_t)(2 GB - 1));
zmat/lz4/lz4.c:914:                        matchIndex = LZ4_getIndexOnHash(h, dictCtx->hashTable, byU32);
zmat/lz4/lz4.c:925:                        assert(startIndex - matchIndex >= MINMATCH);
zmat/lz4/lz4.c:936:                LZ4_putIndexOnHash(current, h, cctx->hashTable, tableType);
zmat/lz4/lz4.c:938:                DEBUGLOG(7, "candidate at pos=%u  (offset=%u \n", matchIndex, current - matchIndex);
zmat/lz4/lz4.c:945:                assert((current - matchIndex) <= LZ4_DISTANCE_MAX);  /* match now expected within distance */
zmat/lz4/lz4.c:948:                    if (maybe_extMem) offset = current - matchIndex;
zmat/lz4/lz4.c:957:        while (((ip>anchor) & (match > lowLimit)) && (unlikely(ip[-1]==match[-1]))) { ip--; match--; }
zmat/lz4/lz4.c:960:        {   unsigned const litLength = (unsigned)(ip - anchor);
zmat/lz4/lz4.c:967:                (unlikely(op + (litLength+240)/255 /* litlen */ + litLength /* literals */ + 2 /* offset */ + 1 /* token */ + MFLIMIT - MINMATCH /* min last literals so last match is <= end - MFLIMIT */ > olimit))) {
zmat/lz4/lz4.c:968:                op--;
zmat/lz4/lz4.c:972:                int len = (int)(litLength - RUN_MASK);
zmat/lz4/lz4.c:974:                for(; len >= 255 ; len-=255) *op++ = 255;
zmat/lz4/lz4.c:983:                        (int)(anchor-(const BYTE*)source), litLength, (int)(ip-(const BYTE*)source));
zmat/lz4/lz4.c:988:         * - ip : at start of LZ operation
zmat/lz4/lz4.c:989:         * - match : at start of previous pattern occurence; can be within current prefix, or within extDict
zmat/lz4/lz4.c:990:         * - offset : if maybe_ext_memSegment==1 (constant)
zmat/lz4/lz4.c:991:         * - lowLimit : must be == dictionary to mean "match is within extDict"; must be == source otherwise
zmat/lz4/lz4.c:992:         * - token and *token : position to write 4-bits for match length; higher 4-bits for literal length supposed already written
zmat/lz4/lz4.c:996:            (op + 2 /* offset */ + 1 /* token */ + MFLIMIT - MINMATCH /* min last literals so last match is <= end - MFLIMIT */ > olimit)) {
zmat/lz4/lz4.c:1004:            DEBUGLOG(6, "             with offset=%u  (ext if > %i)", offset, (int)(ip - (const BYTE*)source));
zmat/lz4/lz4.c:1008:            DEBUGLOG(6, "             with offset=%u  (same segment)", (U32)(ip - match));
zmat/lz4/lz4.c:1009:            assert(ip-match <= LZ4_DISTANCE_MAX);
zmat/lz4/lz4.c:1010:            LZ4_writeLE16(op, (U16)(ip - match)); op+=2;
zmat/lz4/lz4.c:1018:                const BYTE* limit = ip + (dictEnd-match);
zmat/lz4/lz4.c:1039:                    U32 newMatchCode = 15 /* in token */ - 1 /* to avoid needing a zero byte */ + ((U32)(olimit - op) - 1 - LASTLITERALS) * 255;
zmat/lz4/lz4.c:1040:                    ip -= matchCode - newMatchCode;
zmat/lz4/lz4.c:1050:                        DEBUGLOG(5, "Clearing %u positions", (U32)(filledIp - ip));
zmat/lz4/lz4.c:1053:                            LZ4_clearHash(h, cctx->hashTable, tableType);
zmat/lz4/lz4.c:1063:                matchCode -= ML_MASK;
zmat/lz4/lz4.c:1068:                    matchCode -= 4*255;
zmat/lz4/lz4.c:1084:        LZ4_putPosition(ip-2, cctx->hashTable, tableType, base);
zmat/lz4/lz4.c:1089:            match = LZ4_getPosition(ip, cctx->hashTable, tableType, base);
zmat/lz4/lz4.c:1090:            LZ4_putPosition(ip, cctx->hashTable, tableType, base);
zmat/lz4/lz4.c:1098:            U32 const current = (U32)(ip-base);
zmat/lz4/lz4.c:1099:            U32 matchIndex = LZ4_getIndexOnHash(h, cctx->hashTable, tableType);
zmat/lz4/lz4.c:1104:                    matchIndex = LZ4_getIndexOnHash(h, dictCtx->hashTable, byU32);
zmat/lz4/lz4.c:1123:            LZ4_putIndexOnHash(current, h, cctx->hashTable, tableType);
zmat/lz4/lz4.c:1130:                if (maybe_extMem) offset = current - matchIndex;
zmat/lz4/lz4.c:1132:                            (int)(anchor-(const BYTE*)source), 0, (int)(ip-(const BYTE*)source));
zmat/lz4/lz4.c:1144:    {   size_t lastRun = (size_t)(iend - anchor);
zmat/lz4/lz4.c:1146:            (op + lastRun + 1 + ((lastRun+255-RUN_MASK)/255) > olimit)) {
zmat/lz4/lz4.c:1150:                lastRun  = (size_t)(olimit-op) - 1;
zmat/lz4/lz4.c:1151:                lastRun -= (lastRun+240)/255;
zmat/lz4/lz4.c:1158:            size_t accumulator = lastRun - RUN_MASK;
zmat/lz4/lz4.c:1160:            for(; accumulator >= 255 ; accumulator-=255) *op++ = 255;
zmat/lz4/lz4.c:1171:        *inputConsumed = (int) (((const char*)ip)-source);
zmat/lz4/lz4.c:1173:    DEBUGLOG(5, "LZ4_compress_generic: compressed %i bytes into %i bytes", inputSize, (int)(((char*)op) - dest));
zmat/lz4/lz4.c:1174:    result = (int)(((char*)op) - dest);
zmat/lz4/lz4.c:1182:    LZ4_stream_t_internal* const ctx = & LZ4_initStream(state, sizeof(LZ4_stream_t)) -> internal_donotuse;
zmat/lz4/lz4.c:1213:    LZ4_stream_t_internal* ctx = &((LZ4_stream_t*)state)->internal_donotuse;
zmat/lz4/lz4.c:1220:            if (ctx->currentOffset) {
zmat/lz4/lz4.c:1234:            if (ctx->currentOffset) {
zmat/lz4/lz4.c:1252:    LZ4_stream_t* ctxPtr = ALLOC(sizeof(LZ4_stream_t));   /* malloc-calloc always properly aligned */
zmat/lz4/lz4.c:1301:            return LZ4_compress_generic(&state->internal_donotuse, src, dst, *srcSizePtr, srcSizePtr, targetDstSize, fillOutput, byU16, noDict, noDictIssue, 1);
zmat/lz4/lz4.c:1304:            return LZ4_compress_generic(&state->internal_donotuse, src, dst, *srcSizePtr, srcSizePtr, targetDstSize, fillOutput, addrMode, noDict, noDictIssue, 1);
zmat/lz4/lz4.c:1312:    LZ4_stream_t* ctx = (LZ4_stream_t*)ALLOC(sizeof(LZ4_stream_t));   /* malloc-calloc always properly aligned */
zmat/lz4/lz4.c:1329:/*-******************************
zmat/lz4/lz4.c:1343:#ifndef _MSC_VER  /* for some reason, Visual fails the aligment test on 32-bit x86 :
zmat/lz4/lz4.c:1344:                     it reports an aligment of 8-bytes,
zmat/lz4/lz4.c:1349:    return sizeof(t_a) - sizeof(t_a.t);
zmat/lz4/lz4.c:1358:#ifndef _MSC_VER  /* for some reason, Visual fails the aligment test on 32-bit x86 :
zmat/lz4/lz4.c:1359:                     it reports an aligment of 8-bytes,
zmat/lz4/lz4.c:1361:    if (((size_t)buffer) & (LZ4_stream_t_alignment() - 1)) { return NULL; } /* alignment check */
zmat/lz4/lz4.c:1376:    LZ4_prepareTable(&(ctx->internal_donotuse), 0, byU32);
zmat/lz4/lz4.c:1391:    LZ4_stream_t_internal* dict = &LZ4_dict->internal_donotuse;
zmat/lz4/lz4.c:1411:    dict->currentOffset += 64 KB;
zmat/lz4/lz4.c:1417:    if ((dictEnd - p) > 64 KB) p = dictEnd - 64 KB;
zmat/lz4/lz4.c:1418:    base = dictEnd - dict->currentOffset;
zmat/lz4/lz4.c:1419:    dict->dictionary = p;
zmat/lz4/lz4.c:1420:    dict->dictSize = (U32)(dictEnd - p);
zmat/lz4/lz4.c:1421:    dict->tableType = tableType;
zmat/lz4/lz4.c:1423:    while (p <= dictEnd-HASH_UNIT) {
zmat/lz4/lz4.c:1424:        LZ4_putPosition(p, dict->hashTable, tableType, base);
zmat/lz4/lz4.c:1428:    return (int)dict->dictSize;
zmat/lz4/lz4.c:1433:        &(dictionaryStream->internal_donotuse);
zmat/lz4/lz4.c:1437:             dictCtx != NULL ? dictCtx->dictSize : 0);
zmat/lz4/lz4.c:1449:         * to bump the offset to something non-zero.
zmat/lz4/lz4.c:1451:        if (workingStream->internal_donotuse.currentOffset == 0) {
zmat/lz4/lz4.c:1452:            workingStream->internal_donotuse.currentOffset = 64 KB;
zmat/lz4/lz4.c:1457:        if (dictCtx->dictSize == 0) {
zmat/lz4/lz4.c:1461:    workingStream->internal_donotuse.dictCtx = dictCtx;
zmat/lz4/lz4.c:1468:    if (LZ4_dict->currentOffset + (unsigned)nextSize > 0x80000000) {   /* potential ptrdiff_t overflow (32-bits mode) */
zmat/lz4/lz4.c:1470:        U32 const delta = LZ4_dict->currentOffset - 64 KB;
zmat/lz4/lz4.c:1471:        const BYTE* dictEnd = LZ4_dict->dictionary + LZ4_dict->dictSize;
zmat/lz4/lz4.c:1475:            if (LZ4_dict->hashTable[i] < delta) LZ4_dict->hashTable[i]=0;
zmat/lz4/lz4.c:1476:            else LZ4_dict->hashTable[i] -= delta;
zmat/lz4/lz4.c:1478:        LZ4_dict->currentOffset = 64 KB;
zmat/lz4/lz4.c:1479:        if (LZ4_dict->dictSize > 64 KB) LZ4_dict->dictSize = 64 KB;
zmat/lz4/lz4.c:1480:        LZ4_dict->dictionary = dictEnd - LZ4_dict->dictSize;
zmat/lz4/lz4.c:1491:    LZ4_stream_t_internal* streamPtr = &LZ4_stream->internal_donotuse;
zmat/lz4/lz4.c:1492:    const BYTE* dictEnd = streamPtr->dictionary + streamPtr->dictSize;
zmat/lz4/lz4.c:1496:    if (streamPtr->dirty) { return 0; } /* Uninitialized structure detected */
zmat/lz4/lz4.c:1501:    if ( (streamPtr->dictSize-1 < 4-1)   /* intentional underflow */
zmat/lz4/lz4.c:1503:        DEBUGLOG(5, "LZ4_compress_fast_continue: dictSize(%u) at addr:%p is too small", streamPtr->dictSize, streamPtr->dictionary);
zmat/lz4/lz4.c:1504:        streamPtr->dictSize = 0;
zmat/lz4/lz4.c:1505:        streamPtr->dictionary = (const BYTE*)source;
zmat/lz4/lz4.c:1511:        if ((sourceEnd > streamPtr->dictionary) && (sourceEnd < dictEnd)) {
zmat/lz4/lz4.c:1512:            streamPtr->dictSize = (U32)(dictEnd - sourceEnd);
zmat/lz4/lz4.c:1513:            if (streamPtr->dictSize > 64 KB) streamPtr->dictSize = 64 KB;
zmat/lz4/lz4.c:1514:            if (streamPtr->dictSize < 4) streamPtr->dictSize = 0;
zmat/lz4/lz4.c:1515:            streamPtr->dictionary = dictEnd - streamPtr->dictSize;
zmat/lz4/lz4.c:1521:        if ((streamPtr->dictSize < 64 KB) && (streamPtr->dictSize < streamPtr->currentOffset))
zmat/lz4/lz4.c:1529:        if (streamPtr->dictCtx) {
zmat/lz4/lz4.c:1532:             * to offsets between dictCtx->currentOffset - 64 KB and
zmat/lz4/lz4.c:1533:             * dictCtx->currentOffset - dictCtx->dictSize. This makes it safe
zmat/lz4/lz4.c:1541:                memcpy(streamPtr, streamPtr->dictCtx, sizeof(LZ4_stream_t));
zmat/lz4/lz4.c:1547:            if ((streamPtr->dictSize < 64 KB) && (streamPtr->dictSize < streamPtr->currentOffset)) {
zmat/lz4/lz4.c:1553:        streamPtr->dictionary = (const BYTE*)source;
zmat/lz4/lz4.c:1554:        streamPtr->dictSize = (U32)inputSize;
zmat/lz4/lz4.c:1560:/* Hidden debug function, to force-test external dictionary mode */
zmat/lz4/lz4.c:1563:    LZ4_stream_t_internal* streamPtr = &LZ4_dict->internal_donotuse;
zmat/lz4/lz4.c:1568:    if ((streamPtr->dictSize < 64 KB) && (streamPtr->dictSize < streamPtr->currentOffset)) {
zmat/lz4/lz4.c:1574:    streamPtr->dictionary = (const BYTE*)source;
zmat/lz4/lz4.c:1575:    streamPtr->dictSize = (U32)srcSize;
zmat/lz4/lz4.c:1590:    LZ4_stream_t_internal* const dict = &LZ4_dict->internal_donotuse;
zmat/lz4/lz4.c:1591:    const BYTE* const previousDictEnd = dict->dictionary + dict->dictSize;
zmat/lz4/lz4.c:1594:    if ((U32)dictSize > dict->dictSize) { dictSize = (int)dict->dictSize; }
zmat/lz4/lz4.c:1596:    memmove(safeBuffer, previousDictEnd - dictSize, dictSize);
zmat/lz4/lz4.c:1598:    dict->dictionary = (const BYTE*)safeBuffer;
zmat/lz4/lz4.c:1599:    dict->dictSize = (U32)dictSize;
zmat/lz4/lz4.c:1606:/*-*******************************
zmat/lz4/lz4.c:1616:/* Read the variable-length literal or match length.
zmat/lz4/lz4.c:1618: * ip - pointer to use as input.
zmat/lz4/lz4.c:1619: * lencheck - end ip.  Return an error if ip advances >= lencheck.
zmat/lz4/lz4.c:1620: * loop_check - check ip >= lencheck in body of loop.  Returns loop_error if so.
zmat/lz4/lz4.c:1621: * initial_check - check ip >= lencheck before start of loop.  Returns initial_error if so.
zmat/lz4/lz4.c:1622: * error (output) - error code.  Should be set to 0 before call.
zmat/lz4/lz4.c:1624:typedef enum { loop_error = -2, initial_error = -1, ok = 0 } variable_length_error;
zmat/lz4/lz4.c:1668:    if (src == NULL) { return -1; }
zmat/lz4/lz4.c:1684:        const BYTE* const shortiend = iend - (endOnInput ? 14 : 8) /*maxLL*/ - 2 /*offset*/;
zmat/lz4/lz4.c:1685:        const BYTE* const shortoend = oend - (endOnInput ? 14 : 8) /*maxLL*/ - 18 /*maxML*/;
zmat/lz4/lz4.c:1700:            return ((srcSize==1) && (*ip==0)) ? 0 : -1;
zmat/lz4/lz4.c:1702:        if ((!endOnInput) && (unlikely(outputSize==0))) { return (*ip==0 ? 1 : -1); }
zmat/lz4/lz4.c:1703:        if ((endOnInput) && unlikely(srcSize==0)) { return -1; }
zmat/lz4/lz4.c:1707:        if ((oend - op) < FASTLOOP_SAFE_DISTANCE) {
zmat/lz4/lz4.c:1712:        /* Fast loop : decode sequences as long as output < iend-FASTLOOP_SAFE_DISTANCE */
zmat/lz4/lz4.c:1715:            assert(oend - op >= FASTLOOP_SAFE_DISTANCE);
zmat/lz4/lz4.c:1725:                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
zmat/lz4/lz4.c:1734:                    if ((cpy>oend-32) || (ip+length>iend-32)) { goto safe_literal_copy; }
zmat/lz4/lz4.c:1737:                    if (cpy>oend-8) { goto safe_literal_copy; }
zmat/lz4/lz4.c:1739:                                                 * it doesn't know input length, and only relies on end-of-block properties */
zmat/lz4/lz4.c:1745:                    DEBUGLOG(7, "copy %u bytes in a 16-bytes stripe", (unsigned)length);
zmat/lz4/lz4.c:1747:                    if (ip > iend-(16 + 1/*max lit + offset + nextToken*/)) { goto safe_literal_copy; }
zmat/lz4/lz4.c:1752:                     * it doesn't know input length, and relies on end-of-block properties */
zmat/lz4/lz4.c:1761:            match = op - offset;
zmat/lz4/lz4.c:1770:              length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
zmat/lz4/lz4.c:1774:                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
zmat/lz4/lz4.c:1779:                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
zmat/lz4/lz4.c:1800:                if (unlikely(op+length > oend-LASTLITERALS)) {
zmat/lz4/lz4.c:1802:                        length = MIN(length, (size_t)(oend-op));  /* reach end of buffer */
zmat/lz4/lz4.c:1804:                        goto _output_error;  /* end-of-block condition violated */
zmat/lz4/lz4.c:1807:                if (length <= (size_t)(lowPrefix-match)) {
zmat/lz4/lz4.c:1809:                    memmove(op, dictEnd - (lowPrefix-match), length);
zmat/lz4/lz4.c:1813:                    size_t const copySize = (size_t)(lowPrefix - match);
zmat/lz4/lz4.c:1814:                    size_t const restSize = length - copySize;
zmat/lz4/lz4.c:1815:                    memcpy(op, dictEnd - copySize, copySize);
zmat/lz4/lz4.c:1817:                    if (restSize > (size_t)(op - lowPrefix)) {  /* overlap copy */
zmat/lz4/lz4.c:1831:            assert((op <= oend) && (oend-op >= 32));
zmat/lz4/lz4.c:1850:            /* A two-stage shortcut for the most common case:
zmat/lz4/lz4.c:1860:                /* strictly "less than" on input, to re-enter the loop with at least one byte */
zmat/lz4/lz4.c:1870:                match = op - offset;
zmat/lz4/lz4.c:1894:                length += read_variable_length(&ip, iend-RUN_MASK, endOnInput, endOnInput, &error);
zmat/lz4/lz4.c:1906:            if ( ((endOnInput) && ((cpy>oend-MFLIMIT) || (ip+length>iend-(2+1+LASTLITERALS))) )
zmat/lz4/lz4.c:1907:              || ((!endOnInput) && (cpy>oend-WILDCOPYLENGTH)) )
zmat/lz4/lz4.c:1922:                    if ((ip+length>iend-(2+1+LASTLITERALS)) && (ip+length != iend)) { goto _output_error; }
zmat/lz4/lz4.c:1930:                        length = (size_t)(oend-op);
zmat/lz4/lz4.c:1943:                memmove(op, ip, length);  /* supports overlapping memory regions, which only matters for in-place decompression scenarios */
zmat/lz4/lz4.c:1960:            match = op - offset;
zmat/lz4/lz4.c:1968:              length += read_variable_length(&ip, iend - LASTLITERALS + 1, endOnInput, 0, &error);
zmat/lz4/lz4.c:1980:                if (unlikely(op+length > oend-LASTLITERALS)) {
zmat/lz4/lz4.c:1981:                    if (partialDecoding) length = MIN(length, (size_t)(oend-op));
zmat/lz4/lz4.c:1985:                if (length <= (size_t)(lowPrefix-match)) {
zmat/lz4/lz4.c:1987:                    memmove(op, dictEnd - (lowPrefix-match), length);
zmat/lz4/lz4.c:1991:                    size_t const copySize = (size_t)(lowPrefix - match);
zmat/lz4/lz4.c:1992:                    size_t const restSize = length - copySize;
zmat/lz4/lz4.c:1993:                    memcpy(op, dictEnd - copySize, copySize);
zmat/lz4/lz4.c:1995:                    if (restSize > (size_t)(op - lowPrefix)) {  /* overlap copy */
zmat/lz4/lz4.c:2012:            if (partialDecoding && (cpy > oend-MATCH_SAFEGUARD_DISTANCE)) {
zmat/lz4/lz4.c:2013:                size_t const mlen = MIN(length, (size_t)(oend-op));
zmat/lz4/lz4.c:2034:                match -= dec64table[offset];
zmat/lz4/lz4.c:2041:            if (unlikely(cpy > oend-MATCH_SAFEGUARD_DISTANCE)) {
zmat/lz4/lz4.c:2042:                BYTE* const oCopyLimit = oend - (WILDCOPYLENGTH-1);
zmat/lz4/lz4.c:2043:                if (cpy > oend-LASTLITERALS) { goto _output_error; } /* Error : last LASTLITERALS bytes must be literals (uncompressed) */
zmat/lz4/lz4.c:2046:                    match += oCopyLimit - op;
zmat/lz4/lz4.c:2059:           return (int) (((char*)op)-dst);     /* Nb of output bytes decoded */
zmat/lz4/lz4.c:2061:           return (int) (((const char*)ip)-src);   /* Nb of input bytes read */
zmat/lz4/lz4.c:2066:        return (int) (-(((const char*)ip)-src))-1;
zmat/lz4/lz4.c:2095:                                  (BYTE*)dest - 64 KB, NULL, 0);
zmat/lz4/lz4.c:2105:                                  (BYTE*)dest - 64 KB, NULL, 0);
zmat/lz4/lz4.c:2122:                                  (BYTE*)dest-prefixSize, NULL, 0);
zmat/lz4/lz4.c:2154:                                  (BYTE*)dest-prefixSize, (const BYTE*)dictStart, dictSize);
zmat/lz4/lz4.c:2163:                                  (BYTE*)dest-prefixSize, (const BYTE*)dictStart, dictSize);
zmat/lz4/lz4.c:2190:    LZ4_streamDecode_t_internal* lz4sd = &LZ4_streamDecode->internal_donotuse;
zmat/lz4/lz4.c:2191:    lz4sd->prefixSize = (size_t) dictSize;
zmat/lz4/lz4.c:2192:    lz4sd->prefixEnd = (const BYTE*) dictionary + dictSize;
zmat/lz4/lz4.c:2193:    lz4sd->externalDict = NULL;
zmat/lz4/lz4.c:2194:    lz4sd->extDictSize  = 0;
zmat/lz4/lz4.c:2227:    LZ4_streamDecode_t_internal* lz4sd = &LZ4_streamDecode->internal_donotuse;
zmat/lz4/lz4.c:2230:    if (lz4sd->prefixSize == 0) {
zmat/lz4/lz4.c:2232:        assert(lz4sd->extDictSize == 0);
zmat/lz4/lz4.c:2235:        lz4sd->prefixSize = (size_t)result;
zmat/lz4/lz4.c:2236:        lz4sd->prefixEnd = (BYTE*)dest + result;
zmat/lz4/lz4.c:2237:    } else if (lz4sd->prefixEnd == (BYTE*)dest) {
zmat/lz4/lz4.c:2239:        if (lz4sd->prefixSize >= 64 KB - 1)
zmat/lz4/lz4.c:2241:        else if (lz4sd->extDictSize == 0)
zmat/lz4/lz4.c:2243:                                                         lz4sd->prefixSize);
zmat/lz4/lz4.c:2246:                                                    lz4sd->prefixSize, lz4sd->externalDict, lz4sd->extDictSize);
zmat/lz4/lz4.c:2248:        lz4sd->prefixSize += (size_t)result;
zmat/lz4/lz4.c:2249:        lz4sd->prefixEnd  += result;
zmat/lz4/lz4.c:2252:        lz4sd->extDictSize = lz4sd->prefixSize;
zmat/lz4/lz4.c:2253:        lz4sd->externalDict = lz4sd->prefixEnd - lz4sd->extDictSize;
zmat/lz4/lz4.c:2255:                                                  lz4sd->externalDict, lz4sd->extDictSize);
zmat/lz4/lz4.c:2257:        lz4sd->prefixSize = (size_t)result;
zmat/lz4/lz4.c:2258:        lz4sd->prefixEnd  = (BYTE*)dest + result;
zmat/lz4/lz4.c:2267:    LZ4_streamDecode_t_internal* lz4sd = &LZ4_streamDecode->internal_donotuse;
zmat/lz4/lz4.c:2271:    if (lz4sd->prefixSize == 0) {
zmat/lz4/lz4.c:2272:        assert(lz4sd->extDictSize == 0);
zmat/lz4/lz4.c:2275:        lz4sd->prefixSize = (size_t)originalSize;
zmat/lz4/lz4.c:2276:        lz4sd->prefixEnd = (BYTE*)dest + originalSize;
zmat/lz4/lz4.c:2277:    } else if (lz4sd->prefixEnd == (BYTE*)dest) {
zmat/lz4/lz4.c:2278:        if (lz4sd->prefixSize >= 64 KB - 1 || lz4sd->extDictSize == 0)
zmat/lz4/lz4.c:2282:                                                    lz4sd->prefixSize, lz4sd->externalDict, lz4sd->extDictSize);
zmat/lz4/lz4.c:2284:        lz4sd->prefixSize += (size_t)originalSize;
zmat/lz4/lz4.c:2285:        lz4sd->prefixEnd  += originalSize;
zmat/lz4/lz4.c:2287:        lz4sd->extDictSize = lz4sd->prefixSize;
zmat/lz4/lz4.c:2288:        lz4sd->externalDict = lz4sd->prefixEnd - lz4sd->extDictSize;
zmat/lz4/lz4.c:2290:                                             lz4sd->externalDict, lz4sd->extDictSize);
zmat/lz4/lz4.c:2292:        lz4sd->prefixSize = (size_t)originalSize;
zmat/lz4/lz4.c:2293:        lz4sd->prefixEnd  = (BYTE*)dest + originalSize;
zmat/lz4/lz4.c:2312:        if (dictSize >= 64 KB - 1) {
zmat/lz4/lz4.c:2363:- LZ4_uncompress is totally equivalent to LZ4_decompress_fast
zmat/lz4/lz4.c:2364:- LZ4_uncompress_unknownOutputSize is totally equivalent to LZ4_decompress_safe
zmat/lz4/lz4.c:2394:    /* avoid const char * -> char * conversion warning */
zmat/lz4/lz4.c:2395:    return (char *)(uptrval)((LZ4_stream_t*)state)->internal_donotuse.dictionary;
Binary file zmat/lz4/lz4hc.o matches
zmat/lz4/lz4hc.c:2:    LZ4 HC - High Compression Mode of LZ4
zmat/lz4/lz4hc.c:3:    Copyright (C) 2011-2017, Yann Collet.
zmat/lz4/lz4hc.c:5:    BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
zmat/lz4/lz4hc.c:31:       - LZ4 source repository : https://github.com/lz4/lz4
zmat/lz4/lz4hc.c:32:       - LZ4 public forum : https://groups.google.com/forum/#!forum/lz4c
zmat/lz4/lz4hc.c:58:#  pragma GCC diagnostic ignored "-Wunused-function"
zmat/lz4/lz4hc.c:61:#  pragma clang diagnostic ignored "-Wunused-function"
zmat/lz4/lz4hc.c:74:#define OPTIMAL_ML (int)((ML_MASK-1)+MINMATCH)
zmat/lz4/lz4hc.c:81:#define HASH_FUNCTION(i)         (((i) * 2654435761U) >> ((MINMATCH*8)-LZ4HC_HASH_LOG))
zmat/lz4/lz4hc.c:95:    MEM_INIT((void*)hc4->hashTable, 0, sizeof(hc4->hashTable));
zmat/lz4/lz4hc.c:96:    MEM_INIT(hc4->chainTable, 0xFF, sizeof(hc4->chainTable));
zmat/lz4/lz4hc.c:101:    uptrval startingOffset = (uptrval)(hc4->end - hc4->base);
zmat/lz4/lz4hc.c:107:    hc4->nextToUpdate = (U32) startingOffset;
zmat/lz4/lz4hc.c:108:    hc4->base = start - startingOffset;
zmat/lz4/lz4hc.c:109:    hc4->end = start;
zmat/lz4/lz4hc.c:110:    hc4->dictBase = start - startingOffset;
zmat/lz4/lz4hc.c:111:    hc4->dictLimit = (U32) startingOffset;
zmat/lz4/lz4hc.c:112:    hc4->lowLimit = (U32) startingOffset;
zmat/lz4/lz4hc.c:119:    U16* const chainTable = hc4->chainTable;
zmat/lz4/lz4hc.c:120:    U32* const hashTable  = hc4->hashTable;
zmat/lz4/lz4hc.c:121:    const BYTE* const base = hc4->base;
zmat/lz4/lz4hc.c:122:    U32 const target = (U32)(ip - base);
zmat/lz4/lz4hc.c:123:    U32 idx = hc4->nextToUpdate;
zmat/lz4/lz4hc.c:127:        size_t delta = idx - hashTable[h];
zmat/lz4/lz4hc.c:134:    hc4->nextToUpdate = target;
zmat/lz4/lz4hc.c:144:    int const min = (int)MAX(iMin - ip, mMin - match);
zmat/lz4/lz4hc.c:146:    assert(ip >= iMin); assert((size_t)(ip-iMin) < (1U<<31));
zmat/lz4/lz4hc.c:147:    assert(match >= mMin); assert((size_t)(match - mMin) < (1U<<31));
zmat/lz4/lz4hc.c:149:         && (ip[back-1] == match[back-1]) )
zmat/lz4/lz4hc.c:150:            back--;
zmat/lz4/lz4hc.c:157:#  define LZ4HC_rotl32(x,r) ((x << r) | (x >> (32 - r)))
zmat/lz4/lz4hc.c:163:    size_t const bitsToRotate = (rotate & (sizeof(pattern) - 1)) << 3;
zmat/lz4/lz4hc.c:177:    while (likely(ip < iEnd-(sizeof(pattern)-1))) {
zmat/lz4/lz4hc.c:181:        return (unsigned)(ip - iStart);
zmat/lz4/lz4hc.c:190:        U32 bitOffset = (sizeof(pattern)*8) - 8;
zmat/lz4/lz4hc.c:194:            ip ++; bitOffset -= 8;
zmat/lz4/lz4hc.c:198:    return (unsigned)(ip - iStart);
zmat/lz4/lz4hc.c:210:        if (LZ4_read32(ip-4) != pattern) break;
zmat/lz4/lz4hc.c:211:        ip -= 4;
zmat/lz4/lz4hc.c:215:            if (ip[-1] != *bytePtr) break;
zmat/lz4/lz4hc.c:216:            ip--; bytePtr--;
zmat/lz4/lz4hc.c:218:    return (unsigned)(iStart - ip);
zmat/lz4/lz4hc.c:228:    return ((U32)((dictLimit - 1) - matchIndex) >= 3);
zmat/lz4/lz4hc.c:249:    U16* const chainTable = hc4->chainTable;
zmat/lz4/lz4hc.c:250:    U32* const HashTable = hc4->hashTable;
zmat/lz4/lz4hc.c:251:    const LZ4HC_CCtx_internal * const dictCtx = hc4->dictCtx;
zmat/lz4/lz4hc.c:252:    const BYTE* const base = hc4->base;
zmat/lz4/lz4hc.c:253:    const U32 dictLimit = hc4->dictLimit;
zmat/lz4/lz4hc.c:255:    const U32 ipIndex = (U32)(ip - base);
zmat/lz4/lz4hc.c:256:    const U32 lowestMatchIndex = (hc4->lowLimit + (LZ4_DISTANCE_MAX + 1) > ipIndex) ? hc4->lowLimit : ipIndex - LZ4_DISTANCE_MAX;
zmat/lz4/lz4hc.c:257:    const BYTE* const dictBase = hc4->dictBase;
zmat/lz4/lz4hc.c:258:    int const lookBackLength = (int)(ip-iLowLimit);
zmat/lz4/lz4hc.c:275:        nbAttempts--;
zmat/lz4/lz4hc.c:277:        if (favorDecSpeed && (ipIndex - matchIndex < 8)) {
zmat/lz4/lz4hc.c:284:            if (LZ4_read16(iLowLimit + longest - 1) == LZ4_read16(matchPtr - lookBackLength + longest - 1)) {
zmat/lz4/lz4hc.c:288:                    matchLength -= back;
zmat/lz4/lz4hc.c:297:                const BYTE* const dictStart = dictBase + hc4->lowLimit;
zmat/lz4/lz4hc.c:299:                const BYTE* vLimit = ip + (dictLimit - matchIndex);
zmat/lz4/lz4hc.c:305:                matchLength -= back;
zmat/lz4/lz4hc.c:317:                int const end = longest - MINMATCH + 1;
zmat/lz4/lz4hc.c:332:                    matchIndex -= distanceToNextMatch;
zmat/lz4/lz4hc.c:338:                U32 const matchCandidateIdx = matchIndex-1;
zmat/lz4/lz4hc.c:353:                        const BYTE* const dictStart = dictBase + hc4->lowLimit;
zmat/lz4/lz4hc.c:363:                            if (!extDict && matchPtr - backLength == lowPrefixPtr && hc4->lowLimit < dictLimit) {
zmat/lz4/lz4hc.c:364:                                U32 const rotatedPattern = LZ4HC_rotatePattern((U32)(-(int)backLength), pattern);
zmat/lz4/lz4hc.c:368:                            backLength = matchCandidateIdx - MAX(matchCandidateIdx - (U32)backLength, lowestMatchIndex);
zmat/lz4/lz4hc.c:369:                            assert(matchCandidateIdx - backLength >= lowestMatchIndex);
zmat/lz4/lz4hc.c:374:                                U32 const newMatchIndex = matchCandidateIdx + (U32)forwardPatternLength - (U32)srcPatternLength;  /* best position, full pattern, might be followed by more match */
zmat/lz4/lz4hc.c:379:                                    assert(newMatchIndex >= dictLimit - 3 && newMatchIndex < dictLimit && !extDict);
zmat/lz4/lz4hc.c:383:                                U32 const newMatchIndex = matchCandidateIdx - (U32)backLength;   /* farthest position in current segment, will find a match of length currentSegmentLength + maybe some back */
zmat/lz4/lz4hc.c:385:                                    assert(newMatchIndex >= dictLimit - 3 && newMatchIndex < dictLimit && !extDict);
zmat/lz4/lz4hc.c:393:                                            if (ip - (base+matchIndex) > LZ4_DISTANCE_MAX) break;
zmat/lz4/lz4hc.c:401:                                            matchIndex -= distToNextPattern;
zmat/lz4/lz4hc.c:408:        matchIndex -= DELTANEXTU16(chainTable, matchIndex + matchChainPos);
zmat/lz4/lz4hc.c:414:      && ipIndex - lowestMatchIndex < LZ4_DISTANCE_MAX) {
zmat/lz4/lz4hc.c:415:        size_t const dictEndOffset = (size_t)(dictCtx->end - dictCtx->base);
zmat/lz4/lz4hc.c:416:        U32 dictMatchIndex = dictCtx->hashTable[LZ4HC_hashPtr(ip)];
zmat/lz4/lz4hc.c:418:        matchIndex = dictMatchIndex + lowestMatchIndex - (U32)dictEndOffset;
zmat/lz4/lz4hc.c:419:        while (ipIndex - matchIndex <= LZ4_DISTANCE_MAX && nbAttempts--) {
zmat/lz4/lz4hc.c:420:            const BYTE* const matchPtr = dictCtx->base + dictMatchIndex;
zmat/lz4/lz4hc.c:425:                const BYTE* vLimit = ip + (dictEndOffset - dictMatchIndex);
zmat/lz4/lz4hc.c:428:                back = lookBackLength ? LZ4HC_countBack(ip, matchPtr, iLowLimit, dictCtx->base + dictCtx->dictLimit) : 0;
zmat/lz4/lz4hc.c:429:                mlt -= back;
zmat/lz4/lz4hc.c:436:            {   U32 const nextOffset = DELTANEXTU16(dictCtx->chainTable, dictMatchIndex);
zmat/lz4/lz4hc.c:437:                dictMatchIndex -= nextOffset;
zmat/lz4/lz4hc.c:438:                matchIndex -= nextOffset;
zmat/lz4/lz4hc.c:456:    return LZ4HC_InsertAndGetWiderMatch(hc4, ip, ip, iLimit, MINMATCH-1, matchpos, &uselessPtr, maxNbAttempts, patternAnalysis, 0 /*chainSwap*/, dict, favorCompressionRatio);
zmat/lz4/lz4hc.c:477:    U32 const pos = (start==NULL) ? 0 : (U32)(*anchor - start);
zmat/lz4/lz4hc.c:478:    U32 const ll = (U32)(*ip - *anchor);
zmat/lz4/lz4hc.c:479:    U32 const llAdd = (ll>=15) ? ((ll-15) / 255) + 1 : 0;
zmat/lz4/lz4hc.c:480:    U32 const mlAdd = (matchLength>=19) ? ((matchLength-19) / 255) + 1 : 0;
zmat/lz4/lz4hc.c:484:    DEBUGLOG(6, "pos:%7u -- literals:%3u, match:%4i, offset:%5u, cost:%3u + %u",
zmat/lz4/lz4hc.c:486:                (U32)(*ip - *anchor), matchLength, (U32)(*ip-match),
zmat/lz4/lz4hc.c:492:    length = (size_t)(*ip - *anchor);
zmat/lz4/lz4hc.c:495:        size_t len = length - RUN_MASK;
zmat/lz4/lz4hc.c:497:        for(; len >= 255 ; len -= 255) *(*op)++ = 255;
zmat/lz4/lz4hc.c:508:    assert( (*ip - match) <= LZ4_DISTANCE_MAX );   /* note : consider providing offset as a value, rather than as a pointer difference */
zmat/lz4/lz4hc.c:509:    LZ4_writeLE16(*op, (U16)(*ip-match)); *op += 2;
zmat/lz4/lz4hc.c:513:    length = (size_t)matchLength - MINMATCH;
zmat/lz4/lz4hc.c:517:        length -= ML_MASK;
zmat/lz4/lz4hc.c:518:        for(; length >= 510 ; length -= 510) { *(*op)++ = 255; *(*op)++ = 255; }
zmat/lz4/lz4hc.c:519:        if (length >= 255) { length -= 255; *(*op)++ = 255; }
zmat/lz4/lz4hc.c:549:    const BYTE* const mflimit = iend - MFLIMIT;
zmat/lz4/lz4hc.c:550:    const BYTE* const matchlimit = (iend - LASTLITERALS);
zmat/lz4/lz4hc.c:567:    if (limit == fillOutput) oend -= LASTLITERALS;                  /* Hack for support LZ4 format restriction */
zmat/lz4/lz4hc.c:581:                            ip + ml - 2, ip + 0, matchlimit, ml, &ref2, &start2,
zmat/lz4/lz4hc.c:599:        if ((start2 - ip) < 3) {  /* First Match too small : removed */
zmat/lz4/lz4hc.c:610:        if ((start2 - ip) < OPTIMAL_ML) {
zmat/lz4/lz4hc.c:614:            if (ip+new_ml > start2 + ml2 - MINMATCH) new_ml = (int)(start2 - ip) + ml2 - MINMATCH;
zmat/lz4/lz4hc.c:615:            correction = new_ml - (int)(start2 - ip);
zmat/lz4/lz4hc.c:619:                ml2 -= correction;
zmat/lz4/lz4hc.c:626:                            start2 + ml2 - 3, start2, matchlimit, ml2, &ref3, &start3,
zmat/lz4/lz4hc.c:634:            if (start2 < ip+ml)  ml = (int)(start2 - ip);
zmat/lz4/lz4hc.c:647:                    int correction = (int)(ip+ml - start2);
zmat/lz4/lz4hc.c:650:                    ml2 -= correction;
zmat/lz4/lz4hc.c:682:            if ((start2 - ip) < OPTIMAL_ML) {
zmat/lz4/lz4hc.c:685:                if (ip + ml > start2 + ml2 - MINMATCH) ml = (int)(start2 - ip) + ml2 - MINMATCH;
zmat/lz4/lz4hc.c:686:                correction = ml - (int)(start2 - ip);
zmat/lz4/lz4hc.c:690:                    ml2 -= correction;
zmat/lz4/lz4hc.c:693:                ml = (int)(start2 - ip);
zmat/lz4/lz4hc.c:711:    {   size_t lastRunSize = (size_t)(iend - anchor);  /* literals */
zmat/lz4/lz4hc.c:712:        size_t litLength = (lastRunSize + 255 - RUN_MASK) / 255;
zmat/lz4/lz4hc.c:718:            lastRunSize  = (size_t)(oend - op) - 1;
zmat/lz4/lz4hc.c:719:            litLength = (lastRunSize + 255 - RUN_MASK) / 255;
zmat/lz4/lz4hc.c:720:            lastRunSize -= litLength;
zmat/lz4/lz4hc.c:725:            size_t accumulator = lastRunSize - RUN_MASK;
zmat/lz4/lz4hc.c:727:            for(; accumulator >= 255 ; accumulator -= 255) *op++ = 255;
zmat/lz4/lz4hc.c:737:    *srcSizePtr = (int) (((const char*)ip) - source);
zmat/lz4/lz4hc.c:738:    return (int) (((char*)op)-dest);
zmat/lz4/lz4hc.c:796:    ctx->end += *srcSizePtr;
zmat/lz4/lz4hc.c:800:        HCfavor_e const favor = ctx->favorDecSpeed ? favorDecompressionSpeed : favorCompressionRatio;
zmat/lz4/lz4hc.c:815:        if (result <= 0) ctx->dirty = 1;
zmat/lz4/lz4hc.c:833:    assert(ctx->dictCtx == NULL);
zmat/lz4/lz4hc.c:848:    const size_t position = (size_t)(ctx->end - ctx->base) - ctx->lowLimit;
zmat/lz4/lz4hc.c:849:    assert(ctx->dictCtx != NULL);
zmat/lz4/lz4hc.c:851:        ctx->dictCtx = NULL;
zmat/lz4/lz4hc.c:854:        memcpy(ctx, ctx->dictCtx, sizeof(LZ4HC_CCtx_internal));
zmat/lz4/lz4hc.c:856:        ctx->compressionLevel = (short)cLevel;
zmat/lz4/lz4hc.c:874:    if (ctx->dictCtx == NULL) {
zmat/lz4/lz4hc.c:884:#ifndef _MSC_VER  /* for some reason, Visual fails the aligment test on 32-bit x86 :
zmat/lz4/lz4hc.c:885:                   * it reports an aligment of 8-bytes,
zmat/lz4/lz4hc.c:890:    return sizeof(t_a) - sizeof(t_a.t);
zmat/lz4/lz4hc.c:898:    LZ4HC_CCtx_internal* const ctx = &((LZ4_streamHC_t*)state)->internal_donotuse;
zmat/lz4/lz4hc.c:899:#ifndef _MSC_VER  /* for some reason, Visual fails the aligment test on 32-bit x86 :
zmat/lz4/lz4hc.c:900:                   * it reports an aligment of 8-bytes,
zmat/lz4/lz4hc.c:902:    assert(((size_t)state & (LZ4_streamHC_t_alignment() - 1)) == 0);  /* check alignment */
zmat/lz4/lz4hc.c:904:    if (((size_t)(state)&(sizeof(void*)-1)) != 0) return 0;   /* Error : state is not aligned for pointers (32 or 64 bits) */
zmat/lz4/lz4hc.c:940:    LZ4HC_init_internal(&ctx->internal_donotuse, (const BYTE*) source);
zmat/lz4/lz4hc.c:942:    return LZ4HC_compress_generic(&ctx->internal_donotuse, source, dest, sourceSizePtr, targetDestSize, cLevel, fillOutput);
zmat/lz4/lz4hc.c:973:#ifndef _MSC_VER  /* for some reason, Visual fails the aligment test on 32-bit x86 :
zmat/lz4/lz4hc.c:974:                   * it reports an aligment of 8-bytes,
zmat/lz4/lz4hc.c:976:    if (((size_t)buffer) & (LZ4_streamHC_t_alignment() - 1)) return NULL;  /* alignment check */
zmat/lz4/lz4hc.c:981:    /* end-base will trigger a clearTable on starting compression */
zmat/lz4/lz4hc.c:982:    LZ4_streamHCPtr->internal_donotuse.end = (const BYTE *)(ptrdiff_t)-1;
zmat/lz4/lz4hc.c:983:    LZ4_streamHCPtr->internal_donotuse.base = NULL;
zmat/lz4/lz4hc.c:984:    LZ4_streamHCPtr->internal_donotuse.dictCtx = NULL;
zmat/lz4/lz4hc.c:985:    LZ4_streamHCPtr->internal_donotuse.favorDecSpeed = 0;
zmat/lz4/lz4hc.c:986:    LZ4_streamHCPtr->internal_donotuse.dirty = 0;
zmat/lz4/lz4hc.c:1001:    if (LZ4_streamHCPtr->internal_donotuse.dirty) {
zmat/lz4/lz4hc.c:1004:        /* preserve end - base : can trigger clearTable's threshold */
zmat/lz4/lz4hc.c:1005:        LZ4_streamHCPtr->internal_donotuse.end -= (uptrval)LZ4_streamHCPtr->internal_donotuse.base;
zmat/lz4/lz4hc.c:1006:        LZ4_streamHCPtr->internal_donotuse.base = NULL;
zmat/lz4/lz4hc.c:1007:        LZ4_streamHCPtr->internal_donotuse.dictCtx = NULL;
zmat/lz4/lz4hc.c:1017:    LZ4_streamHCPtr->internal_donotuse.compressionLevel = (short)compressionLevel;
zmat/lz4/lz4hc.c:1022:    LZ4_streamHCPtr->internal_donotuse.favorDecSpeed = (favor!=0);
zmat/lz4/lz4hc.c:1030:    LZ4HC_CCtx_internal* const ctxPtr = &LZ4_streamHCPtr->internal_donotuse;
zmat/lz4/lz4hc.c:1034:        dictionary += (size_t)dictSize - 64 KB;
zmat/lz4/lz4hc.c:1037:    /* need a full initialization, there are bad side-effects when using resetFast() */
zmat/lz4/lz4hc.c:1038:    {   int const cLevel = ctxPtr->compressionLevel;
zmat/lz4/lz4hc.c:1043:    ctxPtr->end = (const BYTE*)dictionary + dictSize;
zmat/lz4/lz4hc.c:1044:    if (dictSize >= 4) LZ4HC_Insert (ctxPtr, ctxPtr->end-3);
zmat/lz4/lz4hc.c:1049:    working_stream->internal_donotuse.dictCtx = dictionary_stream != NULL ? &(dictionary_stream->internal_donotuse) : NULL;
zmat/lz4/lz4hc.c:1057:    if (ctxPtr->end >= ctxPtr->base + ctxPtr->dictLimit + 4)
zmat/lz4/lz4hc.c:1058:        LZ4HC_Insert (ctxPtr, ctxPtr->end-3);   /* Referencing remaining dictionary content */
zmat/lz4/lz4hc.c:1061:    ctxPtr->lowLimit  = ctxPtr->dictLimit;
zmat/lz4/lz4hc.c:1062:    ctxPtr->dictLimit = (U32)(ctxPtr->end - ctxPtr->base);
zmat/lz4/lz4hc.c:1063:    ctxPtr->dictBase  = ctxPtr->base;
zmat/lz4/lz4hc.c:1064:    ctxPtr->base = newBlock - ctxPtr->dictLimit;
zmat/lz4/lz4hc.c:1065:    ctxPtr->end  = newBlock;
zmat/lz4/lz4hc.c:1066:    ctxPtr->nextToUpdate = ctxPtr->dictLimit;   /* match referencing will resume from there */
zmat/lz4/lz4hc.c:1069:    ctxPtr->dictCtx = NULL;
zmat/lz4/lz4hc.c:1077:    LZ4HC_CCtx_internal* const ctxPtr = &LZ4_streamHCPtr->internal_donotuse;
zmat/lz4/lz4hc.c:1081:    /* auto-init if forgotten */
zmat/lz4/lz4hc.c:1082:    if (ctxPtr->base == NULL) LZ4HC_init_internal (ctxPtr, (const BYTE*) src);
zmat/lz4/lz4hc.c:1085:    if ((size_t)(ctxPtr->end - ctxPtr->base) > 2 GB) {
zmat/lz4/lz4hc.c:1086:        size_t dictSize = (size_t)(ctxPtr->end - ctxPtr->base) - ctxPtr->dictLimit;
zmat/lz4/lz4hc.c:1088:        LZ4_loadDictHC(LZ4_streamHCPtr, (const char*)(ctxPtr->end) - dictSize, (int)dictSize);
zmat/lz4/lz4hc.c:1092:    if ((const BYTE*)src != ctxPtr->end)
zmat/lz4/lz4hc.c:1097:        const BYTE* const dictBegin = ctxPtr->dictBase + ctxPtr->lowLimit;
zmat/lz4/lz4hc.c:1098:        const BYTE* const dictEnd   = ctxPtr->dictBase + ctxPtr->dictLimit;
zmat/lz4/lz4hc.c:1101:            ctxPtr->lowLimit = (U32)(sourceEnd - ctxPtr->dictBase);
zmat/lz4/lz4hc.c:1102:            if (ctxPtr->dictLimit - ctxPtr->lowLimit < 4) ctxPtr->lowLimit = ctxPtr->dictLimit;
zmat/lz4/lz4hc.c:1106:    return LZ4HC_compress_generic (ctxPtr, src, dst, srcSizePtr, dstCapacity, ctxPtr->compressionLevel, limit);
zmat/lz4/lz4hc.c:1128:    LZ4HC_CCtx_internal* const streamPtr = &LZ4_streamHCPtr->internal_donotuse;
zmat/lz4/lz4hc.c:1129:    int const prefixSize = (int)(streamPtr->end - (streamPtr->base + streamPtr->dictLimit));
zmat/lz4/lz4hc.c:1134:    memmove(safeBuffer, streamPtr->end - dictSize, dictSize);
zmat/lz4/lz4hc.c:1135:    {   U32 const endIndex = (U32)(streamPtr->end - streamPtr->base);
zmat/lz4/lz4hc.c:1136:        streamPtr->end = (const BYTE*)safeBuffer + dictSize;
zmat/lz4/lz4hc.c:1137:        streamPtr->base = streamPtr->end - endIndex;
zmat/lz4/lz4hc.c:1138:        streamPtr->dictLimit = endIndex - (U32)dictSize;
zmat/lz4/lz4hc.c:1139:        streamPtr->lowLimit = endIndex - (U32)dictSize;
zmat/lz4/lz4hc.c:1140:        if (streamPtr->nextToUpdate < streamPtr->dictLimit) streamPtr->nextToUpdate = streamPtr->dictLimit;
zmat/lz4/lz4hc.c:1174:    LZ4HC_init_internal (&hc4->internal_donotuse, (const BYTE*)inputBuffer);
zmat/lz4/lz4hc.c:1182:    LZ4HC_init_internal (&hc4->internal_donotuse, (const BYTE*)inputBuffer);
zmat/lz4/lz4hc.c:1195:    return LZ4HC_compress_generic (&((LZ4_streamHC_t*)LZ4HC_Data)->internal_donotuse, src, dst, &srcSize, 0, cLevel, notLimited);
zmat/lz4/lz4hc.c:1200:    return LZ4HC_compress_generic (&((LZ4_streamHC_t*)LZ4HC_Data)->internal_donotuse, src, dst, &srcSize, dstCapacity, cLevel, limitedOutput);
zmat/lz4/lz4hc.c:1206:    const BYTE *bufferStart = ctx->internal_donotuse.base + ctx->internal_donotuse.lowLimit;
zmat/lz4/lz4hc.c:1207:    LZ4_resetStreamHC_fast(ctx, ctx->internal_donotuse.compressionLevel);
zmat/lz4/lz4hc.c:1208:    /* avoid const char * -> char * conversion warning :( */
zmat/lz4/lz4hc.c:1214: *  LZ4 Optimal parser (levels [LZ4HC_CLEVEL_OPT_MIN - LZ4HC_CLEVEL_MAX])
zmat/lz4/lz4hc.c:1229:        price += 1 + ((litlen-(int)RUN_MASK) / 255);
zmat/lz4/lz4hc.c:1237:    int price = 1 + 2 ; /* token + 16-bit offset */
zmat/lz4/lz4hc.c:1244:        price += 1 + ((mlen-(int)(ML_MASK+MINMATCH)) / 255);
zmat/lz4/lz4hc.c:1273:    match.off = (int)(ip-matchPtr);
zmat/lz4/lz4hc.c:1296:    const BYTE* const mflimit = iend - MFLIMIT;
zmat/lz4/lz4hc.c:1297:    const BYTE* const matchlimit = iend - LASTLITERALS;
zmat/lz4/lz4hc.c:1305:    if (limit == fillOutput) oend -= LASTLITERALS;   /* Hack for support LZ4 format restriction */
zmat/lz4/lz4hc.c:1306:    if (sufficient_len >= LZ4_OPT_NUM) sufficient_len = LZ4_OPT_NUM-1;
zmat/lz4/lz4hc.c:1309:    assert(ip - anchor < LZ4_MAX_INPUT_SIZE);
zmat/lz4/lz4hc.c:1311:         int const llen = (int)(ip - anchor);
zmat/lz4/lz4hc.c:1315:         LZ4HC_match_t const firstMatch = LZ4HC_FindLongerMatch(ctx, ip, matchlimit, MINMATCH-1, nbSearches, dict, favorDecSpeed);
zmat/lz4/lz4hc.c:1321:             const BYTE* const matchPos = ip - firstMatch.off;
zmat/lz4/lz4hc.c:1336:                 DEBUGLOG(7, "rPos:%3i => price:%3i (litlen=%i) -- initial setup",
zmat/lz4/lz4hc.c:1350:                 DEBUGLOG(7, "rPos:%3i => price:%3i (matchlen=%i) -- initial setup",
zmat/lz4/lz4hc.c:1360:                 DEBUGLOG(7, "rPos:%3i => price:%3i (litlen=%i) -- initial setup",
zmat/lz4/lz4hc.c:1385:                 newMatch = LZ4HC_FindLongerMatch(ctx, curPtr, matchlimit, MINMATCH-1, nbSearches, dict, favorDecSpeed);
zmat/lz4/lz4hc.c:1388:                 newMatch = LZ4HC_FindLongerMatch(ctx, curPtr, matchlimit, last_match_pos - cur, nbSearches, dict, favorDecSpeed);
zmat/lz4/lz4hc.c:1404:                     int const price = opt[cur].price - LZ4HC_literalsPrice(baseLitlen) + LZ4HC_literalsPrice(baseLitlen+litlen);
zmat/lz4/lz4hc.c:1429:                         price = ((cur > ll) ? opt[cur - ll].price : 0)
zmat/lz4/lz4hc.c:1438:                      || price <= opt[pos].price - (int)favorDecSpeed) {
zmat/lz4/lz4hc.c:1464:         cur = last_match_pos - best_mlen;
zmat/lz4/lz4hc.c:1483:                 candidate_pos -= next_matchLength;
zmat/lz4/lz4hc.c:1496:                 if ( LZ4HC_encodeSequence(UPDATABLE(ip, op, anchor), ml, ip - offset, limit, oend) )   /* updates ip, op and anchor */
zmat/lz4/lz4hc.c:1503:     {   size_t lastRunSize = (size_t)(iend - anchor);  /* literals */
zmat/lz4/lz4hc.c:1504:         size_t litLength = (lastRunSize + 255 - RUN_MASK) / 255;
zmat/lz4/lz4hc.c:1510:             lastRunSize  = (size_t)(oend - op) - 1;
zmat/lz4/lz4hc.c:1511:             litLength = (lastRunSize + 255 - RUN_MASK) / 255;
zmat/lz4/lz4hc.c:1512:             lastRunSize -= litLength;
zmat/lz4/lz4hc.c:1517:             size_t accumulator = lastRunSize - RUN_MASK;
zmat/lz4/lz4hc.c:1519:             for(; accumulator >= 255 ; accumulator -= 255) *op++ = 255;
zmat/lz4/lz4hc.c:1529:     *srcSizePtr = (int) (((const char*)ip) - source);
zmat/lz4/lz4hc.c:1530:     return (int) ((char*)op-dst);
zmat/zmatlib.h:5:**  \copyright Qianqian Fang, 2019-2020
mmc_optix_ray.h:14:    float photontimer;            /**< the total time-of-fly of the photon */
mmc_highorder.cpp:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_highorder.cpp:5:**  \copyright Qianqian Fang, 2010-2021
mmc_highorder.cpp:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_highorder.cpp:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_highorder.cpp:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_highorder.cpp:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_highorder.cpp:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_highorder.cpp:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_highorder.cpp:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_highorder.cpp:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_highorder.cpp:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_highorder.cpp:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_highorder.cpp:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_highorder.cpp:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_highorder.cpp:48:    int pos, n1, n2, oldnn = mesh->nn;
mmc_highorder.cpp:61:    if (mesh->elem2 == NULL) {
mmc_highorder.cpp:62:        mesh->elem2 = (int*)calloc(sizeof(int) * TETEDGE, mesh->ne);
mmc_highorder.cpp:65:    for (int eid = 0; eid < mesh->ne; eid++)
mmc_highorder.cpp:67:            ee = (int*)(&mesh->elem[eid]);
mmc_highorder.cpp:76:                pos = edgelist.size() - 1;
mmc_highorder.cpp:83:            mesh->elem2[eid * TETEDGE + ed] = pos;
mmc_highorder.cpp:88:    mesh->nn += edgelist.size();
mmc_highorder.cpp:89:    mesh->node = (MMCfloat3*)realloc((void*)mesh->node, sizeof(MMCfloat3) * (mesh->nn));
mmc_highorder.cpp:90:    mesh->weight = (double*)realloc((void*)mesh->weight, sizeof(double) * mesh->nn * cfg->maxgate);
mmc_highorder.cpp:91:    memset(mesh->weight, 0, sizeof(double)*mesh->nn * cfg->maxgate); // if mesh->weight is filled, need to allocate a new buffer, and copy the old buffer gate by gate
mmc_highorder.cpp:95:            ((float*)(&mesh->node[oldnn + pos]))[i] =
mmc_highorder.cpp:96:                (((float*)(&mesh->node[(*it).first]))[i] + ((float*)(&mesh->node[(*it).second]))[i]) * 0.5f;
mmc_const.h:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_const.h:5:**  \copyright Qianqian Fang, 2010-2021
mmc_const.h:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_const.h:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_const.h:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_const.h:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_const.h:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_const.h:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_const.h:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_const.h:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_const.h:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_const.h:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_const.h:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_const.h:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_const.h:40:#define MCX_DEBUG_REC_LEN  6  /**<  number of floating points per position saved when -D M is used for trajectory */
mmc_const.h:42:#define MCX_SRC_PENCIL     0  /**<  default-Pencil beam src, no param */
mmc_const.h:54:#define MCX_SRC_LINE       12 /**<  a non-directional line source */
mmc_cu_host.h:2:**  \mainpage Mesh-based Monte Carlo (MMC) - a 3D photon simulator
mmc_cu_host.h:5:**  \copyright Qianqian Fang, 2010-2021
mmc_cu_host.h:8:**  \li \c (\b Fang2010) Qianqian Fang, <a href="http://www.opticsinfobase.org/abstract.cfm?uri=boe-1-1-165">
mmc_cu_host.h:9:**          "Mesh-based Monte Carlo Method Using Fast Ray-Tracing
mmc_cu_host.h:10:**          in Plucker Coordinates,"</a> Biomed. Opt. Express, 1(1) 165-175 (2010).
mmc_cu_host.h:12:**           <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-3-12-3223">
mmc_cu_host.h:13:**          "Accelerating mesh-based Monte Carlo method on modern CPU architectures,"</a>
mmc_cu_host.h:14:**          Biomed. Opt. Express 3(12), 3223-3230 (2012)
mmc_cu_host.h:16:**          <a href="https://www.osapublishing.org/boe/abstract.cfm?uri=boe-7-1-171">
mmc_cu_host.h:17:**          "Generalized mesh-based Monte Carlo for wide-field illumination and detection
mmc_cu_host.h:18:**           via mesh retessellation,"</a> Biomed. Optics Express, 7(1), 171-184 (2016)
mmc_cu_host.h:21:**          "Graphics processing unit-accelerated mesh-based Monte Carlo photon transport
mmc_cu_host.h:24:**          <a href="https://www.osapublishing.org/boe/fulltext.cfm?uri=boe-12-1-147">
mmc_cu_host.h:26:**           mesh-based Monte Carlo algorithm,"</a> Biomed. Optics Express, 12(1) 147-161 (2021)
mmc_cu_host.h:50:#define ABS(a)  ((a)<0?-(a):(a))
